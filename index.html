<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v3 – TEC Forecast & Verification Tool (Leaflet版, 3日予報・加算+SuperStorm+Base手動Flare)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin: 0 0 4px 0;
      letter-spacing: 0.03em;
    }
    h1 { font-size: 20px; }
    h2 { font-size: 16px; }
    h3 { font-size: 14px; }

    .page {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 430px;
      min-width: 360px;
      max-width: 480px;
      border-right: 1px solid #222b3f;
      padding: 10px;
      overflow-y: auto;
      background: radial-gradient(circle at top, #1c2740 0, #050814 55%, #050814 100%);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
      min-width: 0;
      overflow-y: auto;
    }

    .card {
      background: rgba(10, 16, 32, 0.96);
      border: 1px solid #222b3f;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 4px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .card-header span {
      font-size: 11px;
      opacity: 0.7;
    }

    textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #334;
      background: #050814;
      color: #f5f5f5;
      font-family: "Consolas","Menlo",monospace;
    }
    input[type="number"],
    input[type="text"],
    input[type="color"],
    select {
      background: #050814;
      border-radius: 4px;
      border: 1px solid #334;
      color: #f5f5f5;
      font-size: 11px;
      padding: 2px 4px;
      font-family: inherit;
    }
    input[type="checkbox"] {
      transform: scale(0.9);
    }
    label {
      font-size: 11px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-bottom: 4px;
      align-items: center;
      flex-wrap: wrap;
    }
    .row > div {
      flex: 1;
      min-width: 80px;
    }
    button {
      border-radius: 4px;
      border: 1px solid #3b82f6;
      background: #1d4ed8;
      color: #f9fafb;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary {
      border-color: #4b5563;
      background: #111827;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .small {
      font-size: 10px;
      opacity: 0.8;
    }
    pre {
      font-size: 11px;
      background: #050814;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #222b3f;
      white-space: pre-wrap;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }
    th, td {
      border: 1px solid #222b3f;
      padding: 2px 4px;
      text-align: center;
    }
    th {
      background: #111827;
    }
    .flex-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-card { flex: 0 0 auto; }
    .map-card {
      flex: 1 1 auto;
      min-height: 55vh;
      display: flex;
    }
    .output-card { flex: 0 0 auto; }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      flex-wrap: wrap;
    }
    #timeSlider {
      flex: 1;
      min-width: 120px;
    }

    #tecMap {
      flex: 1;
      height: 100%;
      min-height: 360px;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .leaflet-container {
      background: #000;
    }
    .tec-canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 400;
    }

    .leaflet-control.tec-legend {
      background: rgba(5, 8, 20, 0.95);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #222b3f;
      color: #f5f5f5;
      font-size: 10px;
      line-height: 1.3;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
    }
    .tec-legend-title {
      text-align: center;
      margin-bottom: 4px;
      font-weight: 600;
      letter-spacing: 0.05em;
    }
    .tec-legend-bar {
      width: 18px;
      height: 130px;
      margin: 0 auto 4px auto;
      border-radius: 4px;
      border: 1px solid #444;
    }
    .tec-legend-labels {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
    }

    .output-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .output-col {
      flex: 1;
      min-width: 200px;
      display: flex;
      flex-direction: column;
    }

    .output-col pre {
      max-height: 220px;
      overflow-y: auto;
    }

    hr {
      border: none;
      border-top: 1px solid #222b3f;
      margin: 4px 0;
    }

    .focus-btn {
      width: 100%;
      font-size: 9px;
      padding: 3px 2px;
    }
  </style>
</head>
<body>
  <div class="page">
    <!-- ============= サイドバー ============= -->
    <div class="sidebar">
      <div class="card">
        <div class="card-header">
          <h1>SWIFT-TEC v3</h1>
          <span>Global TEC Forecast (3-day, 加算+SuperStorm+Base手動Flare)</span>
        </div>
        <div class="small">
          ・BoM TEC（最大9枚）から <b>3日 / 30min</b> 予報を生成<br>
          ・BaseTEC（静穏）＋ ΔStorm(Kp) ＋ ΔFlare<br>
          ・Base用フレア：<b>実測イベントを手動入力</b><br>
          ・予報用フレア：<b>DeepFlareNet 9領域確率</b><br>
          ・Kp≦7: Mukhtarov, Kp≧8: SuperStorm ΔTECmax(EIA) モード
        </div>
      </div>

      <!-- 1. BoM TEC 予報用 -->
      <div class="card">
        <div class="card-header">
          <h2>1. BoM TEC（予報用 最大9枚）</h2>
          <span>World0000_tec.txt などをコピペ</span>
        </div>
        <div class="row small">
          <div>BoM #1</div><div>BoM #2</div><div>BoM #3</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput1" placeholder="# PRODUCT NAME..."></textarea></div>
          <div><textarea id="bomInput2"></textarea></div>
          <div><textarea id="bomInput3"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #4</div><div>BoM #5</div><div>BoM #6</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput4"></textarea></div>
          <div><textarea id="bomInput5"></textarea></div>
          <div><textarea id="bomInput6"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #7</div><div>BoM #8</div><div>BoM #9</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput7"></textarea></div>
          <div><textarea id="bomInput8"></textarea></div>
          <div><textarea id="bomInput9"></textarea></div>
        </div>
        <div class="row">
          <button onclick="saveBomInputs()">BoM入力を保存</button>
          <button class="secondary" onclick="clearBomInputsStorage()">保存を削除</button>
        </div>
        <div class="small" id="bomInfo">
          ※「BoM入力を保存」を押した時点の内容をブラウザに保存。次回起動時に自動復元。
        </div>
      </div>

      <!-- 2. NOAA Kp テキスト（Base用+予報用） -->
      <div class="card">
        <div class="card-header">
          <h2>2. Kp テキスト</h2>
          <span>Base 実測 / 予報</span>
        </div>
        <div class="small">
          ●Base逆算用 Kp（実測 or 解析値）<br>
          　→ 例の JSON テーブル<br>
          　　<code>[["time_tag","Kp",...],["2025-11-26 00:00:00.000","3.33",...],...]</code><br>
          ●予報用 Kp<br>
          　→ <b>3-Day Forecast</b> を丸ごと貼り付け or 簡易形式
        </div>
        <div class="row">
          <div>
            <label>Kp 実測テキスト（BaseTEC 逆算用）</label><br>
            <textarea id="noaaKpBaseText" placeholder='[["time_tag","Kp","a_running","station_count"],["2025-11-26 00:00:00.000","3.33","18","8"], ...]'></textarea>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Kp 予報テキスト（3-Day Forecast）</label><br>
            <textarea id="noaaKpText" placeholder=":Product: 3-Day Forecast から最後までを丸ごと貼り付け"></textarea>
          </div>
        </div>
      </div>

      <!-- 3. Base用フレアイベント（手動） -->
      <div class="card">
        <div class="card-header">
          <h2>3. Base用フレアイベント（実測）</h2>
          <span>BaseTEC 逆算でのみ使用</span>
        </div>
        <div class="small">
          ・ここで入力したフレアは <b>BaseTEC 逆算にだけ効く</b><br>
          ・予報側のフレアは DeepFlareNet 9領域で別計算<br>
          ・時間はUTCで指定（例: <code>2025-11-26 03:00</code> や <code>2025-11-26T03:00Z</code>）<br>
          ・範囲は緯度・経度の矩形で指定（空欄なら全地球）<br>
          ・ΔTECmax はそのイベントの最大増分[TECU]（推奨 0〜15）
        </div>
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>開始UTC</th>
              <th>終了UTC</th>
              <th>Lat min</th>
              <th>Lat max</th>
              <th>Lon min</th>
              <th>Lon max</th>
              <th>ΔTECmax</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1</td>
              <td><input id="baseFlareStart1" type="text" placeholder="2025-11-26 03:00"></td>
              <td><input id="baseFlareEnd1"   type="text" placeholder="2025-11-26 06:00"></td>
              <td><input id="baseFlareLatMin1" type="number" step="1" style="width:60px;" placeholder="-90"></td>
              <td><input id="baseFlareLatMax1" type="number" step="1" style="width:60px;" placeholder="90"></td>
              <td><input id="baseFlareLonMin1" type="number" step="1" style="width:60px;" placeholder="-180"></td>
              <td><input id="baseFlareLonMax1" type="number" step="1" style="width:60px;" placeholder="180"></td>
              <td><input id="baseFlareDelta1"  type="number" step="0.5" style="width:60px;" placeholder="10"></td>
            </tr>
            <tr>
              <td>2</td>
              <td><input id="baseFlareStart2" type="text"></td>
              <td><input id="baseFlareEnd2"   type="text"></td>
              <td><input id="baseFlareLatMin2" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareLatMax2" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareLonMin2" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareLonMax2" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareDelta2"  type="number" step="0.5" style="width:60px;"></td>
            </tr>
            <tr>
              <td>3</td>
              <td><input id="baseFlareStart3" type="text"></td>
              <td><input id="baseFlareEnd3"   type="text"></td>
              <td><input id="baseFlareLatMin3" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareLatMax3" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareLonMin3" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareLonMax3" type="number" step="1" style="width:60px;"></td>
              <td><input id="baseFlareDelta3"  type="number" step="0.5" style="width:60px;"></td>
            </tr>
          </tbody>
        </table>
        <div class="small" style="margin-top:4px;">
          ※ΔTECの実効値は <b>DaySide(LT)</b> を掛けて昼側だけ効くようにしています（Base用）。
        </div>
      </div>

      <!-- 4. Deep Flare Net 9領域（予報用） -->
      <div class="card">
        <div class="card-header">
          <h2>4. Deep Flare Net 領域（予報）</h2>
          <span>9分割フレア確率</span>
        </div>
        <div class="small">
          太陽円盤を 3×3 の 9領域に分割し、各領域ごとの Xクラス / Mクラス発生確率 [%] を入力。<br>
          位置イメージ：<br>
          R1=北西, R2=北, R3=北東 / R4=西, R5=中央, R6=東 / R7=南西, R8=南, R9=南東<br>
          → ここから <b>予報用 ΔFlare</b> を計算（Baseには使わない）。
        </div>
        <table>
          <thead>
            <tr>
              <th>ID</th><th>位置イメージ</th><th>P(X≥) %</th><th>P(M≥) %</th><th>使用</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>R1</td><td>北西</td>
              <td><input id="fx1" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm1" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu1" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R2</td><td>北</td>
              <td><input id="fx2" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm2" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu2" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R3</td><td>北東</td>
              <td><input id="fx3" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm3" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu3" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R4</td><td>西</td>
              <td><input id="fx4" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm4" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu4" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R5</td><td>中央</td>
              <td><input id="fx5" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm5" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu5" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R6</td><td>東</td>
              <td><input id="fx6" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm6" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu6" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R7</td><td>南西</td>
              <td><input id="fx7" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm7" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu7" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R8</td><td>南</td>
              <td><input id="fx8" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm8" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu8" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R9</td><td>南東</td>
              <td><input id="fx9" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm9" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu9" type="checkbox" checked></td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- 5. TEC カラーマップ設定 -->
      <div class="card">
        <div class="card-header">
          <h2>5. TEC カラーマップ設定</h2>
          <span>TEC値 → 色を任意設定</span>
        </div>
        <div class="small">
          TEC [TECU] の上限と色を設定。色は Leaflet 地図と凡例に反映されます。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>TEC上限[TECU]</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="tLimit1" type="number" value="10" style="width:60px;"></td>
              <td><input id="tColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="tLimit2" type="number" value="30" style="width:60px;"></td>
              <td><input id="tColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="tLimit3" type="number" value="60" style="width:60px;"></td>
              <td><input id="tColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="tLimit4" type="number" value="120" style="width:60px;"></td>
              <td><input id="tColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyTecColorScale()">TEC色を反映</button>
          <button class="secondary" onclick="resetTecColorScale()">初期化</button>
        </div>
      </div>

      <!-- 6. GPS L1誤差 カラーマップ設定 -->
      <div class="card">
        <div class="card-header">
          <h2>6. GPS L1誤差 カラーマップ</h2>
          <span>誤差[m] → 色を任意設定</span>
        </div>
        <div class="small">
          L1即位誤差 [m] の上限と色を設定。TEC×kL1 で換算。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>誤差上限[m]</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="gLimit1" type="number" value="5" style="width:60px;"></td>
              <td><input id="gColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="gLimit2" type="number" value="10" style="width:60px;"></td>
              <td><input id="gColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="gLimit3" type="number" value="20" style="width:60px;"></td>
              <td><input id="gColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="gLimit4" type="number" value="40" style="width:60px;"></td>
              <td><input id="gColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyGpsColorScale()">GPS色を反映</button>
          <button class="secondary" onclick="resetGpsColorScale()">初期化</button>
        </div>
      </div>

      <!-- 7. 係数設定 -->
      <div class="card">
        <div class="card-header">
          <h2>7. 係数設定（Advanced）</h2>
          <span>Base / Storm / Flare / GPS変換</span>
        </div>
        <div class="small">※いじり過ぎる前に現在値をどこかにメモ推奨。</div>
        <div class="flex-col">
          <div class="row">
            <div>
              <label>kBase（BoM静穏ベース倍率）</label><br>
              <input id="cfg_kBase" type="number" value="1.0" step="0.1">
            </div>
            <div>
              <label>kStorm（ΔStorm倍率）</label><br>
              <input id="cfg_kStorm" type="number" value="1.0" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>β_flare（予報用）</label><br>
              <input id="cfg_betaFlare" type="number" value="0.7" step="0.05">
            </div>
            <div>
              <label>k_X（予報：Xフレア寄与）</label><br>
              <input id="cfg_kX" type="number" value="1.0" step="0.1">
            </div>
            <div>
              <label>k_M（予報：Mフレア寄与）</label><br>
              <input id="cfg_kM" type="number" value="0.5" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>kL1（TEC→L1誤差[m/TECU]）</label><br>
              <input id="cfg_kL1" type="number" value="0.16" step="0.01">
            </div>
          </div>
        </div>
        <div class="row">
          <button onclick="saveConfig()">設定を保存</button>
          <button class="secondary" onclick="loadConfig(true)">保存値を再読込</button>
        </div>
      </div>

      <!-- 8. 地域フォーカス -->
      <div class="card">
        <div class="card-header">
          <h2>8. 地域フォーカス</h2>
          <span>地図ズームに反映</span>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('japan')">日本</button>
          <button class="focus-btn" onclick="focusRegion('northAmerica')">北アメリカ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('southAmerica')">南アメリカ</button>
          <button class="focus-btn" onclick="focusRegion('europe')">ヨーロッパ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('africa')">アフリカ</button>
          <button class="focus-btn" onclick="focusRegion('australia')">オーストラリア</button>
        </div>
        <hr>
        <div class="small">手動指定（緯度・経度 範囲）</div>
        <div class="row">
          <div>
            <label>Lat min</label><br>
            <input id="focusLatMin" type="number" value="-10" step="1">
          </div>
          <div>
            <label>Lat max</label><br>
            <input id="focusLatMax" type="number" value="50" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Lon min</label><br>
            <input id="focusLonMin" type="number" value="120" step="1">
          </div>
          <div>
            <label>Lon max</label><br>
            <input id="focusLonMax" type="number" value="150" step="1">
          </div>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="applyManualFocus()">手動フォーカス適用</button>
          <button class="focus-btn secondary" onclick="resetFocus()">全体表示</button>
        </div>
      </div>

      <!-- 9. 実行 -->
      <div class="card">
        <div class="card-header">
          <h2>9. 実行</h2>
          <span>予報 & 描画</span>
        </div>
        <div class="row small">
          <div style="flex:1;">
            予報スタート時刻（UTC, BoM有効時刻から選択）:<br>
            <select id="forecastStartSelect" style="width:100%;"></select>
          </div>
        </div>
        <div class="small" id="forecastStartInfo">
          BoMを読み込むと候補が自動で入ります。未選択時は最も早い有効時刻から開始します。
        </div>
        <div class="row" style="margin-top:4px;">
          <button onclick="runForecast()">TEC予報を計算</button>
          <button class="secondary" onclick="resetAll()">リセット</button>
        </div>
        <div id="runInfo" class="small"></div>
      </div>
    </div>

    <!-- ============= メイン領域 ============= -->
    <div class="main">
      <!-- 上段：時間スライダー＋透明度＋表示モード -->
      <div class="card slider-card">
        <div class="slider-row">
          <span>時間スライダー（0〜3日 / 30分刻み）</span>
          <input type="range" id="timeSlider" min="0" max="144" value="0" oninput="onSliderChange()">
          <span id="timeLabel">t = 0.00 h</span>
          <span id="utcLabel">UTC: --</span>
          <span id="kpNowLabel">Kp=--</span>
        </div>
        <div class="row small" style="margin-top:4px;">
          <div style="flex:1;">
            TEC透明度:
            <input id="tecAlpha" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;" oninput="onTecAlphaChange()">
          </div>
          <div style="flex:1;">
            表示モード:
            <select id="mapModeSelect" onchange="changeMapMode()">
              <option value="tec">TEC [TECU]</option>
              <option value="gps">GPS L1誤差 [m]</option>
            </select>
          </div>
          <div style="flex:2;">
            <span class="small">※地図をズーム／ドラッグして、任意の地域の TEC / GPS誤差 分布を確認できます。</span>
          </div>
        </div>
      </div>

      <!-- 中段：Leaflet 地図 -->
      <div class="card map-card">
        <div id="tecMap"></div>
      </div>

      <!-- 下段：式 & クリックTEC値 -->
      <div class="card output-card">
        <div class="output-row">
          <div class="output-col" style="flex:2;">
            <h3>10. 現在の計算式（加算+SuperStorm+Base手動Flare）</h3>
            <pre id="formulaText">(Base + ΔStorm + ΔFlare の式をここに表示)</pre>
          </div>
          <div class="output-col" style="flex:1;">
            <h3>11. 現在の TEC / GPS値</h3>
            <pre id="pointInfo">地図上をクリックすると、その格子点のTEC・GPS L1誤差と位置が表示されます。</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ============ グローバル状態 ============ */
    const FORECAST_HOURS = 24 * 3;   // 3日分
    const DT_MINUTES     = 30;       // 30分刻み

    let gGrid = null;              // {latArr, lonArr, nLat, nLon}
    let gForecastFrames = [];      // [step][iLat][iLon] TEC_total
    let gForecastTimes  = [];      // Date[]
    let gForecastStart  = null;    // Date (UTC)
    let currentStepIndex = 0;

    // TEC カラー
    let gTecColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 30,  color: "#ffff00" },
      { limit: 60,  color: "#ff9900" },
      { limit: 120, color: "#ff0000" }
    ];

    // GPS L1 誤差 カラー
    let gGpsColorScale = [
      { limit: 5,  color: "#00ff00" },
      { limit: 10, color: "#ffff00" },
      { limit: 20, color: "#ff9900" },
      { limit: 40, color: "#ff0000" }
    ];

    // Kp(t) シリーズ
    let gKpSeries        = []; // 予報用（3-Day Forecast）
    let gKpSeriesBase    = []; // Base逆算用（実測JSONなど）

    // Leaflet 関連
    let map = null;
    let tecCanvas = null;
    let tecCtx = null;
    let tecLegendControl = null;
    let tecAlpha = 0.8;

    let mapMode = "tec";   // 'tec' or 'gps'

    // 地域フォーカス
    let currentFocus = null; // {latMin,latMax,lonMin,lonMax}

    const STORAGE_KEY_CONFIG   = "swifttec_config_v5_additive_superstorm_baseflare";
    const STORAGE_KEY_BOM      = "swifttec_bom_inputs_v5_additive_superstorm_baseflare";
    const STORAGE_KEY_TCOL     = "swifttec_teccol_v3";
    const STORAGE_KEY_GCOL     = "swifttec_gpscol_v1";

    // SuperStorm パラメータ（Kp>=8用）
    const SUPERSTORM_KP8 = 0.7;  // Kp=8 → S_super ≈ 0.7 (昼側)
    const SUPERSTORM_KP9 = 1.0;  // Kp=9 → S_super ≈ 1.0 (昼側)

    function logInfo(msg) {
      const div = document.getElementById("runInfo");
      if (div) div.textContent = msg;
      console.log(msg);
    }
    function clamp(v, a, b) { return v < a ? a : (v > b ? b : v); }

    /* ===== Local Time & 昼夜ウェイト（Base用 LT減衰） ===== */
    // ★修正ポイント1：UTではなく「地方時 LT」で昼夜判定し、
    //   BaseTEC の夜間減衰は LT のみで 24h 周期にする

    // UTC と経度から Local Time [h]（0〜24）を計算
    function getLocalTimeHours(tUtc, lonDeg) {
      let lt = tUtc.getUTCHours() + tUtc.getUTCMinutes()/60 + lonDeg/15;
      lt = ((lt % 24) + 24) % 24;
      return lt;
    }

    // フレアや SuperStorm など「昼側だけ効かせる」ための DaySide(LT)
    function calcDaySideWeight(ltHour) {
      const ang = Math.PI * (ltHour - 14.0) / 12.0;
      const w = Math.cos(ang);
      return w > 0 ? w : 0;
    }

    // BaseTEC 用：LTベースの夜間減衰（UT日付には依存しない）
    // ・LT≈14h で 1.0
    // ・深夜帯で ≈0.3
    // ・同じ LT なら何日目でも同じ係数
    function calcBaseNightFactor(ltHour) {
      const maxFactor = 1.0;
      const minFactor = 0.3;
      const offsetHours = -2; // LT=14h で最大になるよう補正 → (LT-2) がピーク中心

      let x = (ltHour + offsetHours + 24) % 24;
      const nightFactor =
        minFactor +
        (maxFactor - minFactor) * 0.5 * (1 + Math.cos(2 * Math.PI * (x / 24)));

      return nightFactor;
    }

    /* ===== SuperStorm: ΔTEC_max(φ) & S_super(Kp,LT) ===== */

    // Zakharenkova 風 EIA二山プロファイル
    // ΔTEC_max(φ) = 20 + 80 [ exp(-(φ-25)^2/10^2) + exp(-(φ+25)^2/10^2) ]
    function sstorm_super_deltaMax(latDeg) {
      const x1 = (latDeg - 25.0) / 10.0;
      const x2 = (latDeg + 25.0) / 10.0;
      return 20.0 + 80.0 * (Math.exp(-x1 * x1) + Math.exp(-x2 * x2));
    }

    // S_super(Kp,LT):
    //  - Kp=8 → ≈0.7, Kp=9 → 1.0 (昼側)
    //  - 夜側は DaySide(LT)=0 で 0
    function sstorm_super_factor(Kp, ltHour) {
      const dayW = calcDaySideWeight(ltHour);
      if (dayW <= 0) return 0.0;

      const norm = clamp((Kp - 8.0) / 1.0, 0.0, 1.0);
      const fKp = SUPERSTORM_KP8 + (SUPERSTORM_KP9 - SUPERSTORM_KP8) * norm; // 8→0.7,9→1.0
      return dayW * fKp;
    }

    /* ===== 日付パース: VALID DATE/TIME: 11/11/2025 00:00:00UTC ===== */
    function parseBomValidTime(text) {
      const lines = text.split(/\r?\n/);
      for (const line of lines) {
        const m = line.match(/VALID DATE\/TIME:\s*(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/i);
        if (m) {
          const d  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const y  = parseInt(m[3],10);
          const hh = parseInt(m[4],10);
          const mm = parseInt(m[5],10);
          const ss = parseInt(m[6],10);
          return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
        }
      }
      return null;
    }

    /* ====== BoM TEC テキスト → 格子データ ====== */
    function parseBoM(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (!lines.length) throw new Error("空のテキストです。");

      let latMin, latMax, latStep, nLat;
      let lonMin, lonMax, lonStep, nLon;

      for (const line of lines) {
        if (/LATITUDE GRID/i.test(line)) {
          const m = line.match(/LATITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            latMin  = parseFloat(m[1]);
            latMax  = parseFloat(m[2]);
            latStep = parseFloat(m[3]);
            nLat    = parseInt(m[4],10);
          }
        } else if (/LONGITUDE GRID/i.test(line)) {
          const m = line.match(/LONGITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            lonMin  = parseFloat(m[1]);
            lonMax  = parseFloat(m[2]);
            lonStep = parseFloat(m[3]);
            nLon    = parseInt(m[4],10);
          }
        }
      }
      if (latMin === undefined || lonMin === undefined) {
        throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません。");
      }

      const valLines = lines.filter(l => !l.trim().startsWith("#") && !/GRID/i.test(l));
      const values = [];
      for (const ln of valLines) {
        const parts = ln.split(/[, ]+/).map(x => x.trim()).filter(x => x.length>0);
        for (const p of parts) {
          const v = parseFloat(p);
          if (!isNaN(v)) values.push(v);
        }
      }
      if (values.length !== nLat*nLon) {
        throw new Error(`データ数が不一致です: ${values.length} vs ${nLat*nLon}`);
      }

      const latArr = [];
      for (let i=0;i<nLat;i++) latArr.push(latMin + latStep*i);
      const lonArr = [];
      for (let j=0;j<nLon;j++) lonArr.push(lonMin + lonStep*j);

      const grid = new Array(nLat);
      let idx = 0;
      for (let i=0;i<nLat;i++) {
        grid[i] = new Array(nLon);
        for (let j=0;j<nLon;j++) {
          grid[i][j] = values[idx++];
        }
      }

      const validTime = parseBomValidTime(text);
      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============ BoM 入力保存 ============ */
    function saveBomInputs() {
      const data = {
        bomInput1: document.getElementById("bomInput1").value,
        bomInput2: document.getElementById("bomInput2").value,
        bomInput3: document.getElementById("bomInput3").value,
        bomInput4: document.getElementById("bomInput4").value,
        bomInput5: document.getElementById("bomInput5").value,
        bomInput6: document.getElementById("bomInput6").value,
        bomInput7: document.getElementById("bomInput7").value,
        bomInput8: document.getElementById("bomInput8").value,
        bomInput9: document.getElementById("bomInput9").value,
      };
      localStorage.setItem(STORAGE_KEY_BOM, JSON.stringify(data));
      logInfo("BoM入力を保存しました。（次回起動時に自動復元）");
    }

    function loadBomInputsFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_BOM);
      if (!s) return;
      try {
        const data = JSON.parse(s);
        if (data.bomInput1 !== undefined) document.getElementById("bomInput1").value = data.bomInput1;
        if (data.bomInput2 !== undefined) document.getElementById("bomInput2").value = data.bomInput2;
        if (data.bomInput3 !== undefined) document.getElementById("bomInput3").value = data.bomInput3;
        if (data.bomInput4 !== undefined) document.getElementById("bomInput4").value = data.bomInput4;
        if (data.bomInput5 !== undefined) document.getElementById("bomInput5").value = data.bomInput5;
        if (data.bomInput6 !== undefined) document.getElementById("bomInput6").value = data.bomInput6;
        if (data.bomInput7 !== undefined) document.getElementById("bomInput7").value = data.bomInput7;
        if (data.bomInput8 !== undefined) document.getElementById("bomInput8").value = data.bomInput8;
        if (data.bomInput9 !== undefined) document.getElementById("bomInput9").value = data.bomInput9;
      } catch(e) {
        console.warn("BoM入力の復元に失敗:", e);
      }
    }

    function clearBomInputsStorage() {
      localStorage.removeItem(STORAGE_KEY_BOM);
      logInfo("保存されていた BoM 入力を削除しました。（テキスト内容はそのまま）");
    }

    /* ============ Config（係数） ============ */
    function getConfigFromUI() {
      return {
        kBase:     parseFloat(document.getElementById("cfg_kBase").value)     || 1.0,
        kStorm:    parseFloat(document.getElementById("cfg_kStorm").value)    || 1.0,
        betaFlare: parseFloat(document.getElementById("cfg_betaFlare").value) || 0.7,
        kX:        parseFloat(document.getElementById("cfg_kX").value)        || 1.0,
        kM:        parseFloat(document.getElementById("cfg_kM").value)        || 0.5,
        kL1:       parseFloat(document.getElementById("cfg_kL1").value)       || 0.16
      };
    }

    function applyConfigToUI(cfg) {
      document.getElementById("cfg_kBase").value     = cfg.kBase     ?? 1.0;
      document.getElementById("cfg_kStorm").value    = cfg.kStorm    ?? 1.0;
      document.getElementById("cfg_betaFlare").value = cfg.betaFlare ?? 0.7;
      document.getElementById("cfg_kX").value        = cfg.kX        ?? 1.0;
      document.getElementById("cfg_kM").value        = cfg.kM        ?? 0.5;
      document.getElementById("cfg_kL1").value       = cfg.kL1       ?? 0.16;

      updateFormulaText();
    }

    function saveConfig() {
      const cfg = getConfigFromUI();
      localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(cfg));
      logInfo("係数設定を保存しました。");
      updateFormulaText();
    }

    function loadConfig(apply) {
      const s = localStorage.getItem(STORAGE_KEY_CONFIG);
      if (!s) {
        if (apply) {
          updateFormulaText();
          logInfo("保存された係数がありません。初期値を使用。");
        }
        return null;
      }
      try {
        const cfg = JSON.parse(s);
        if (apply) applyConfigToUI(cfg);
        return cfg;
      } catch(e) {
        console.warn("Configの復元に失敗:", e);
        return null;
      }
    }

    /* ============ TEC / GPS カラーマップ設定 ============ */
    function applyTecColorScale() {
      const limits = [
        parseFloat(document.getElementById("tLimit1").value) || 10,
        parseFloat(document.getElementById("tLimit2").value) || 30,
        parseFloat(document.getElementById("tLimit3").value) || 60,
        parseFloat(document.getElementById("tLimit4").value) || 120
      ];
      const cols = [
        document.getElementById("tColor1").value || "#00ff00",
        document.getElementById("tColor2").value || "#ffff00",
        document.getElementById("tColor3").value || "#ff9900",
        document.getElementById("tColor4").value || "#ff0000"
      ];
      gTecColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      logInfo("TECカラースケールを保存しました。");
      updateTecLegend();
      drawTecOverlay();
    }

    function resetTecColorScale() {
      gTecColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 30,  color: "#ffff00" },
        { limit: 60,  color: "#ff9900" },
        { limit: 120, color: "#ff0000" }
      ];
      document.getElementById("tLimit1").value = 10;
      document.getElementById("tLimit2").value = 30;
      document.getElementById("tLimit3").value = 60;
      document.getElementById("tLimit4").value = 120;
      document.getElementById("tColor1").value = "#00ff00";
      document.getElementById("tColor2").value = "#ffff00";
      document.getElementById("tColor3").value = "#ff9900";
      document.getElementById("tColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      updateTecLegend();
      drawTecOverlay();
    }

    function loadTecColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_TCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gTecColorScale = arr;
        document.getElementById("tLimit1").value = arr[0].limit;
        document.getElementById("tLimit2").value = arr[1].limit;
        document.getElementById("tLimit3").value = arr[2].limit;
        document.getElementById("tLimit4").value = arr[3].limit;
        document.getElementById("tColor1").value = arr[0].color;
        document.getElementById("tColor2").value = arr[1].color;
        document.getElementById("tColor3").value = arr[2].color;
        document.getElementById("tColor4").value = arr[3].color;
      } catch(e) {
        console.warn("TEC色スケール復元に失敗:", e);
      }
    }

    function applyGpsColorScale() {
      const limits = [
        parseFloat(document.getElementById("gLimit1").value) || 5,
        parseFloat(document.getElementById("gLimit2").value) || 10,
        parseFloat(document.getElementById("gLimit3").value) || 20,
        parseFloat(document.getElementById("gLimit4").value) || 40
      ];
      const cols = [
        document.getElementById("gColor1").value || "#00ff00",
        document.getElementById("gColor2").value || "#ffff00",
        document.getElementById("gColor3").value || "#ff9900",
        document.getElementById("gColor4").value || "#ff0000"
      ];
      gGpsColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      logInfo("GPS色スケールを保存しました。");
      updateTecLegend();
      drawTecOverlay();
    }

    function resetGpsColorScale() {
      gGpsColorScale = [
        { limit: 5,  color: "#00ff00" },
        { limit: 10, color: "#ffff00" },
        { limit: 20, color: "#ff9900" },
        { limit: 40, color: "#ff0000" }
      ];
      document.getElementById("gLimit1").value = 5;
      document.getElementById("gLimit2").value = 10;
      document.getElementById("gLimit3").value = 20;
      document.getElementById("gLimit4").value = 40;
      document.getElementById("gColor1").value = "#00ff00";
      document.getElementById("gColor2").value = "#ffff00";
      document.getElementById("gColor3").value = "#ff9900";
      document.getElementById("gColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      updateTecLegend();
      drawTecOverlay();
    }

    function loadGpsColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_GCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gGpsColorScale = arr;
        document.getElementById("gLimit1").value = arr[0].limit;
        document.getElementById("gLimit2").value = arr[1].limit;
        document.getElementById("gLimit3").value = arr[2].limit;
        document.getElementById("gLimit4").value = arr[3].limit;
        document.getElementById("gColor1").value = arr[0].color;
        document.getElementById("gColor2").value = arr[1].color;
        document.getElementById("gColor3").value = arr[2].color;
        document.getElementById("gColor4").value = arr[3].color;
      } catch(e) {
        console.warn("GPS色スケール復元に失敗:", e);
      }
    }

    /* ===== NOAA / JSON Kp テキストパーサ ===== */

    function tryParseKpJsonTable(text) {
      let arr;
      try {
        arr = JSON.parse(text);
      } catch (e) {
        return null;
      }
      if (!Array.isArray(arr) || arr.length < 2 || !Array.isArray(arr[0])) return null;
      const header = arr[0];
      const idxTime = header.indexOf("time_tag");
      const idxKp   = header.indexOf("Kp");
      if (idxTime < 0 || idxKp < 0) return null;

      const out = [];
      for (let i = 1; i < arr.length; i++) {
        const row = arr[i];
        if (!Array.isArray(row)) continue;
        const ts = row[idxTime];
        const kpStr = row[idxKp];
        if (!ts || kpStr == null) continue;

        const m = String(ts).match(/(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})/);
        if (!m) continue;
        const y  = parseInt(m[1],10);
        const mo = parseInt(m[2],10);
        const d  = parseInt(m[3],10);
        const hh = parseInt(m[4],10);
        const mm = parseInt(m[5],10);
        const ss = parseInt(m[6],10);
        const t = new Date(Date.UTC(y, mo-1, d, hh, mm, ss));

        const kp = parseFloat(kpStr);
        if (isNaN(kp)) continue;

        out.push({ time: t, kp: kp });
      }
      out.sort((a,b) => a.time - b.time);
      return out;
    }

    function parseKpText(raw) {
      const text = raw || "";

      const jsonResult = tryParseKpJsonTable(text);
      if (jsonResult && jsonResult.length) return jsonResult;

      if (/NOAA Kp index breakdown/i.test(text)) {
        return parseKpFrom3Day(text);
      }

      const lines = text.split(/\r?\n/);
      const out = [];
      for (const line of lines) {
        const m = line.match(/(\d{4})[\/\-\s](\d{1,2})[\/\-\s](\d{1,2})[T\s]+(\d{1,2})/);
        if (!m) continue;
        const y  = parseInt(m[1],10);
        const mo = parseInt(m[2],10);
        const d  = parseInt(m[3],10);
        const hh = parseInt(m[4],10);
        const tokens = line.trim().split(/\s+/);
        if (!tokens.length) continue;
        const kpToken = tokens[tokens.length-1];
        let kp = null;
        let m3 = kpToken.match(/^(\d+(\.\d+)?)/);
        if (m3) {
          kp = parseFloat(m3[1]);
        } else {
          const m4 = kpToken.match(/^([0-9])([\-+o]?)$/i);
          if (m4) {
            kp = parseInt(m4[1],10);
            const sfx = m4[2];
            if (sfx === "+") kp += 0.33;
            else if (sfx === "-") kp -= 0.33;
          }
        }
        if (kp === null || isNaN(kp)) continue;
        const t = new Date(Date.UTC(y, mo-1, d, hh, 0, 0));
        out.push({ time: t, kp: kp });
      }
      out.sort((a,b) => a.time - b.time);
      return out;
    }

    function parseKpFrom3Day(raw) {
      const lines = raw.split(/\r?\n/);
      const out = [];
      const monthMap = {
        Jan:0, Feb:1, Mar:2, Apr:3, May:4, Jun:5,
        Jul:6, Aug:7, Sep:8, Oct:9, Nov:10, Dec:11
      };

      let idxBreak = -1;
      for (let i=0;i<lines.length;i++) {
        if (/NOAA Kp index breakdown/i.test(lines[i])) {
          idxBreak = i;
          break;
        }
      }
      if (idxBreak < 0) return out;

      let year = null;
      const mYear = lines[idxBreak].match(/(\d{4})\s*$/);
      if (mYear) year = parseInt(mYear[1],10);

      let headerLine = null;
      let headerIndex = -1;
      for (let i=idxBreak+1;i<lines.length;i++) {
        const ln = lines[i].trim();
        if (!ln) continue;
        if (/[A-Za-z]{3}\s+\d{1,2}/.test(ln)) {
          headerLine = lines[i];
          headerIndex = i;
          break;
        }
      }
     	if (!headerLine || year === null) return out;

      const headerTokens = headerLine.trim().split(/\s+/);
      if (headerTokens.length % 2 !== 0) return out;
      const colDates = [];
      for (let i=0;i<headerTokens.length;i+=2) {
        const mon = headerTokens[i];
        const day = parseInt(headerTokens[i+1],10);
        const mi  = monthMap[mon] !== undefined ? monthMap[mon] : monthMap[mon.slice(0,3)];
        if (mi === undefined || isNaN(day)) continue;
        colDates.push(new Date(Date.UTC(year, mi, day, 0, 0, 0)));
      }
      if (!colDates.length) return out;

      const patUT = /^\s*(\d{2})-(\d{2})UT/;
      for (let i=headerIndex+1;i<lines.length;i++) {
        const line = lines[i];
        const m = line.match(patUT);
        if (!m) continue;
        const startHour = parseInt(m[1],10);
        const tokens = line.trim().split(/\s+/);
        if (tokens.length < 1 + colDates.length) continue;

        for (let c=0;c<colDates.length;c++) {
          const vStr = tokens[1+c];
          const kpVal = parseFloat(vStr);
          if (!isNaN(kpVal)) {
            const baseDate = colDates[c];
            const t = new Date(Date.UTC(
              baseDate.getUTCFullYear(),
              baseDate.getUTCMonth(),
              baseDate.getUTCDate(),
              startHour, 0, 0
            ));
            out.push({ time: t, kp: kpVal });
          }
        }
      }

      out.sort((a,b) => a.time - b.time);
      return out;
    }

    function sampleSeriesAtUtc(series, tUtc, stepLike=false) {
      if (!series || series.length === 0) return null;
      if (tUtc <= series[0].time) return series[0].kp;
      const last = series[series.length-1];
      if (tUtc >= last.time) return last.kp;
      for (let i=1;i<series.length;i++) {
        if (tUtc < series[i].time) {
          if (stepLike) {
            return series[i-1].kp;
          } else {
            const a = series[i-1];
            const b = series[i];
            const vA = a.kp;
            const vB = b.kp;
            const tA = a.time.getTime();
            const tB = b.time.getTime();
            const f  = (tUtc.getTime() - tA) / (tB - tA);
            return vA * (1-f) + vB * f;
          }
        }
      }
      return last.kp;
    }

    /* ===== Deep Flare Net 入力 → 予報用 ΔFlare ===== */
    function getDeepFlareProbs() {
      let sumX = 0, sumM = 0, count = 0;
      for (let i=1;i<=9;i++) {
        const use = document.getElementById("fu"+i).checked;
        if (!use) continue;
        const px = parseFloat(document.getElementById("fx"+i).value) || 0;
        const pm = parseFloat(document.getElementById("fm"+i).value) || 0;
        sumX += px;
        sumM += pm;
        count++;
      }
      if (count === 0) return { Px: 0, Pm: 0 };
      return { Px: sumX/count, Pm: sumM/count };
    }

    // 予報用 ΔFlare_forecast(λ,t) [TECU]（最大 +15 TECU）
    function calcFlareDeltaForecast(cfg, ltHour) {
      const probs = getDeepFlareProbs();
      const Px = probs.Px;  // %
      const Pm = probs.Pm;  // %

      if (Px <= 0 && Pm <= 0) return 0.0;

      const level = cfg.kX*(Px/100) + cfg.kM*(Pm/100); // 0〜(kX+kM)
      if (level <= 0) return 0.0;

      const dayWeight = calcDaySideWeight(ltHour);

      const raw = 15.0 * cfg.betaFlare * level * dayWeight;
      return clamp(raw, 0, 15);
    }

    /* ===== Base用 手動フレアイベント ===== */

    function parseUtcFromInput(str) {
      if (!str) return null;
      const s = str.trim();
      if (!s) return null;

      const d = new Date(s);
      if (!isNaN(d.getTime())) return d;

      const m = s.match(/(\d{4})-(\d{2})-(\d{2})[T\s](\d{2}):(\d{2})/);
      if (m) {
        const y  = parseInt(m[1],10);
        const mo = parseInt(m[2],10);
        const d2 = parseInt(m[3],10);
        const hh = parseInt(m[4],10);
        const mm = parseInt(m[5],10);
        return new Date(Date.UTC(y, mo-1, d2, hh, mm, 0));
      }
      return null;
    }

    function getBaseFlareEvents() {
      const events = [];
      for (let i=1;i<=3;i++) {
        const startStr = document.getElementById("baseFlareStart"+i).value;
        const endStr   = document.getElementById("baseFlareEnd"+i).value;
        const start = parseUtcFromInput(startStr);
        const end   = parseUtcFromInput(endStr);
        let dTecMax = parseFloat(document.getElementById("baseFlareDelta"+i).value);
        if (!start || !end || isNaN(dTecMax) || dTecMax <= 0) continue;

        let latMin = parseFloat(document.getElementById("baseFlareLatMin"+i).value);
        let latMax = parseFloat(document.getElementById("baseFlareLatMax"+i).value);
        let lonMin = parseFloat(document.getElementById("baseFlareLonMin"+i).value);
        let lonMax = parseFloat(document.getElementById("baseFlareLonMax"+i).value);

        if (isNaN(latMin)) latMin = -90;
        if (isNaN(latMax)) latMax =  90;
        if (isNaN(lonMin)) lonMin = -180;
        if (isNaN(lonMax)) lonMax =  180;

        if (end.getTime() <= start.getTime()) continue;

        events.push({
          start, end,
          latMin, latMax,
          lonMin, lonMax,
          dTecMax
        });
      }
      return events;
    }

    // Base用 ΔFlare_base(φ,λ,t) [TECU]（最大 +15 TECU）
    function calcFlareDeltaBaseManual(tUtc, latDeg, lonDeg) {
      const events = getBaseFlareEvents();
      if (!events.length) return 0.0;
      const tMs = tUtc.getTime();
      let sum = 0;

      for (const ev of events) {
        if (tMs < ev.start.getTime() || tMs > ev.end.getTime()) continue;
        if (latDeg < ev.latMin || latDeg > ev.latMax) continue;
        if (lonDeg < ev.lonMin || lonDeg > ev.lonMax) continue;

        const ltHour = getLocalTimeHours(tUtc, lonDeg);
        const dayW = calcDaySideWeight(ltHour);
        if (dayW <= 0) continue;

        const contrib = ev.dTecMax * dayW;
        sum += contrib;
      }
      return clamp(sum, 0, 15);
    }

    /* ===== Simple Sstorm Positive (Mukhtarovベース, SuperStormは外で分岐) ===== */
    const SstormPos_SIGMA_LAT = 15.0;
    const SstormPos_SIGMA_M   = 2.0;
    const SstormPos_KC  = 6.5;
    const SstormPos_W   = 1.2;
    const SstormPos_A0  = 0.01;

    const SstormPos_BASIS = [
      {
        name:   "July_40S",
        latAbs: 40.0,
        month:  7,
        a: [
          -0.0742756961,
           0.08331505314,
          -0.01888613709,
           0.002074999214
        ]
      },
      {
        name:   "Nov_40N",
        latAbs: 40.0,
        month:  11,
        a: [
          -0.1106197275,
           0.1320345523,
          -0.04870525828,
           0.005143845605
        ]
      },
      {
        name:   "Nov_70N",
        latAbs: 70.0,
        month:  11,
        a: [
          -0.3746087246,
           0.3563156192,
          -0.09425770425,
           0.007924840841
        ]
      }
    ];

    function sstormPos_evalPoly(a, Kp) {
      const [a0, a1, a2, a3] = a;
      return a0 + a1*Kp + a2*Kp*Kp + a3*Kp*Kp*Kp;
    }
    function sstormPos_monthDiff(m, mi) {
      const d = Math.abs(m - mi);
      return Math.min(d, 12 - d);
    }
    function sstormPos_seasonMonth(latDeg, month) {
      if (latDeg < 0) {
        return ((month + 6 - 1) % 12) + 1;
      }
      return month;
    }

    function sstormPos_rTEC_base(
      Kp,
      latDeg,
      month,
      sigmaLat = SstormPos_SIGMA_LAT,
      sigmaM   = SstormPos_SIGMA_M
    ) {
      const latAbs = Math.abs(latDeg);
      const mSeason = sstormPos_seasonMonth(latDeg, month);

      const weights = SstormPos_BASIS.map(b => {
        const dLat = latAbs - b.latAbs;
        const dm   = sstormPos_monthDiff(mSeason, b.month);

        const gLat = Math.exp(-0.5 * (dLat / sigmaLat) ** 2);
        const gM   = Math.exp(-0.5 * (dm   / sigmaM  ) ** 2);

        return gLat * gM;
      });

      const sumW = weights.reduce((s, x) => s + x, 0) || 1.0;

      let r = 0;
      for (let i = 0; i < SstormPos_BASIS.length; i++) {
        const Wi = weights[i] / sumW;
        r += Wi * sstormPos_evalPoly(SstormPos_BASIS[i].a, Kp);
      }
      return r;
    }

    function sstormPos_rTEC(
      Kp,
      latDeg,
      month,
      options = {}
    ) {
      const {
        sigmaLat = SstormPos_SIGMA_LAT,
        sigmaM   = SstormPos_SIGMA_M,
        useTail  = true,
        Kc       = SstormPos_KC,
        w        = SstormPos_W,
        A0       = SstormPos_A0
      } = options;

      const base = sstormPos_rTEC_base(Kp, latDeg, month, sigmaLat, sigmaM);
      if (!useTail) {
        return base;
      }

      const baseAtKc = sstormPos_rTEC_base(Kc, latDeg, month, sigmaLat, sigmaM);
      const A = A0 * (1.0 + Math.max(baseAtKc, 0.0));

      const L = 1.0 / (1.0 + Math.exp(-(Kp - Kc) / w));
      const dK = Math.max(0.0, Kp - Kc);
      const tail = A * L * dK * dK;

      return base + tail;
    }

    function sstormPos_rStorm(Kp, latDeg, month, options = {}) {
      const rTEC = sstormPos_rTEC(Kp, latDeg, month, options);
      return 1.0 + rTEC;
    }

    if (typeof window !== "undefined") {
      window.sstormPos_rTEC   = sstormPos_rTEC;
      window.sstormPos_rStorm = sstormPos_rStorm;
    }

    /* ===== Leaflet 初期化 & ヒートマップ描画 ===== */
    function initMap() {
      map = L.map("tecMap", {
        worldCopyJump: true
      }).setView([0, 0], 2);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 6,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);

      const overlayPane = map.getPanes().overlayPane;
      tecCanvas = document.createElement("canvas");
      tecCanvas.className = "tec-canvas-overlay";
      overlayPane.appendChild(tecCanvas);
      tecCtx = tecCanvas.getContext("2d");
      resizeTecCanvas();

      map.on("moveend zoomend", () => {
        resizeTecCanvas();
        drawTecOverlay();
      });

      map.on("click", onMapClick);

      tecLegendControl = L.control({ position: "bottomright" });
      tecLegendControl.onAdd = function() {
        const div = L.DomUtil.create("div", "tec-legend");
        div.innerHTML =
          '<div class="tec-legend-title">TEC [TECU]</div>' +
          '<div class="tec-legend-bar"></div>' +
          '<div class="tec-legend-labels"><span>Low</span><span>High</span></div>';
        return div;
      };
      tecLegendControl.addTo(map);
      updateTecLegend();
    }

    function resizeTecCanvas() {
      if (!map || !tecCanvas) return;
      const size = map.getSize();
      tecCanvas.width  = size.x;
      tecCanvas.height = size.y;
    }

    function getColorFromScale(value, scale) {
      if (!scale || !scale.length) return "#000000";
      let prevLimit = 0;
      let prevColor = scale[0].color;
      for (let i=0;i<scale.length;i++) {
        const s = scale[i];
        if (value <= s.limit) {
          if (i === 0) return s.color;
          const ratio = (value - prevLimit) / (s.limit - prevLimit + 1e-6);
          return interpColor(prevColor, s.color, clamp(ratio,0,1));
        }
        prevLimit = s.limit;
        prevColor = s.color;
      }
      return scale[scale.length-1].color;
    }

    function interpColor(c1, c2, t) {
      const parse = c => {
        const m = c.match(/^#([0-9a-fA-F]{6})$/);
        if (!m) return [0,0,0];
        const n = parseInt(m[1],16);
        return [(n>>16)&255,(n>>8)&255,n&255];
      };
      const a = parse(c1), b = parse(c2);
      const r = Math.round(a[0]*(1-t)+b[0]*t);
      const g = Math.round(a[1]*(1-t)+b[1]*t);
      const b2 = Math.round(a[2]*(1-t)+b[2]*t);
      return "#" + ((1<<24) + (r<<16) + (g<<8) + b2).toString(16).slice(1);
    }

    function drawTecOverlay() {
      if (!map || !tecCtx || !gForecastFrames.length || !gGrid) {
        if (tecCtx && tecCanvas) {
          tecCtx.clearRect(0,0,tecCanvas.width, tecCanvas.height);
        }
        return;
      }
      resizeTecCanvas();
      const ctx = tecCtx;
      ctx.clearRect(0,0,tecCanvas.width, tecCanvas.height);

      const step = clamp(currentStepIndex, 0, gForecastFrames.length-1);
      const frame = gForecastFrames[step];
      const cfg = getConfigFromUI();

      const nLat = gGrid.nLat;
      const nLon = gGrid.nLon;

      ctx.globalAlpha = tecAlpha;

      for (let i=0;i<nLat-1;i++) {
        const lat1 = gGrid.latArr[i];
        const lat2 = gGrid.latArr[i+1];
        for (let j=0;j<nLon-1;j++) {
          const lon1 = gGrid.lonArr[j];
          const lon2 = gGrid.lonArr[j+1];

          const v00 = frame[i][j];
          const v10 = frame[i+1][j];
          const v01 = frame[i][j+1];
          const v11 = frame[i+1][j+1];
          let val = (v00 + v10 + v01 + v11) / 4;

          let colorScale, valueForColor;
          if (mapMode === "gps") {
            const gpsErr = val * cfg.kL1;
            colorScale = gGpsColorScale;
            valueForColor = gpsErr;
          } else {
            colorScale = gTecColorScale;
            valueForColor = val;
          }

          const p1 = map.latLngToContainerPoint([lat1, lon1]);
          const p2 = map.latLngToContainerPoint([lat2, lon2]);
          const x = Math.min(p1.x, p2.x);
          const y = Math.min(p1.y, p2.y);
          const w = Math.abs(p2.x - p1.x);
          const h = Math.abs(p2.y - p1.y);

          if (w <= 0 || h <= 0) continue;

          ctx.fillStyle = getColorFromScale(valueForColor, colorScale);
          ctx.fillRect(x, y, w, h);
        }
      }
    }

    function updateTecLegend() {
      const div = document.querySelector(".tec-legend");
      if (!div) return;
      const bar = div.querySelector(".tec-legend-bar");
      const labelsDiv = div.querySelector(".tec-legend-labels");
      const title = div.querySelector(".tec-legend-title");

      const scale = (mapMode === "tec") ? gTecColorScale : gGpsColorScale;
      const stops = scale.map(s => s.color).join(",");
      bar.style.background = "linear-gradient(to top," + stops + ")";

      labelsDiv.innerHTML =
        "<span>" + scale[0].limit + "</span><span>" + scale[scale.length-1].limit + "</span>";
      title.textContent = (mapMode === "tec") ? "TEC [TECU]" : "GPS L1誤差 [m]";
    }

    function onTecAlphaChange() {
      const v = parseFloat(document.getElementById("tecAlpha").value) || 0.8;
      tecAlpha = clamp(v, 0.1, 1.0);
      drawTecOverlay();
    }

    function changeMapMode() {
      mapMode = document.getElementById("mapModeSelect").value;
      updateTecLegend();
      drawTecOverlay();
    }

    /* ===== BoMフレーム補間（時間範囲外はループ利用） ===== */
    function interpolateBomFrames(frames, tUtc) {
      const nLat = frames[0].nLat;
      const nLon = frames[0].nLon;
      const out = new Array(nLat);
      for (let i=0;i<nLat;i++) out[i] = new Array(nLon);

      const hasTime = frames.every(f => f.validTime instanceof Date && !isNaN(f.validTime.getTime()));
      if (!hasTime) {
        const src = frames[0].grid;
        for (let i=0;i<nLat;i++) {
          for (let j=0;j<nLon;j++) out[i][j] = src[i][j];
        }
        return out;
      }

      frames.sort((a,b) => a.validTime - b.validTime);
      const tMin = frames[0].validTime.getTime();
      const tMax = frames[frames.length-1].validTime.getTime();
      const span = tMax - tMin;

      if (span <= 0) {
        const src = frames[0].grid;
        for (let i=0;i<nLat;i++) {
          for (let j=0;j<nLon;j++) out[i][j] = src[i][j];
        }
        return out;
      }

      const tRaw = tUtc.getTime();
      const tWrap = tMin + (((tRaw - tMin) % span) + span) % span;

      if (tWrap <= tMin) {
        const src = frames[0].grid;
        for (let i=0;i<nLat;i++) {
          for (let j=0;j<nLon;j++) out[i][j] = src[i][j];
        }
        return out;
      }

      let k = 1;
      while (k < frames.length && frames[k].validTime.getTime() < tWrap) k++;
      if (k >= frames.length) {
        const src = frames[frames.length-1].grid;
        for (let i=0;i<nLat;i++) {
          for (let j=0;j<nLon;j++) out[i][j] = src[i][j];
        }
        return out;
      }

      const f1 = frames[k-1];
      const f2 = frames[k];
      const t1 = f1.validTime.getTime();
      const t2 = f2.validTime.getTime();
      const alpha = (tWrap - t1) / (t2 - t1 + 1e-9);

      for (let i=0;i<nLat;i++) {
        const row1 = f1.grid[i];
        const row2 = f2.grid[i];
        for (let j=0;j<nLon;j++) {
          out[i][j] = row1[j]*(1-alpha) + row2[j]*alpha;
        }
      }
      return out;
    }

    /* ===== 時間ラベル / Kpラベル / UTCラベル ===== */
    function updateTimeLabel() {
      const slider = document.getElementById("timeSlider");
      const idx = parseInt(slider.value,10) || 0;
      const hours = idx * (DT_MINUTES/60);
      const lbl = document.getElementById("timeLabel");
      if (lbl) lbl.textContent = "t = " + hours.toFixed(1) + " h";
    }

    function updateUtcLabel(stepIndex) {
      const lbl = document.getElementById("utcLabel");
      if (!lbl) return;
      if (!gForecastTimes.length || !gForecastTimes[stepIndex]) {
        lbl.textContent = "UTC: --";
        return;
      }
      const tUtc = gForecastTimes[stepIndex];
      lbl.textContent = "UTC: " + tUtc.toISOString().replace(".000Z","Z");
    }

    function updateKpLabelForStep(stepIndex) {
      const kpLbl   = document.getElementById("kpNowLabel");
      if (!gForecastTimes.length || !gForecastTimes[stepIndex]) {
        if (kpLbl) kpLbl.textContent = "Kp=--";
        return;
      }
      const tUtc = gForecastTimes[stepIndex];
      let kp_t = sampleSeriesAtUtc(gKpSeries, tUtc, true);
      if (kp_t == null) kp_t = 0;
      if (kpLbl) kpLbl.textContent = "Kp=" + kp_t.toFixed(1);
    }

    function onSliderChange() {
      const idx = parseInt(document.getElementById("timeSlider").value,10) || 0;
      currentStepIndex = clamp(idx, 0, gForecastFrames.length ? gForecastFrames.length-1 : idx);
      updateTimeLabel();
      updateUtcLabel(currentStepIndex);
      updateKpLabelForStep(currentStepIndex);
      drawTecOverlay();
    }

    /* ===== 予報スタート選択セレクトの更新 ===== */
    function updateForecastStartSelect(frames) {
      const sel = document.getElementById("forecastStartSelect");
      const info = document.getElementById("forecastStartInfo");
      if (!sel) return;
      sel.innerHTML = "";

      const times = frames
        .map(f => f.validTime)
        .filter(t => t instanceof Date && !isNaN(t.getTime()))
        .sort((a,b) => a - b);

      const uniqueMs = [];
      const uniqueTimes = [];
      for (const t of times) {
        const ms = t.getTime();
        if (!uniqueMs.includes(ms)) {
          uniqueMs.push(ms);
          uniqueTimes.push(t);
        }
      }

      if (!uniqueTimes.length) {
        if (info) info.textContent = "BoMに有効時刻が含まれていないため、最初のフレーム時刻を基準に3日予報を行います。";
        return;
      }

      uniqueTimes.forEach((t, idx) => {
        const opt = document.createElement("option");
        opt.value = t.getTime().toString();
        opt.textContent = t.toISOString().replace(".000Z","Z");
        if (idx === 0) opt.selected = true;
        sel.appendChild(opt);
      });

      if (info) info.textContent = "BoMの有効時刻から選択できます。変更後は再度「TEC予報を計算」を押してください。";
    }

    /* ===== 予報計算（加算+SuperStorm+Base手動Flare） ===== */
    function runForecast() {
      try {
        logInfo("TEC予報を計算中...");
        gForecastFrames = [];
        gForecastTimes  = [];
        gGrid = null;
        gForecastStart = null;

        const bomTexts = [
          document.getElementById("bomInput1").value,
          document.getElementById("bomInput2").value,
          document.getElementById("bomInput3").value,
          document.getElementById("bomInput4").value,
          document.getElementById("bomInput5").value,
          document.getElementById("bomInput6").value,
          document.getElementById("bomInput7").value,
          document.getElementById("bomInput8").value,
          document.getElementById("bomInput9").value
        ];

        const frames = [];
        for (const txt of bomTexts) {
          if (!txt.trim()) continue;
          try {
            const f = parseBoM(txt);
            frames.push(f);
          } catch(e) {
            console.warn("BoMパース失敗:", e);
          }
        }
        if (!frames.length) {
          logInfo("BoM TEC テキストが1つもありません。");
          return;
        }
        frames.sort((a,b) => (a.validTime || 0) - (b.validTime || 0));
        const first = frames[0];

        gGrid = {
          latArr: first.latArr,
          lonArr: first.lonArr,
          nLat:   first.nLat,
          nLon:   first.nLon
        };

        updateForecastStartSelect(frames);

        let startTime = first.validTime || new Date();
        const sel = document.getElementById("forecastStartSelect");
        if (sel && sel.options.length > 0 && sel.value) {
          const ms = parseInt(sel.value,10);
          if (!isNaN(ms)) {
            startTime = new Date(ms);
          }
        }
        gForecastStart = startTime;

        const baseKpText = document.getElementById("noaaKpBaseText").value;
        const fcstKpText = document.getElementById("noaaKpText").value;
        gKpSeriesBase = parseKpText(baseKpText);
        gKpSeries     = parseKpText(fcstKpText);

        const cfg   = getConfigFromUI();

        const totalSteps = Math.round(FORECAST_HOURS * 60 / DT_MINUTES); // 72h *2 =144
        for (let s=0;s<=totalSteps;s++) {
          const t = new Date(gForecastStart.getTime() + s * DT_MINUTES * 60000);
          gForecastTimes.push(t);
        }

        const nLat = gGrid.nLat;
        const nLon = gGrid.nLon;

        for (let s=0;s<gForecastTimes.length;s++) {
          const tUtc = gForecastTimes[s];

          const tecInGrid = interpolateBomFrames(frames, tUtc);

          const kp_fcst = sampleSeriesAtUtc(gKpSeries, tUtc, true) ?? 0;
          const kp_base = sampleSeriesAtUtc(
            (gKpSeriesBase && gKpSeriesBase.length) ? gKpSeriesBase : gKpSeries,
            tUtc,
            true
          ) ?? 0;

          const frame = new Array(nLat);

          for (let i=0;i<nLat;i++) {
            frame[i] = new Array(nLon);
            const lat = gGrid.latArr[i];

            for (let j=0;j<nLon;j++) {
              const lon = gGrid.lonArr[j];

              // 実太陽時（近似）LT = UTC + λ/15h （UT日付によらず 24h 周期）
              const ltHour = getLocalTimeHours(tUtc, lon);
              const monthIndex = tUtc.getUTCMonth() + 1;

              const tecIn = tecInGrid[i][j];

              // --- BaseTEC 逆算 (入力TEC - Sstorm_base - BaseFlare_manual) ---
              const dFlare_base = calcFlareDeltaBaseManual(tUtc, lat, lon);

              let tecBaseRaw;
              if (kp_base <= 7.0) {
                // Kp<=7: Mukhtarov モード
                const rStormBase = sstormPos_rStorm(kp_base, lat, monthIndex);
                const denom = 1.0 + cfg.kStorm * (rStormBase - 1.0);
                const denomSafe = Math.max(denom, 0.2);
                tecBaseRaw = (tecIn - dFlare_base) / denomSafe;
              } else {
                // Kp>=8: SuperStorm モード
                const deltaMaxBase = sstorm_super_deltaMax(lat);
                const sSuperBase   = sstorm_super_factor(kp_base, ltHour);
                const corr = cfg.kStorm * sSuperBase * deltaMaxBase + dFlare_base;
                tecBaseRaw = tecIn - corr;
              }

              if (!isFinite(tecBaseRaw)) tecBaseRaw = 0;
              const nightFactor = calcBaseNightFactor(ltHour);   // ★修正ポイント2：BaseTEC にだけ LT夜間減衰
              let tecBase = cfg.kBase * tecBaseRaw * nightFactor;
              if (tecBase < 0) tecBase = 0;

              // --- 予報側 ΔStorm (Kp_fcst) ---
              let dStorm;
              if (kp_fcst <= 7.0) {
                const rStormFcst = sstormPos_rStorm(kp_fcst, lat, monthIndex);
                dStorm = cfg.kStorm * tecBase * (rStormFcst - 1.0);
              } else {
                const deltaMax = sstorm_super_deltaMax(lat);
                const sSuper   = sstorm_super_factor(kp_fcst, ltHour);
                dStorm = cfg.kStorm * sSuper * deltaMax;
              }

              // --- 予報用 ΔFlare（DeepFlareNet ベース） ---
              const dFlare_fcst = calcFlareDeltaForecast(cfg, ltHour);

              let tec = tecBase + dStorm + dFlare_fcst;
              if (!isFinite(tec) || tec < 0) tec = 0;
              frame[i][j] = tec;
            }
          }
          gForecastFrames.push(frame);
        }

        currentStepIndex = 0;
        document.getElementById("timeSlider").value = 0;
        updateTimeLabel();
        updateUtcLabel(0);
        updateKpLabelForStep(0);
        drawTecOverlay();
        updateFormulaText();

        logInfo("TEC予報計算が完了しました。ステップ数: " + gForecastFrames.length);
      } catch(e) {
        console.error(e);
        logInfo("エラー: " + e.message);
      }
    }

    /* ===== クリック情報 ===== */
    function onMapClick(e) {
      if (!gGrid || !gForecastFrames.length) return;
      const lat = e.latlng.lat;
      const lon = e.latlng.lng;

      let bestI = 0, bestJ = 0, bestD = 1e9;
      for (let i=0;i<gGrid.nLat;i++) {
        const dLat = Math.abs(gGrid.latArr[i] - lat);
        for (let j=0;j<gGrid.nLon;j++) {
          const dLon = Math.abs(gGrid.lonArr[j] - lon);
          const d = dLat + dLon;
          if (d < bestD) {
            bestD = d;
            bestI = i;
            bestJ = j;
          }
        }
      }

      const tec = gForecastFrames[currentStepIndex][bestI][bestJ];
      const cfg = getConfigFromUI();
      const gpsErr = tec * cfg.kL1;
      const tUtc = gForecastTimes[currentStepIndex];

      const kp_t = tUtc ? (sampleSeriesAtUtc(gKpSeries, tUtc, true) ?? 0) : 0;
      const month = tUtc ? (tUtc.getUTCMonth() + 1) : 1;

      const txt =
        "UTC: " + (tUtc ? tUtc.toISOString().replace(".000Z","Z") : "N/A") + "\n" +
        "Lat=" + gGrid.latArr[bestI].toFixed(1) + "°, Lon=" + gGrid.lonArr[bestJ].toFixed(1) + "°\n" +
        "TEC = " + tec.toFixed(1) + " TECU\n" +
        "GPS L1誤差 ≈ " + gpsErr.toFixed(2) + " m\n" +
        "Kp(予報) ≈ " + kp_t.toFixed(1) + " (month=" + month + ")";

      document.getElementById("pointInfo").textContent = txt;
    }

    /* ===== 地域フォーカス ===== */
    function focusRegion(name) {
      if (!map) return;
      let latMin,latMax,lonMin,lonMax;
      if (name === "japan") {
        latMin = 20; latMax = 50;
        lonMin = 120; lonMax = 150;
      } else if (name === "northAmerica") {
        latMin = 10; latMax = 70;
        lonMin = -170; lonMax = -50;
      } else if (name === "southAmerica") {
        latMin = -60; latMax = 20;
        lonMin = -90; lonMax = -30;
      } else if (name === "europe") {
        latMin = 30; latMax = 70;
        lonMin = -20; lonMax = 40;
      } else if (name === "africa") {
        latMin = -40; latMax = 30;
        lonMin = -20; lonMax = 50;
      } else if (name === "australia") {
        latMin = -50; latMax = 0;
        lonMin = 110; lonMax = 160;
      } else {
        return;
      }
      currentFocus = { latMin, latMax, lonMin, lonMax };
      const sw = L.latLng(latMin, lonMin);
      const ne = L.latLng(latMax, lonMax);
      map.fitBounds(L.latLngBounds(sw, ne));
    }

    function applyManualFocus() {
      const latMin = parseFloat(document.getElementById("focusLatMin").value);
      const latMax = parseFloat(document.getElementById("focusLatMax").value);
      const lonMin = parseFloat(document.getElementById("focusLonMin").value);
      const lonMax = parseFloat(document.getElementById("focusLonMax").value);
      currentFocus = { latMin, latMax, lonMin, lonMax };
      const sw = L.latLng(latMin, lonMin);
      const ne = L.latLng(latMax, lonMax);
      map.fitBounds(L.latLngBounds(sw, ne));
    }

    function resetFocus() {
      currentFocus = null;
      if (map) map.setView([0,0], 2);
    }

    /* ===== 式テキスト（加算+SuperStorm+Base手動Flare版） ===== */
    function updateFormulaText() {
      const cfg = getConfigFromUI();
      const txt =
`加算+SuperStorm+Base手動Flare モデル:

  1. BaseTEC 逆算（BoM入力TEC → 静穏成分）

    入力 TEC:
      TEC_in(φ,λ,t) = BoM TEC を時間補間した値

    実太陽時:
      LT(t,λ) = UTC(t) + λ/15h (mod 24)

    昼夜ウェイト:
      DaySide(LT) = max(0, cos(π(LT-14)/12))       // フレア・SuperStorm の昼側判定用
      Base 夜間減衰 (UT日付非依存):
        NightBase(LT)
          = 0.3 + 0.7 · 0.5 · { 1 + cos[ 2π((LT-2)/24) ] }
          （LT≒14h で ≒1.0, 深夜帯で ≒0.3）

    Base用フレア（手動イベント）:
      ・イベント i = 1..N について
         start_i, end_i : UTC 時刻
         [latMin_i, latMax_i], [lonMin_i, lonMax_i] : 領域
         ΔTECmax_i : 最大増分 [TECU]

      ΔFlare_base(φ,λ,t)
        = Σ_i { ΔTECmax_i · DaySide(LT(t,λ))
                （t∈[start_i,end_i], かつ φ,λ が矩形内） } を 0〜15 TECU にクリップ

    (1) Kp_base ≤ 7: Mukhtarov モード

      r_storm_base(φ,t) = 1 + r_TEC_Mukhtarov(Kp_base(t), φ, season(t))

      TEC_base_raw(φ,λ,t)
        = [ TEC_in(φ,λ,t) - ΔFlare_base(φ,λ,t) ]
          / { 1 + kStorm·[r_storm_base(φ,t) - 1] }

    (2) Kp_base ≥ 8: SuperStorm モード

      ΔTEC_max(φ)
        = 20 + 80[ exp(-((φ-25)/10)^2) + exp(-((φ+25)/10)^2) ]

      S_super_base(Kp_base,LT)
        = DaySide(LT) · f(Kp_base)   // Kp=8→0.7, Kp=9→1.0

      TEC_base_raw(φ,λ,t)
        = TEC_in(φ,λ,t)
          - kStorm·S_super_base·ΔTEC_max(φ)
          - ΔFlare_base(φ,λ,t)

    最終 BaseTEC（夜間減衰 + kBase）:
      BaseTEC(φ,λ,t)
        = max(0, kBase · TEC_base_raw(φ,λ,t) · NightBase(LT(t,λ)))

  2. 予報側 ΔStorm (Kp_fcst) + ΔFlare_forecast (DeepFlareNet)

    (1) Kp_fcst ≤ 7: Mukhtarov モード

      r_storm_fcst(φ,t) = 1 + r_TEC_Mukhtarov(Kp_fcst(t), φ, season(t))

      ΔStorm_fcst(φ,λ,t)
        = kStorm · BaseTEC(φ,λ,t) · [ r_storm_fcst(φ,t) - 1 ]

    (2) Kp_fcst ≥ 8: SuperStorm モード

      ΔStorm_fcst(φ,λ,t)
        = kStorm · S_super(Kp_fcst(t),LT(t,λ)) · ΔTEC_max(φ)

    予報用フレア（DeepFlareNet 9領域）:
      Px, Pm = DeepFlareNet からの平均 P(X≥), P(M≥) [%]
      level  = k_X·(Px/100) + k_M·(Pm/100)
      ΔFlare_forecast(λ,t)
        = min(15,
               15·β_flare·level·DaySide(LT(t,λ)))

  3. 最終 TEC & GPS誤差

      TEC_total(φ,λ,t)
        = BaseTEC(φ,λ,t)
        + ΔStorm_fcst(φ,λ,t)
        + ΔFlare_forecast(λ,t)

      σ_L1(φ,λ,t) ≈ TEC_total(φ,λ,t) · kL1   [m]

  現在の係数:
    kBase   = ${cfg.kBase}
    kStorm  = ${cfg.kStorm}
    β_flare = ${cfg.betaFlare}  (予報用)
    k_X     = ${cfg.kX}
    k_M     = ${cfg.kM}
    kL1     = ${cfg.kL1} [m/TECU]`;

      document.getElementById("formulaText").textContent = txt;
    }

    /* ===== リセット ===== */
    function resetAll() {
      gForecastFrames = [];
      gForecastTimes  = [];
      gGrid = null;
      gForecastStart = null;
      currentStepIndex = 0;
      document.getElementById("timeSlider").value = 0;
      updateTimeLabel();
      updateUtcLabel(0);
      updateKpLabelForStep(0);
      if (tecCtx && tecCanvas) tecCtx.clearRect(0,0,tecCanvas.width, tecCanvas.height);
      document.getElementById("pointInfo").textContent =
        "地図上をクリックすると、その格子点のTEC・GPS L1誤差と位置が表示されます。";
      logInfo("計算結果をリセットしました。");
    }

    /* ===== 起動時処理 ===== */
    document.addEventListener("DOMContentLoaded", () => {
      initMap();
      loadBomInputsFromStorage();
      loadConfig(true);
      loadTecColorScaleFromStorage();
      loadGpsColorScaleFromStorage();
      updateTimeLabel();
      updateUtcLabel(0);
      updateKpLabelForStep(0);
      updateFormulaText();
    });
  </script>
</body>
</html>

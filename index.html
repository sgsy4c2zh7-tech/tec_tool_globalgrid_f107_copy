<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v2 (BoM 4-snapshot)</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 16px;
      background: #0b1020;
      color: #f0f4ff;
    }
    h1, h2, h3 {
      margin: 4px 0 8px;
    }
    h1 {
      font-size: 20px;
      color: #7bd0ff;
    }
    h2 {
      font-size: 16px;
      color: #ffd480;
    }
    h3 {
      font-size: 14px;
      color: #b0c8ff;
    }
    .flex-row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .card {
      background: #141b33;
      border-radius: 8px;
      padding: 8px 10px;
      border: 1px solid #283256;
      box-shadow: 0 0 8px rgba(0,0,0,0.5);
      margin-bottom: 10px;
    }
    textarea {
      width: 100%;
      min-height: 100px;
      background: #050813;
      color: #e0ecff;
      border: 1px solid #3a476e;
      border-radius: 4px;
      padding: 4px;
      font-size: 11px;
      font-family: Consolas, "Courier New", monospace;
      box-sizing: border-box;
    }
    textarea:focus, input:focus {
      outline: none;
      border-color: #6dd3ff;
      box-shadow: 0 0 4px #6dd3ff;
    }
    button {
      padding: 3px 10px;
      font-size: 12px;
      border-radius: 4px;
      border: 1px solid #3c8dd9;
      background: linear-gradient(90deg, #275093, #2e7ac7);
      color: #f5fbff;
      cursor: pointer;
      margin-right: 5px;
      margin-top: 4px;
    }
    button:hover {
      background: linear-gradient(90deg, #3473c0, #3ba4ff);
    }
    input[type="number"], input[type="text"], input[type="datetime-local"], input[type="file"] {
      background: #050813;
      color: #e0ecff;
      border: 1px solid #3a476e;
      border-radius: 4px;
      padding: 2px 4px;
      font-size: 11px;
      box-sizing: border-box;
    }
    label {
      font-size: 11px;
      margin-right: 6px;
    }
    pre {
      background: #050813;
      color: #e0ecff;
      border-radius: 4px;
      border: 1px solid #3a476e;
      font-size: 11px;
      padding: 4px;
      overflow: auto;
      max-height: 150px;
    }
    .small {
      font-size: 11px;
      color: #a9b8df;
    }
    #tecMapCanvas {
      border-radius: 8px;
      border: 1px solid #3a476e;
      background: #000000;
      display: block;
      max-width: 100%;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 4px;
    }
    input[type="range"] {
      flex: 1;
    }
    .pill {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 999px;
      background: #1e2847;
      font-size: 11px;
      margin-right: 5px;
    }
    table.color-table {
      border-collapse: collapse;
      font-size: 11px;
      margin-top: 4px;
    }
    table.color-table th, table.color-table td {
      border: 1px solid #3a476e;
      padding: 2px 4px;
    }
  </style>
</head>
<body>
  <h1>SWIFT-TEC v2 &mdash; BoM 4-snapshot + Space Weather</h1>
  <div class="small">
    BoMのTECグローバルマップ（IRI-2020ベース）を最大4枚貼り付けて昼夜変化の「型」を推定し、
    F10.7 / Ap / Dst / X-ray を重ねて 72時間 TEC 予報を作成します。<br>
    背景地図はブラウザ内に保存され、さらに <code>bg.png</code> を同じリポジトリに置くと、どのPCから開いても同じ初期背景になります。
  </div>

  <!-- ===== BoM TEC 入力（最大4枚） ===== -->
  <div class="card">
    <h2>1. BoM TEC Global Grid（最大4つ）</h2>
    <div class="small">
      World0000_tec.txt / World0300_tec.txt などを、そのままコピペしてください（ヘッダ付きでOK）。
    </div>
    <div class="flex-row">
      <div style="flex:1; min-width:220px;">
        <h3>BoM #1</h3>
        <textarea id="bomInput1" placeholder="# PRODUCT NAME ...&#10;VALID DATE/TIME: ..."></textarea>
      </div>
      <div style="flex:1; min-width:220px;">
        <h3>BoM #2</h3>
        <textarea id="bomInput2"></textarea>
      </div>
      <div style="flex:1; min-width:220px;">
        <h3>BoM #3</h3>
        <textarea id="bomInput3"></textarea>
      </div>
      <div style="flex:1; min-width:220px;">
        <h3>BoM #4</h3>
        <textarea id="bomInput4"></textarea>
      </div>
    </div>
    <button onclick="parseBomMulti()">BoM 解析（最大4枚）</button>
    <pre id="bomMultiInfo"></pre>
  </div>

  <!-- ===== NOAA / Dst / X-ray ===== -->
  <div class="flex-row">
    <div class="card" style="flex:1; min-width:260px;">
      <h2>2. NOAA 27-day Outlook（F10.7 / Ap）</h2>
      <div class="small">https://www.spaceweather.gov/products/27-day-outlook-107-cm-radio-flux-and-geomagnetic-indices のテキストを貼り付け。</div>
      <textarea id="noaaInput"></textarea>
      <button onclick="testParseNOAA()">NOAA 解析</button>
      <div style="margin-top:4px;">
        <label>F10.7</label><input id="F107" type="number" step="0.1" style="width:60px;" />
        <label>Ap</label><input id="Ap" type="number" step="0.1" style="width:60px;" />
      </div>
      <pre id="noaaInfo"></pre>
    </div>

    <div class="card" style="flex:1; min-width:260px;">
      <h2>3. Kyoto Dst Table</h2>
      <div class="small">Kyoto WDC の Dst 表を1日分貼り付け（DAY行を含む）。</div>
      <textarea id="dstInput"></textarea>
      <button onclick="testParseDst()">Dst 解析</button>
      <div style="margin-top:4px;">
        <label>Dst (nT)</label>
        <input id="DstVal" type="number" step="1" style="width:60px;" />
      </div>
      <pre id="dstInfo"></pre>
    </div>

    <div class="card" style="flex:1; min-width:260px;">
      <h2>4. GOES X-ray JSON</h2>
      <div class="small">GOES 0.1-0.8nm の JSON（1日分）を貼り付け。</div>
      <textarea id="xrayInput"></textarea>
      <button onclick="testParseXray()">X-ray 解析</button>
      <pre id="xrayInfo"></pre>
    </div>
  </div>

  <!-- ===== 予報条件 & 地点指定 ===== -->
  <div class="card">
    <h2>5. 予報条件 & 地点指定</h2>
    <div class="flex-row">
      <div style="flex:1; min-width:220px;">
        <h3>観測基準時刻 / 1地点予報</h3>
        <div class="small">
          BoMの最新時刻を自動取得しています。必要なら上書きしてください（UTC）。
        </div>
        <div style="margin-top:4px;">
          <label>観測時刻(UTC)</label>
          <input id="timeNow" type="datetime-local" style="width:180px;" />
        </div>
        <div style="margin-top:4px;">
          <label>地点lat</label><input id="latForecast" type="number" step="1" style="width:60px;" />
          <label>lon</label><input id="lonForecast" type="number" step="1" style="width:60px;" />
        </div>
        <div style="margin-top:4px;">
          <label>現在TEC</label><input id="tecNow" type="number" step="0.01" style="width:80px;" />
          <label>Δt (時間)</label><input id="dT" type="number" step="0.5" value="1" style="width:60px;" />
        </div>
        <button onclick="runForecast()">1地点予報を計算</button>
        <pre id="forecastOut"></pre>
      </div>

      <div style="flex:1; min-width:220px;">
        <h3>BoMから最近格子点を検索</h3>
        <div class="small">
          BoMの最新スナップショットを使って、任意の緯度 / 経度に最も近い格子を検索します（観測TECの確認用）。
        </div>
        <div style="margin-top:4px;">
          <label>検索lat</label><input id="latSearch" type="number" step="1" value="35" style="width:60px;" />
          <label>lon</label><input id="lonSearch" type="number" step="1" value="140" style="width:60px;" />
        </div>
        <button onclick="searchOnBom()">BoM から検索</button>
        <pre id="bomSearchInfo"></pre>
      </div>
    </div>
  </div>

  <!-- ===== 72時間グローバル予報マップ ===== -->
  <div class="card">
    <h2>6. 72時間グローバルTEC予報マップ</h2>
    <div class="small">
      BoM 3〜4枚で推定した「昼夜カーブ」＋ F10.7 / Ap / Dst / X-ray を重ねて、30分刻みで72時間分を計算します。
    </div>
    <button onclick="computeForecastFrames()">72時間分を計算</button>
    <div class="slider-row">
      <label>時刻ステップ</label>
      <input id="timeSlider" type="range" min="0" max="0" value="0" oninput="onSliderChange()" />
      <span id="sliderLabel" class="pill">t = 0.0h</span>
      <span id="timeUTCLabel" class="pill">UTC: --</span>
    </div>
    <canvas id="tecMapCanvas" width="1000" height="500"></canvas>
    <div class="small">
      キャンバス上に地図画像をドラッグ＆ドロップするか、下のファイル選択から読み込み。<br>
      読み込んだ背景地図はブラウザに保存され、さらに <code>bg.png</code> があればその画像が初期背景として使われます。
    </div>

    <div class="flex-row" style="margin-top:8px;">
      <!-- 色スケール設定 -->
      <div style="flex:1; min-width:260px;">
        <h3>色スケール設定（TECU &amp; 色）</h3>
        <div class="small">閾値(TECU)と色を自由に設定できます（5段階）。TEC値は閾値間をグラデーション補間します。</div>
        <table class="color-table">
          <tr><th>閾値 (TECU)</th><th>色</th></tr>
          <tr>
            <td><input id="csVal1" type="number" value="0" style="width:70px;" /></td>
            <td><input id="csColor1" type="color" value="#00005a" /></td>
          </tr>
          <tr>
            <td><input id="csVal2" type="number" value="30" style="width:70px;" /></td>
            <td><input id="csColor2" type="color" value="#008800" /></td>
          </tr>
          <tr>
            <td><input id="csVal3" type="number" value="45" style="width:70px;" /></td>
            <td><input id="csColor3" type="color" value="#d0ffd0" /></td>
          </tr>
          <tr>
            <td><input id="csVal4" type="number" value="60" style="width:70px;" /></td>
            <td><input id="csColor4" type="color" value="#ffff00" /></td>
          </tr>
          <tr>
            <td><input id="csVal5" type="number" value="80" style="width:70px;" /></td>
            <td><input id="csColor5" type="color" value="#ff8000" /></td>
          </tr>
        </table>
        <button onclick="drawTecMap()">この色設定で再描画</button>
        <div class="small">※120 TECU を上限として凡例を表示します。</div>

        <h3 style="margin-top:8px;">表示設定の保存・読み込み</h3>
        <div class="small">
          色スケール＋地図の拡大・位置を JSON に保存して、別PCでも読み込めます。
        </div>
        <button onclick="downloadConfig()">設定を保存(JSON)</button><br />
        <input type="file" id="configFile" accept="application/json" />
        <button onclick="loadConfigFromFile()">設定を読み込み</button>
      </div>

      <!-- 地図オーバーレイ設定 -->
      <div style="flex:1; min-width:260px;">
        <h3>ベース地図オーバーレイ（保存機能付き）</h3>
        <div class="small">
          世界地図などの画像をキャンバスへドラッグ＆ドロップするか、下のボタンで選択してください。<br>
          読み込んだ画像はブラウザ内（localStorage）にも保存されます。<br>
          リポジトリに <code>bg.png</code> を置いた場合、それが初期背景になります。
        </div>
        <input type="file" id="mapFile" accept="image/*" />
        <div style="margin-top:4px;">
          <label>scaleX</label><input id="mapScaleX" type="number" step="0.1" value="1.0" style="width:60px;" onchange="onMapParamChange()" />
          <label>scaleY</label><input id="mapScaleY" type="number" step="0.1" value="1.0" style="width:60px;" onchange="onMapParamChange()" />
        </div>
        <div style="margin-top:4px%;">
          <label>offsetX(px)</label><input id="mapOffsetX" type="number" step="10" value="0" style="width:70px;" onchange="onMapParamChange()" />
          <label>offsetY(px)</label><input id="mapOffsetY" type="number" step="10" value="0" style="width:70px;" onchange="onMapParamChange()" />
        </div>
        <div style="margin-top:4px;">
          <label>map透明度</label><input id="mapAlpha" type="number" step="0.1" min="0" max="1" value="0.5" style="width:60px;" onchange="onMapParamChange()" />
        </div>
        <button onclick="clearMapImage()">背景画像を削除</button>
        <div class="small" style="margin-top:4px;">
          ・scaleX / scaleY：地図の拡大縮小・引き伸ばし<br/>
          ・offsetX / offsetY：マップの左右・上下位置調整<br/>
          ・これらの設定も JSON 保存 & 読み込みに含まれます。
        </div>
      </div>
    </div>
  </div>

  <!-- ===== Excelコピペ用 ===== -->
  <div class="card">
    <h2>7. Excel用コピー</h2>
    <div class="small">
      現在スライダーで選択中の時刻ステップのグリッドを、Excelに貼り付けられる形で出力します。
      経度が列（横軸）、緯度が行（縦軸）です。
    </div>
    <button onclick="exportCurrentFrameToExcel()">Excel用グリッドを出力</button>
    <button onclick="copyExcelOut()">クリップボードにコピー</button>
    <textarea id="excelOut" style="min-height:120px;"></textarea>
  </div>

  <script>
    // ===== グローバル変数 =====
    let gBomSnaps = [];     // {time, latMin, latStep, latN, lonMin, lonStep, lonN, grid}
    let gAB = null;         // {a: [latN][lonN], b:[latN][lonN]}
    let gClimBaseTime = null;

    let gXrayDaily = null;  // {Xmean, Xmax, XeffLog}
    let gForecastFrames = null; // [k][i][j] TEC
    let gForecastDt = null;     // [k] hours
    let gForecastStartTime = null;

    // ベース地図
    let gMapImage = null;

    // ========= BoM パーサ（1ファイル） =========
    function parseBoM(text) {
      if (!text.trim()) throw new Error("BoM TEC テキストが空です");

      const m = text.match(/VALID DATE\/TIME:\s*(\d{2})\/(\d{2})\/(\d{4})\s+(\d{2}):(\d{2}):(\d{2})UTC/);
      if (!m) throw new Error("VALID DATE/TIME が見つかりません");
      const day   = parseInt(m[1],10);
      const mon   = parseInt(m[2],10)-1;
      const year  = parseInt(m[3],10);
      const hh    = parseInt(m[4],10);
      const mm    = parseInt(m[5],10);
      const ss    = parseInt(m[6],10);
      const time  = new Date(Date.UTC(year,mon,day,hh,mm,ss));

      const mLat = text.match(/LATITUDE GRID\s*\(min,max,step,n\):\s*([-0-9.]+)\s+([-0-9.]+)\s+([-0-9.]+)\s+(\d+)/);
      const mLon = text.match(/LONGITUDE GRID\s*\(min,max,step,n\):\s*([-0-9.]+)\s+([-0-9.]+)\s+([-0-9.]+)\s+(\d+)/);
      if (!mLat || !mLon) throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません");

      const latMin  = parseFloat(mLat[1]);
      const latMax  = parseFloat(mLat[2]);
      const latStep = parseFloat(mLat[3]);
      const latN    = parseInt(mLat[4],10);
      const lonMin  = parseFloat(mLon[1]);
      const lonMax  = parseFloat(mLon[2]);
      const lonStep = parseFloat(mLon[3]);
      const lonN    = parseInt(mLon[4],10);

      const lines = text.split(/\r?\n/);
      const dataLines = [];
      let started = false;
      for (const raw of lines) {
        const line = raw.trim();
        if (!started) {
          if (!line || line.startsWith("#")) continue;
          if (/^[0-9.\-,\s]+$/.test(line) && /[0-9]/.test(line)) {
            started = true;
            dataLines.push(raw);
          }
        } else {
          if (line) dataLines.push(raw);
        }
      }
      if (!dataLines.length) throw new Error("TEC データ部分が見つかりません");

      const grid = [];
      for (const raw of dataLines) {
        const arr = raw.split(",")
          .map(v=>v.trim())
          .filter(v=>v.length>0)
          .map(v=>{
            const x = parseFloat(v);
            return isNaN(x)? NaN : x;
          });
        if (arr.length) grid.push(arr);
      }
      if (!grid.length) throw new Error("TEC グリッドが空です");

      for (let i=0;i<grid.length;i++) {
        if (grid[i].length < lonN) {
          while (grid[i].length < lonN) grid[i].push(NaN);
        } else if (grid[i].length > lonN) {
          grid[i] = grid[i].slice(0, lonN);
        }
      }
      if (grid.length < latN) {
        while (grid.length < latN) {
          grid.push(new Array(lonN).fill(NaN));
        }
      } else if (grid.length > latN) {
        grid.length = latN;
      }

      for (let i=0;i<latN;i++) {
        for (let j=0;j<lonN;j++) {
          if (!isFinite(grid[i][j])) {
            let up = (i>0)? grid[i-1][j] : NaN;
            let dn = (i<latN-1)? grid[i+1][j] : NaN;
            if (isFinite(up) && isFinite(dn)) {
              grid[i][j] = (up+dn)/2;
            } else if (isFinite(up)) {
              grid[i][j] = up;
            } else if (isFinite(dn)) {
              grid[i][j] = dn;
            } else {
              grid[i][j] = 0;
            }
          }
        }
      }

      return {time, latMin, latMax, latStep, latN, lonMin, lonMax, lonStep, lonN, grid};
    }

    // ========= 太陽位置まわり =========
    function dayOfYear(d) {
      const start = Date.UTC(d.getUTCFullYear(),0,1);
      const today = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
      return Math.floor((today - start)/86400000)+1;
    }
    function solarDeclination(d) {
      const N = dayOfYear(d);
      const B = 2*Math.PI*(N-81)/365;
      return 23.44*Math.sin(B);
    }
    function localSolarTime(utDate, lonDeg) {
      const utH = utDate.getUTCHours() + utDate.getUTCMinutes()/60 + utDate.getUTCSeconds()/3600;
      return (utH + lonDeg/15 + 24) % 24;
    }
    function solarZenith(utDate, latDeg, lonDeg) {
      const d2r = Math.PI/180;
      const phi = latDeg*d2r;
      const delta = solarDeclination(utDate)*d2r;
      const lst = localSolarTime(utDate, lonDeg);
      const H = (lst - 12)*15*d2r;
      let cosChi = Math.sin(phi)*Math.sin(delta) + Math.cos(phi)*Math.cos(delta)*Math.cos(H);
      if (cosChi>1) cosChi=1;
      if (cosChi<-1) cosChi=-1;
      const chiDeg = Math.acos(cosChi)/d2r;
      return {chiDeg, cosChi};
    }
    function xFromCosChi(cosChi) {
      const p = 1.3;
      const c = Math.max(cosChi, 0);
      return Math.pow(c, p);
    }

    // ========= BoM 最大4枚を読み込み、a,bフィット =========
    function parseBomMulti() {
      const infos = [];
      try {
        const texts = [
          document.getElementById("bomInput1").value,
          document.getElementById("bomInput2").value,
          document.getElementById("bomInput3").value,
          document.getElementById("bomInput4").value
        ];
        const snaps = [];
        for (let idx=0; idx<texts.length; idx++) {
          const t = texts[idx];
          if (!t.trim()) continue;
          try {
            const b = parseBoM(t);
            b.index = idx+1;
            snaps.push(b);
          } catch(e) {
            infos.push(`BoM #${idx+1}: エラー → ${e.message}`);
          }
        }
        if (!snaps.length) throw new Error("有効な BoM データが1つもありません。");

        const ref = snaps[0];
        for (const s of snaps) {
          if (s.latMin!==ref.latMin || s.latStep!==ref.latStep || s.latN!==ref.latN ||
              s.lonMin!==ref.lonMin || s.lonStep!==ref.lonStep || s.lonN!==ref.lonN) {
            throw new Error("BoMファイル同士でグリッド仕様が異なります。");
          }
        }

        snaps.sort((a,b)=>a.time - b.time);
        gBomSnaps = snaps;
        gClimBaseTime = snaps[snaps.length-1].time;
        infos.push(`BoM スナップショット数: ${snaps.length}`);
        snaps.forEach((s, i)=>{
          infos.push(`  [${i}] index#${s.index}, VALID UTC = ${s.time.toISOString()}`);
        });

        const pad = n => n.toString().padStart(2,"0");
        const t = gClimBaseTime;
        const isoLocal = `${t.getUTCFullYear()}-${pad(t.getUTCMonth()+1)}-${pad(t.getUTCDate())}T${pad(t.getUTCHours())}:${pad(t.getUTCMinutes())}`;
        document.getElementById("timeNow").value = isoLocal;

        const latN = ref.latN;
        const lonN = ref.lonN;
        const latMin = ref.latMin;
        const lonMin = ref.lonMin;
        const latStep = ref.latStep;
        const lonStep = ref.lonStep;

        const K = snaps.length;
        const xs = new Array(K);
        for (let k=0;k<K;k++) xs[k] = [];

        for (let k=0;k<K;k++) {
          const snap = snaps[k];
          xs[k].length = latN;
          for (let i=0;i<latN;i++) {
            const lat = latMin + i*latStep;
            xs[k][i] = new Array(lonN);
            for (let j=0;j<lonN;j++) {
              const lon = lonMin + j*lonStep;
              const z = solarZenith(snap.time, lat, lon);
              xs[k][i][j] = xFromCosChi(z.cosChi);
            }
          }
        }

        const aGrid = [];
        const bGrid = [];
        for (let i=0;i<latN;i++) {
          aGrid[i] = new Array(lonN);
          bGrid[i] = new Array(lonN);
          for (let j=0;j<lonN;j++) {
            const Tks = [];
            const Xks = [];
            for (let k=0;k<K;k++) {
              const val = snaps[k].grid[i][j];
              if (isFinite(val)) {
                Tks.push(val);
                Xks.push(xs[k][i][j]);
              }
            }
            let a=0,b=0;
            const n = Tks.length;
            if (n===0) {
              a=0; b=0;
            } else if (n===1) {
              a=Tks[0]; b=0;
            } else {
              let Sx=0,Sy=0,Sxx=0,Sxy=0;
              for (let m=0;m<n;m++) {
                const x = Xks[m];
                const y = Tks[m];
                Sx  += x;
                Sy  += y;
                Sxx += x*x;
                Sxy += x*y;
              }
              const den = n*Sxx - Sx*Sx;
              if (Math.abs(den) < 1e-9) {
                a = Sy/n;
                b = 0;
              } else {
                b = (n*Sxy - Sx*Sy) / den;
                a = (Sy - b*Sx)/n;
              }
              if (!isFinite(a)) a=0;
              if (!isFinite(b)) b=0;
            }
            aGrid[i][j] = Math.max(a, 0);
            bGrid[i][j] = b;
          }
        }

        gAB = {
          a: aGrid,
          b: bGrid,
          latMin, latStep, latN,
          lonMin, lonStep, lonN
        };
        infos.push("日周カーブパラメータ a(夜側) / b(昼側増分) を格子ごとに計算しました。");

      } catch(e) {
        infos.push("全体エラー: " + e.message);
        gBomSnaps = [];
        gAB = null;
        gForecastFrames = null;
      }
      document.getElementById("bomMultiInfo").textContent = infos.join("\n");
    }

    // ========= BoM 検索 =========
    function searchOnBom() {
      const out = document.getElementById("bomSearchInfo");
      try {
        if (!gBomSnaps.length) throw new Error("先に BoM を解析してください。");
        const b = gBomSnaps[gBomSnaps.length-1];
        const lat = parseFloat(document.getElementById("latSearch").value);
        const lon = parseFloat(document.getElementById("lonSearch").value);
        if (!isFinite(lat)||!isFinite(lon)) throw new Error("lat / lon を確認してください。");

        const iLatRaw = (lat - b.latMin)/b.latStep;
        const iLonRaw = (lon - b.lonMin)/b.lonStep;
        let iLat = Math.round(iLatRaw);
        let iLon = Math.round(iLonRaw);
        iLat = Math.max(0, Math.min(iLat, b.latN-1));
        iLon = Math.max(0, Math.min(iLon, b.lonN-1));

        const latA = b.latMin + iLat*b.latStep;
        const lonA = b.lonMin + iLon*b.lonStep;
        const val  = b.grid[iLat][iLon];

        const lines = [];
        lines.push(`BoM 最新時刻: ${b.time.toISOString()}`);
        lines.push(`要求地点: lat=${lat}, lon=${lon}`);
        lines.push(`最近格子: lat≈${latA.toFixed(2)}, lon≈${lonA.toFixed(2)}`);
        lines.push(`BoM TEC ≒ ${val.toFixed(2)} TECU`);
        out.textContent = lines.join("\n");

        document.getElementById("latForecast").value = lat;
        document.getElementById("lonForecast").value = lon;
        document.getElementById("tecNow").value = val.toFixed(2);

      } catch(e) {
        out.textContent = "エラー: " + e.message;
      }
    }

    // ========= NOAA 27日テーブル =========
    function parseNOAA27(text, targetDate) {
      if (!text.trim()) throw new Error("NOAAテキストが空です");
      const lines = text.split(/\r?\n/);
      const pattern = /^(20\d{2})\s+(\w{3})\s+(\d{2})\s+(\d+)\s+(\d+)/;
      const monthMap = {Jan:0,Feb:1,Mar:2,Apr:3,May:4,Jun:5,Jul:6,Aug:7,Sep:8,Oct:9,Nov:10,Dec:11};
      const rows = [];
      for (const L of lines) {
        const m = L.match(pattern);
        if (!m) continue;
        const year = parseInt(m[1],10);
        const mon  = monthMap[m[2]] ?? null;
        const day  = parseInt(m[3],10);
        if (mon===null) continue;
        const dUTC = new Date(Date.UTC(year,mon,day,12,0,0));
        const F107 = parseFloat(m[4]);
        const Ap   = parseFloat(m[5]);
        rows.push({date:dUTC, F107, Ap});
      }
      if (!rows.length) throw new Error("27-day 行が見つかりません");

      const tgt = new Date(Date.UTC(targetDate.getUTCFullYear(),targetDate.getUTCMonth(),targetDate.getUTCDate()));
      let best=null, bestDiff=Number.POSITIVE_INFINITY;
      for (const r of rows) {
        const d = new Date(Date.UTC(r.date.getUTCFullYear(),r.date.getUTCMonth(),r.date.getUTCDate()));
        const diff = Math.abs(d - tgt);
        if (diff<bestDiff) {bestDiff=diff;best=r;}
      }
      return best;
    }
    function testParseNOAA() {
      try {
        if (!gClimBaseTime) throw new Error("先に BoM を解析してください。");
        const txt = document.getElementById("noaaInput").value;
        const r = parseNOAA27(txt, gClimBaseTime);
        document.getElementById("F107").value = r.F107.toFixed(1);
        document.getElementById("Ap").value   = r.Ap.toFixed(1);
        const lines = [];
        lines.push(`BoMに最も近い日付: ${r.date.toISOString().slice(0,10)}`);
        lines.push(`F10.7 = ${r.F107}, Ap = ${r.Ap}`);
        document.getElementById("noaaInfo").textContent = lines.join("\n");
      } catch(e) {
        document.getElementById("noaaInfo").textContent = "エラー: " + e.message;
      }
    }

    // ========= Dst =========
    function parseDstTable(text, targetDate) {
      if (!text.trim()) throw new Error("Dstテキストが空です");
      const lines = text.split(/\r?\n/);
      let start = -1;
      for (let i=0;i<lines.length;i++) {
        if (lines[i].includes("DAY")) {start=i+1;break;}
      }
      if (start<0) throw new Error("DAY 行が見つかりません");
      const rows = [];
      for (let i=start;i<lines.length;i++) {
        const L = lines[i].trim();
        if (!L) continue;
        const parts = L.split(/\s+/);
        const day = parseInt(parts[0],10);
        if (isNaN(day)) continue;
        const vals = parts.slice(1).map(v=>parseInt(v,10));
        rows.push({day, vals});
      }
      if (!rows.length) throw new Error("Dstデータ行がありません");
      const d = targetDate.getUTCDate();
      const hh = targetDate.getUTCHours();
      const row = rows.find(r=>r.day===d) || rows[0];
      const idx = Math.max(0, Math.min(hh, row.vals.length-1));
      return row.vals[idx];
    }
    function testParseDst() {
      try {
        if (!gClimBaseTime) throw new Error("先に BoM を解析してください。");
        const txt = document.getElementById("dstInput").value;
        const dst = parseDstTable(txt, gClimBaseTime);
        document.getElementById("DstVal").value = dst.toFixed(0);
        const lines = [];
        lines.push(`基準UTC = ${gClimBaseTime.toISOString()}, hour=${gClimBaseTime.getUTCHours()}`);
        lines.push(`Dst ≒ ${dst} nT`);
        document.getElementById("dstInfo").textContent = lines.join("\n");
      } catch(e) {
        document.getElementById("dstInfo").textContent = "エラー: " + e.message;
      }
    }

    // ========= X-ray =========
    function makeDailyXrayEffective(text, bomTimeUtc) {
      if (!text.trim()) throw new Error("X-ray JSON が空です");
      let arr;
      try {
        arr = JSON.parse(text);
      } catch(e) {
        throw new Error("X-ray JSON をパースできません");
      }
      const dayStr = bomTimeUtc.toISOString().slice(0,10);
      const samples = arr.filter(o =>
        o.energy==="0.1-0.8nm" &&
        typeof o.time_tag==="string" &&
        o.time_tag.startsWith(dayStr)
      );
      if (!samples.length) throw new Error("BoM日付のサンプルがありません");
      const fluxes = samples.map(o=>parseFloat(o.flux)).filter(v=>isFinite(v)&&v>0);
      if (!fluxes.length) throw new Error("有効なfluxがありません");

      const Xmean = fluxes.reduce((a,b)=>a+b,0)/fluxes.length;
      const Xmax  = Math.max.apply(null, fluxes);
      const X0    = 1e-8;
      const XeffLog = 0.5*Math.log10(Xmax/X0+1) + 0.5*Math.log10(Xmean/X0+1);
      return {Xmean,Xmax,XeffLog};
    }
    function testParseXray() {
      try {
        if (!gClimBaseTime) throw new Error("先に BoM を解析してください。");
        const txt = document.getElementById("xrayInput").value;
        const daily = makeDailyXrayEffective(txt, gClimBaseTime);
        gXrayDaily = daily;
        const lines = [];
        lines.push(`BoM日付: ${gClimBaseTime.toISOString().slice(0,10)}`);
        lines.push(`Xmean ≒ ${daily.Xmean.toExponential(3)} W/m²`);
        lines.push(`Xmax  ≒ ${daily.Xmax.toExponential(3)} W/m²`);
        lines.push(`X_eff(log) ≒ ${daily.XeffLog.toFixed(3)}`);
        document.getElementById("xrayInfo").textContent = lines.join("\n");
      } catch(e) {
        document.getElementById("xrayInfo").textContent = "エラー: " + e.message;
      }
    }

    // ========= 太陽活動スケール =========
    function solarBackgroundScale(F107, Ap) {
      const F0=120, Ap0=5;
      const dF  = (F107-F0)/F0;
      const dAp = (Ap-Ap0)/50;
      let s = 1 + 0.4*dF + 0.3*dAp;
      if (!isFinite(s)) s=1;
      return Math.max(0.6, Math.min(1.4, s));
    }
    function dstScale(latDeg, Dst) {
      const D0=0;
      const dD = (Dst-D0)/100;
      const wLat = 0.3 + 0.7*Math.min(1, Math.abs(latDeg)/60);
      let s = 1 + 0.4*wLat*dD;
      if (!isFinite(s)) s=1;
      return Math.max(0.6, Math.min(1.4, s));
    }
    function xrayScale(latDeg, cosChi, XeffLog) {
      if (!gXrayDaily) return 1;
      const wDay = Math.max(cosChi,0);
      const wLat = 0.5 + 0.5*Math.min(1, Math.abs(latDeg)/50);
      let s = 1 + 0.25*wDay*wLat*XeffLog;
      if (!isFinite(s)) s=1;
      return Math.max(0.7, Math.min(1.5, s));
    }

    // ========= 1地点予報 =========
    function runForecast() {
      const out = document.getElementById("forecastOut");
      try {
        if (!gAB) throw new Error("先に BoM を解析して a,b を作成してください。");
        if (!gXrayDaily) throw new Error("先に X-ray を解析してください。");

        const T0 = parseFloat(document.getElementById("tecNow").value);
        const F107 = parseFloat(document.getElementById("F107").value);
        const Ap   = parseFloat(document.getElementById("Ap").value);
        const Dst  = parseFloat(document.getElementById("DstVal").value);
        const dt   = parseFloat(document.getElementById("dT").value);
        const lat  = parseFloat(document.getElementById("latForecast").value);
        const lon  = parseFloat(document.getElementById("lonForecast").value);
        const tStr = document.getElementById("timeNow").value;

        if (!tStr) throw new Error("観測時刻(UTC) を入力してください。");
        if ([T0,F107,Ap,Dst,dt,lat,lon].some(v=>!isFinite(v))) {
          throw new Error("入力値に不正があります。");
        }

        const [dPart,hPart] = tStr.split("T");
        const [Y,M,D] = dPart.split("-").map(x=>parseInt(x,10));
        const [hh,mm] = hPart.split(":").map(x=>parseInt(x,10));
        const t0 = new Date(Date.UTC(Y,M-1,D,hh,mm,0));
        const tFuture = new Date(t0.getTime() + dt*3600*1000);

        const z0 = solarZenith(t0, lat, lon);
        const zF = solarZenith(tFuture, lat, lon);
        const x0 = xFromCosChi(z0.cosChi);
        const xF = xFromCosChi(zF.cosChi);

        const iLatRaw = (lat - gAB.latMin)/gAB.latStep;
        const iLonRaw = (lon - gAB.lonMin)/gAB.lonStep;
        let iLat = Math.round(iLatRaw);
        let iLon = Math.round(iLonRaw);
        iLat = Math.max(0, Math.min(iLat, gAB.latN-1));
        iLon = Math.max(0, Math.min(iLon, gAB.lonN-1));
        const a = gAB.a[iLat][iLon];
        const b = gAB.b[iLat][iLon];
        const Tclim_now = Math.max(a + b*x0, 0);
        const Tclim_fut = Math.max(a + b*xF, 0);

        const Ssolar = solarBackgroundScale(F107, Ap);
        const Sdst   = dstScale(lat, Dst);
        const Sxray  = xrayScale(lat, zF.cosChi, gXrayDaily.XeffLog);

        const Tpred = Tclim_fut * Ssolar * Sdst * Sxray;

        const lines = [];
        lines.push(`地点: lat=${lat.toFixed(2)}°, lon=${lon.toFixed(2)}°`);
        lines.push(`観測時刻(UTC): ${t0.toISOString()}`);
        lines.push(`予報時刻(UTC): ${tFuture.toISOString()} (Δt=${dt.toFixed(1)}h)`);
        lines.push("");
        lines.push(`BoMベース a ≒ ${a.toFixed(2)}, b ≒ ${b.toFixed(2)}`);
        lines.push(`x(now)=${x0.toFixed(3)}, x(future)=${xF.toFixed(3)}`);
        lines.push(`T_clim(now) ≒ ${Tclim_now.toFixed(2)} TECU`);
        lines.push(`T_clim(future) ≒ ${Tclim_fut.toFixed(2)} TECU`);
        lines.push("");
        lines.push(`F10.7=${F107.toFixed(1)}, Ap=${Ap.toFixed(1)}, Dst=${Dst.toFixed(0)} nT, X_eff(log)=${gXrayDaily.XeffLog.toFixed(3)}`);
        lines.push(`S_solar ≒ ${Ssolar.toFixed(3)}, S_dst ≒ ${Sdst.toFixed(3)}, S_xray ≒ ${Sxray.toFixed(3)}`);
        lines.push("");
        lines.push(`SWIFT-TEC予報 ≒ ${Tpred.toFixed(2)} TECU`);
        out.textContent = lines.join("\n");

      } catch(e) {
        out.textContent = "エラー: " + e.message;
      }
    }

    // ========= 72時間グローバル予報 =========
    function computeForecastFrames() {
      if (!gAB) { alert("先に BoM を解析してください。"); return; }
      if (!gXrayDaily) { alert("先に X-ray を解析してください。"); return; }

      const F107 = parseFloat(document.getElementById("F107").value);
      const Ap   = parseFloat(document.getElementById("Ap").value);
      const Dst  = parseFloat(document.getElementById("DstVal").value);
      const tStr = document.getElementById("timeNow").value;
      if (!tStr) { alert("観測基準時刻(UTC) を入力してください。"); return; }
      if ([F107,Ap,Dst].some(v=>!isFinite(v))) {
        alert("F10.7 / Ap / Dst を確認してください。");
        return;
      }

      const [dPart,hPart] = tStr.split("T");
      const [Y,M,D] = dPart.split("-").map(x=>parseInt(x,10));
      const [hh,mm] = hPart.split(":").map(x=>parseInt(x,10));
      const t0 = new Date(Date.UTC(Y,M-1,D,hh,mm,0));
      gForecastStartTime = t0;

      const latN = gAB.latN;
      const lonN = gAB.lonN;
      const latMin = gAB.latMin;
      const lonMin = gAB.lonMin;
      const latStep = gAB.latStep;
      const lonStep = gAB.lonStep;

      const Ssolar = solarBackgroundScale(F107, Ap);

      const maxHours = 72;
      const stepMin = 30;
      const nSteps = Math.round(maxHours*60/stepMin);
      gForecastFrames = [];
      gForecastDt = [];

      for (let k=0;k<=nSteps;k++) {
        const dtHours = k*stepMin/60;
        gForecastDt.push(dtHours);
        const t = new Date(t0.getTime() + dtHours*3600*1000);
        const frame = new Array(latN);
        for (let i=0;i<latN;i++) {
          frame[i] = new Array(lonN);
          const lat = latMin + i*latStep;
          for (let j=0;j<lonN;j++) {
            const lon = lonMin + j*lonStep;
            const a   = gAB.a[i][j];
            const b   = gAB.b[i][j];
            const z   = solarZenith(t, lat, lon);
            const x   = xFromCosChi(z.cosChi);
            let Tclim = a + b*x;
            if (!isFinite(Tclim) || Tclim<0) Tclim=0;

            const Sdst = dstScale(lat, Dst);
            const Sx   = xrayScale(lat, z.cosChi, gXrayDaily.XeffLog);
            let T = Tclim * Ssolar * Sdst * Sx;
            if (!isFinite(T) || T<0) T=0;

            frame[i][j] = T;
          }
        }
        gForecastFrames.push(frame);
      }

      const slider = document.getElementById("timeSlider");
      slider.min = 0;
      slider.max = nSteps.toString();
      slider.value = "0";
      updateSliderLabel();
      drawTecMap();
    }

    function onSliderChange() {
      updateSliderLabel();
      drawTecMap();
    }
    function updateSliderLabel() {
      const slider = document.getElementById("timeSlider");
      const idx = parseInt(slider.value,10);
      const dt = gForecastDt && gForecastDt.length ? gForecastDt[idx] : 0;
      document.getElementById("sliderLabel").textContent = `t = ${dt.toFixed(1)} h`;
      if (gForecastStartTime && gForecastDt && gForecastDt.length) {
        const t = new Date(gForecastStartTime.getTime() + dt*3600*1000);
        document.getElementById("timeUTCLabel").textContent = `UTC: ${t.toISOString().slice(0,19)}`;
      } else {
        document.getElementById("timeUTCLabel").textContent = "UTC: --";
      }
    }

    // ========= 色スケール =========
    function hexToRgb(hex) {
      if (!/^#?[0-9A-Fa-f]{6}$/.test(hex)) return null;
      const h = hex.replace("#","");
      const r = parseInt(h.slice(0,2),16);
      const g = parseInt(h.slice(2,4),16);
      const b = parseInt(h.slice(4,6),16);
      return {r,g,b};
    }

    function readColorStopsInputRaw() {
      const stops = [];
      for (let i=1;i<=5;i++) {
        const vStr = document.getElementById("csVal"+i)?.value;
        const cStr = document.getElementById("csColor"+i)?.value;
        if (!vStr || !cStr) continue;
        const v = parseFloat(vStr);
        const rgb = hexToRgb(cStr);
        if (!isFinite(v) || !rgb) continue;
        stops.push({val:v, rgb, hex:cStr});
      }
      stops.sort((a,b)=>a.val-b.val);
      return stops;
    }

    function readColorStops() {
      const raw = readColorStopsInputRaw();
      if (raw.length < 2) {
        return [
          {val:0,   rgb:{r:0,g:0,b:90}},
          {val:30,  rgb:{r:0,g:136,b:0}},
          {val:45,  rgb:{r:208,g:255,b:208}},
          {val:60,  rgb:{r:255,g:255,b:0}},
          {val:80,  rgb:{r:255,g:128,b:0}},
          {val:120, rgb:{r:255,g:0,b:0}}
        ];
      }
      return raw;
    }

    function applyColorStops(stops) {
      if (!stops || !stops.length) return;
      stops.sort((a,b)=>a.val-b.val);
      for (let i=1;i<=5;i++) {
        const vInput = document.getElementById("csVal"+i);
        const cInput = document.getElementById("csColor"+i);
        if (!vInput || !cInput) continue;
        if (i-1 < stops.length) {
          vInput.value = stops[i-1].val;
          cInput.value = stops[i-1].hex || "#000000";
        } else {
          // 余りは何もしない
        }
      }
    }

    function colorForTEC(T, stops) {
      const v = Math.max(0, Math.min(120, T));
      if (!stops || !stops.length) {
        return {r:0,g:0,b:90};
      }
      if (v <= stops[0].val) return stops[0].rgb;
      const last = stops[stops.length-1];
      if (v >= last.val) return last.rgb;
      for (let i=0;i<stops.length-1;i++) {
        const s0 = stops[i];
        const s1 = stops[i+1];
        if (v >= s0.val && v <= s1.val) {
          const t = (v - s0.val) / (s1.val - s0.val || 1);
          return {
            r: Math.round(s0.rgb.r*(1-t) + s1.rgb.r*t),
            g: Math.round(s0.rgb.g*(1-t) + s1.rgb.g*t),
            b: Math.round(s0.rgb.b*(1-t) + s1.rgb.b*t)
          };
        }
      }
      return last.rgb;
    }

    // ========= 地図オーバーレイ & 保存 =========
    function getMapParams() {
      const scaleX = parseFloat(document.getElementById("mapScaleX")?.value) || 1.0;
      const scaleY = parseFloat(document.getElementById("mapScaleY")?.value) || 1.0;
      const offsetX = parseFloat(document.getElementById("mapOffsetX")?.value) || 0;
      const offsetY = parseFloat(document.getElementById("mapOffsetY")?.value) || 0;
      const alpha = parseFloat(document.getElementById("mapAlpha")?.value);
      const a = (isFinite(alpha)? alpha : 0.5);
      return {
        scaleX: Math.max(0.1, Math.min(5, scaleX)),
        scaleY: Math.max(0.1, Math.min(5, scaleY)),
        offsetX,
        offsetY,
        alpha: Math.max(0, Math.min(1, a))
      };
    }

    function setMapParamsToInputs(p) {
      if (!p) return;
      if (document.getElementById("mapScaleX")) document.getElementById("mapScaleX").value = p.scaleX;
      if (document.getElementById("mapScaleY")) document.getElementById("mapScaleY").value = p.scaleY;
      if (document.getElementById("mapOffsetX")) document.getElementById("mapOffsetX").value = p.offsetX;
      if (document.getElementById("mapOffsetY")) document.getElementById("mapOffsetY").value = p.offsetY;
      if (document.getElementById("mapAlpha"))   document.getElementById("mapAlpha").value   = p.alpha;
    }

    function saveMapParams() {
      try {
        const p = getMapParams();
        localStorage.setItem("swifttec_map_params", JSON.stringify(p));
      } catch(e) {
        console.warn("map params save failed:", e);
      }
    }

    function onMapParamChange() {
      saveMapParams();
      drawTecMap();
    }

    function loadMapFileFromFile(file) {
      const reader = new FileReader();
      reader.onload = e => {
        const dataUrl = e.target.result;
        try {
          localStorage.setItem("swifttec_map_image", dataUrl);
        } catch(err) {
          console.warn("localStorage 保存に失敗しました（容量など）:", err);
        }
        const img = new Image();
        img.onload = () => {
          gMapImage = img;
          drawTecMap();
        };
        img.src = dataUrl;
      };
      reader.readAsDataURL(file);
    }

    function handleMapFileInput(e) {
      const file = e.target.files[0];
      if (file) loadMapFileFromFile(file);
    }

    function clearMapImage() {
      gMapImage = null;
      try {
        localStorage.removeItem("swifttec_map_image");
        // パラメータは残してもよいが、ここでは残す
      } catch(e) {}
      drawTecMap();
    }

    // ========= 設定保存・読み込み(JSON) =========
    function downloadConfig() {
      try {
        const cfg = {
          colorStops: readColorStopsInputRaw(),
          mapParams: getMapParams()
        };
        const blob = new Blob([JSON.stringify(cfg,null,2)], {type:"application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "swifttec_config.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      } catch(e) {
        alert("設定保存に失敗しました: " + e.message);
      }
    }

    function loadConfigFromFile() {
      const input = document.getElementById("configFile");
      if (!input || !input.files || !input.files[0]) {
        alert("設定ファイルを選択してください。");
        return;
      }
      const file = input.files[0];
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const cfg = JSON.parse(e.target.result);
          if (cfg.colorStops) applyColorStops(cfg.colorStops);
          if (cfg.mapParams) {
            setMapParamsToInputs(cfg.mapParams);
            saveMapParams();
          }
          drawTecMap();
          alert("設定を読み込みました。");
        } catch(err) {
          alert("設定ファイルが不正です: " + err.message);
        }
      };
      reader.readAsText(file);
    }

    // ========= ヒートマップ描画 =========
    function drawTecMap() {
      const canvas = document.getElementById("tecMapCanvas");
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#000000";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const legendWidth = 80;
      const plotW = canvas.width - legendWidth;
      const plotH = canvas.height;

      // ベース地図（背景）
      if (gMapImage) {
        const p = getMapParams();
        ctx.save();
        ctx.globalAlpha = p.alpha;
        const imgW = plotW * p.scaleX;
        const imgH = plotH * p.scaleY;
        const x0 = p.offsetX;
        const y0 = p.offsetY;
        ctx.drawImage(gMapImage, x0, y0, imgW, imgH);
        ctx.restore();
      }

      if (!gForecastFrames || !gForecastFrames.length || !gAB) {
        ctx.fillStyle = "#9fb5ff";
        ctx.fillText("まだ予報が計算されていません。", 20, 20);
        return;
      }

      const idx = parseInt(document.getElementById("timeSlider").value,10);
      const frame = gForecastFrames[idx];
      const latN = gAB.latN;
      const lonN = gAB.lonN;

      const stops = readColorStops();
      const cellW = plotW / lonN;
      const cellH = plotH / latN;

      ctx.save();
      ctx.globalAlpha = 0.7;
      for (let i=0;i<latN;i++) {
        for (let j=0;j<lonN;j++) {
          const T = frame[i][j];
          const c = colorForTEC(T, stops);
          ctx.fillStyle = `rgb(${c.r},${c.g},${c.b})`;
          const x = j*cellW;
          const y = (latN-1-i)*cellH;
          ctx.fillRect(x,y,cellW+1,cellH+1);
        }
      }
      ctx.restore();

      // 緯度経度グリッド＆ラベル
      const latMin = gAB.latMin;
      const lonMin = gAB.lonMin;
      const latStep = gAB.latStep;
      const lonStep = gAB.lonStep;
      const latMax = latMin + (latN-1)*latStep;
      const lonMax = lonMin + (lonN-1)*lonStep;

      ctx.strokeStyle = "rgba(255,255,255,0.15)";
      ctx.lineWidth = 0.5;
      ctx.fillStyle = "#ffffff";
      ctx.font = "10px sans-serif";

      for (let lat=-80; lat<=80; lat+=20) {
        const t = (lat - latMin)/(latMax - latMin);
        const y = (1-t)*plotH;
        ctx.beginPath();
        ctx.moveTo(0,y);
        ctx.lineTo(plotW,y);
        ctx.stroke();
        ctx.fillText(`${lat}°`, 2, y-2);
      }

      for (let lon=-180; lon<=180; lon+=60) {
        const t = (lon - lonMin)/(lonMax - lonMin);
        const x = t*plotW;
        ctx.beginPath();
        ctx.moveTo(x,0);
        ctx.lineTo(x,plotH);
        ctx.stroke();
        ctx.fillText(`${lon}°`, x-12, plotH-4);
      }

      // 凡例
      const legendX = plotW + 10;
      const legendYTop = 20;
      const legendYBot = canvas.height - 40;
      const legendH = legendYBot - legendYTop;
      const legendWRect = 20;
      const TMin = 0, TMax = 120;

      for (let y=0;y<legendH;y++) {
        const frac = 1 - y/legendH;
        const T = TMin + frac*(TMax-TMin);
        const c = colorForTEC(T, stops);
        ctx.fillStyle = `rgb(${c.r},${c.g},${c.b})`;
        ctx.fillRect(legendX, legendYTop + y, legendWRect, 1);
      }
      ctx.strokeStyle = "#ffffff";
      ctx.strokeRect(legendX, legendYTop, legendWRect, legendH);
      ctx.fillStyle = "#ffffff";
      ctx.font = "11px sans-serif";
      ctx.fillText("TEC (TECU)", legendX-5, legendYTop-6);

      const usedStops = readColorStops();
      ctx.font = "10px sans-serif";
      for (const s of usedStops) {
        const frac = (s.val - TMin)/(TMax - TMin);
        const y = legendYBot - frac*legendH;
        ctx.fillText(`${s.val.toFixed(0)}`, legendX + legendWRect + 6, y+3);
      }
    }

    // ========= Excel出力 =========
    function exportCurrentFrameToExcel() {
      const out = document.getElementById("excelOut");
      if (!gForecastFrames || !gForecastFrames.length || !gAB) {
        out.value = "先に72時間予報を計算してください。";
        return;
      }
      const idx = parseInt(document.getElementById("timeSlider").value,10);
      const frame = gForecastFrames[idx];
      const latN = gAB.latN;
      const lonN = gAB.lonN;
      const latMin = gAB.latMin;
      const lonMin = gAB.lonMin;
      const latStep = gAB.latStep;
      const lonStep = gAB.lonStep;

      const lines = [];
      let header = "lat/lon";
      for (let j=0;j<lonN;j++) {
        const lon = lonMin + j*lonStep;
        header += "," + lon.toFixed(1);
      }
      lines.push(header);
      for (let i=0;i<latN;i++) {
        const lat = latMin + i*latStep;
        let row = lat.toFixed(1);
        for (let j=0;j<lonN;j++) {
          const v = frame[i][j];
          row += "," + v.toFixed(2);
        }
        lines.push(row);
      }
      out.value = lines.join("\n");
    }
    function copyExcelOut() {
      const ta = document.getElementById("excelOut");
      if (!ta.value.trim()) {
        alert("出力がありません。先に出力ボタンを押してください。");
        return;
      }
      ta.focus();
      ta.select();
      try {
        const ok = document.execCommand("copy");
        if (ok) alert("Excel 用グリッドをコピーしました。");
        else alert("コピーに失敗。Ctrl+A → Ctrl+C を試してください。");
      } catch(e) {
        alert("コピーに失敗。Ctrl+A → Ctrl+C を試してください。");
      }
    }

    // ========= 地図ドラッグ＆ドロップ + bg.png + 保存の復元 =========
    window.addEventListener("load", () => {
      const fileInput = document.getElementById("mapFile");
      if (fileInput) {
        fileInput.addEventListener("change", handleMapFileInput);
      }
      const canvas = document.getElementById("tecMapCanvas");
      if (canvas) {
        canvas.addEventListener("dragover", (ev) => {
          ev.preventDefault();
        });
        canvas.addEventListener("drop", (ev) => {
          ev.preventDefault();
          const file = ev.dataTransfer.files[0];
          if (file) loadMapFileFromFile(file);
        });
      }

      // 保存済み地図の復元 or bg.png ロード
      try {
        const savedImg = localStorage.getItem("swifttec_map_image");
        if (savedImg) {
          const img = new Image();
          img.onload = () => {
            gMapImage = img;
            drawTecMap();
          };
          img.src = savedImg;
        } else {
          // リポジトリに bg.png があればそれを初期背景として読み込む
          const img = new Image();
          img.onload = () => {
            gMapImage = img;
            drawTecMap();
          };
          img.onerror = () => {
            // bg.png が無い場合は何もしない
            drawTecMap();
          };
          img.src = "bg.png";
        }

        const savedParams = localStorage.getItem("swifttec_map_params");
        if (savedParams) {
          const p = JSON.parse(savedParams);
          setMapParamsToInputs(p);
        }
      } catch(e) {
        console.warn("保存済み背景画像・パラメータの復元に失敗:", e);
        drawTecMap();
      }
    });
  </script>
</body>
</html>

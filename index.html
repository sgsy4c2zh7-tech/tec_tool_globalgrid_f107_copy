<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v2 – TEC Forecast & Verification Tool</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1020;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin: 0 0 4px 0;
      letter-spacing: 0.03em;
    }
    h1 {
      font-size: 20px;
    }
    h2 {
      font-size: 16px;
    }
    h3 {
      font-size: 14px;
    }
    .page {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    .sidebar {
      width: 420px;
      min-width: 360px;
      max-width: 480px;
      border-right: 1px solid #222b3f;
      padding: 10px;
      overflow-y: auto;
      background: radial-gradient(circle at top, #1c2740 0, #050814 55%, #050814 100%);
    }
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
    }
    .card {
      background: rgba(10, 16, 32, 0.96);
      border: 1px solid #222b3f;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .card-header span {
      font-size: 11px;
      opacity: 0.7;
    }
    textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #334;
      background: #050814;
      color: #f5f5f5;
      font-family: "Consolas","Menlo",monospace;
    }
    input[type="number"],
    input[type="text"],
    input[type="color"] {
      background: #050814;
      border-radius: 4px;
      border: 1px solid #334;
      color: #f5f5f5;
      font-size: 11px;
      padding: 2px 4px;
      font-family: inherit;
    }
    input[type="checkbox"] {
      transform: scale(0.9);
    }
    label {
      font-size: 11px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-bottom: 4px;
      align-items: center;
      flex-wrap: wrap;
    }
    .row > div {
      flex: 1;
      min-width: 80px;
    }
    button {
      border-radius: 4px;
      border: 1px solid #3b82f6;
      background: #1d4ed8;
      color: #f9fafb;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary {
      border-color: #4b5563;
      background: #111827;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .small {
      font-size: 10px;
      opacity: 0.8;
    }
    .canvas-row {
      display: flex;
      gap: 8px;
      flex: 1;
      min-height: 0;
    }
    #tecCanvas {
      flex: 3;
      border-radius: 8px;
      border: 1px solid #222b3f;
      background: #000;
    }
    #verifyCanvas {
      flex: 1;
      border-radius: 8px;
      border: 1px solid #222b3f;
      background: #000;
      max-width: 220px;
    }
    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
    }
    #timeSlider {
      flex: 1;
    }
    pre {
      font-size: 11px;
      background: #050814;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #222b3f;
      overflow-x: auto;
      white-space: pre-wrap;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }
    th, td {
      border: 1px solid #222b3f;
      padding: 2px 4px;
      text-align: center;
    }
    th {
      background: #111827;
    }
    .flex {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
    }
    .flex-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .section-title {
      font-size: 12px;
      font-weight: 600;
      margin-bottom: 2px;
    }
  </style>
</head>
<body>
  <div class="page">
    <div class="sidebar">
      <div class="card">
        <div class="card-header">
          <h1>SWIFT-TEC v2</h1>
          <span>TEC forecast + verification</span>
        </div>
        <div class="small">
          ・BoM TEC を最大6枚貼り付けて 48時間・15分刻みの予報<br>
          ・Deep Flare Net の8領域確率を反映<br>
          ・BoM 実測4枚で 9分割誤差マップ＋係数提案
        </div>
      </div>

      <!-- BoM forecast inputs -->
      <div class="card">
        <div class="card-header">
          <h2>1. BoM TEC（予報用 最大6枚）</h2>
          <span>World0000_tec.txt などをコピペ</span>
        </div>
        <div class="row small">
          <div>BoM #1</div><div>BoM #2</div><div>BoM #3</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput1" placeholder="# PRODUCT NAME..."></textarea></div>
          <div><textarea id="bomInput2"></textarea></div>
          <div><textarea id="bomInput3"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #4</div><div>BoM #5</div><div>BoM #6</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput4"></textarea></div>
          <div><textarea id="bomInput5"></textarea></div>
          <div><textarea id="bomInput6"></textarea></div>
        </div>
        <div class="small" id="bomInfo"></div>
      </div>

      <!-- Solar parameters -->
      <div class="card">
        <div class="card-header">
          <h2>2. 太陽活動パラメータ</h2>
          <span>数値入力版（簡易）</span>
        </div>
        <div class="row">
          <div>
            <label>F10.7 [sfu]</label><br>
            <input id="inpF107" type="number" value="150" step="1">
          </div>
          <div>
            <label>Ap Index</label><br>
            <input id="inpAp" type="number" value="10" step="1">
          </div>
          <div>
            <label>Dst [nT]</label><br>
            <input id="inpDst" type="number" value="-20" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>X-ray (代表値 W/m²)</label><br>
            <input id="inpXray" type="number" value="1e-6" step="1e-7">
          </div>
        </div>
        <div class="small">
          ※ NOAA / 京都WDC / GOES のテキスト自動パースは後から追加可能。<br>
          まずは代表値を手入力して動作確認しましょう。
        </div>
      </div>

      <!-- Deep Flare Net 8 regions -->
      <div class="card">
        <div class="card-header">
          <h2>3. Deep Flare Net 8領域</h2>
          <span>地球全体への効き具合のみ</span>
        </div>
        <div class="small">
          各領域ごとに Xクラス / Mクラス発生確率 [%] を入力。<br>
          同じ場所に複数領域がある場合は「特異なもののみ」入力。
        </div>
        <table>
          <thead>
          <tr>
            <th>ID</th><th>位置イメージ</th><th>P(X≥) %</th><th>P(M≥) %</th><th>使用</th>
          </tr>
          </thead>
          <tbody>
          <tr><td>R1</td><td>北西</td>
            <td><input id="fx1" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm1" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu1" type="checkbox" checked></td>
          </tr>
          <tr><td>R2</td><td>西</td>
            <td><input id="fx2" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm2" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu2" type="checkbox" checked></td>
          </tr>
          <tr><td>R3</td><td>南西</td>
            <td><input id="fx3" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm3" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu3" type="checkbox" checked></td>
          </tr>
          <tr><td>R4</td><td>南</td>
            <td><input id="fx4" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm4" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu4" type="checkbox" checked></td>
          </tr>
          <tr><td>R5</td><td>南東</td>
            <td><input id="fx5" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm5" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu5" type="checkbox" checked></td>
          </tr>
          <tr><td>R6</td><td>東</td>
            <td><input id="fx6" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm6" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu6" type="checkbox" checked></td>
          </tr>
          <tr><td>R7</td><td>北東</td>
            <td><input id="fx7" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm7" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu7" type="checkbox" checked></td>
          </tr>
          <tr><td>R8</td><td>中央</td>
            <td><input id="fx8" type="number" value="0" style="width:50px;"></td>
            <td><input id="fm8" type="number" value="10" style="width:50px;"></td>
            <td><input id="fu8" type="checkbox" checked></td>
          </tr>
          </tbody>
        </table>
      </div>

      <!-- Verification inputs -->
      <div class="card">
        <div class="card-header">
          <h2>4. 検証用 BoM TEC（最大4枚）</h2>
          <span>予報期間中の実測</span>
        </div>
        <div class="row small">
          <div>Verify #1</div><div>Verify #2</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput1"></textarea></div>
          <div><textarea id="verifyInput2"></textarea></div>
        </div>
        <div class="row small">
          <div>Verify #3</div><div>Verify #4</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput3"></textarea></div>
          <div><textarea id="verifyInput4"></textarea></div>
        </div>
        <div class="row">
          <button onclick="runVerification()">検証を実行</button>
          <button class="secondary" onclick="clearVerification()">検証クリア</button>
        </div>
        <div class="small">
          検証では 9分割の MAPE（誤差%）と Bias（過小・過大）を集計。<br>
          係数調整の提案も下部に表示されます。
        </div>
      </div>

      <!-- Color settings for verification -->
      <div class="card">
        <div class="card-header">
          <h2>5. 検証マップ色設定</h2>
          <span>誤差(%) → 色を任意設定</span>
        </div>
        <div class="small">
          誤差の上限と色を設定。<br>
          例）10%まで緑、20%まで黄、30%までオレンジ、それ以上赤。
        </div>
        <table>
          <thead>
          <tr><th>レベル</th><th>誤差上限%</th><th>色</th></tr>
          </thead>
          <tbody>
          <tr>
            <td>L1</td>
            <td><input id="vLimit1" type="number" value="10" style="width:50px;"></td>
            <td><input id="vColor1" type="color" value="#00ff00"></td>
          </tr>
          <tr>
            <td>L2</td>
            <td><input id="vLimit2" type="number" value="20" style="width:50px;"></td>
            <td><input id="vColor2" type="color" value="#ffff00"></td>
          </tr>
          <tr>
            <td>L3</td>
            <td><input id="vLimit3" type="number" value="30" style="width:50px;"></td>
            <td><input id="vColor3" type="color" value="#ff9900"></td>
          </tr>
          <tr>
            <td>L4</td>
            <td><input id="vLimit4" type="number" value="999" style="width:50px;"></td>
            <td><input id="vColor4" type="color" value="#ff0000"></td>
          </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyVerifyColorScale()">色設定を反映</button>
          <button class="secondary" onclick="resetVerifyColorScale()">初期化</button>
        </div>
      </div>

      <!-- Advanced coefficients -->
      <div class="card">
        <div class="card-header">
          <h2>6. 係数設定（Advanced）</h2>
          <span>バイアス提案の対象</span>
        </div>
        <div class="small">※いじり過ぎる前に現在値をメモ推奨。</div>
        <div class="flex-col">
          <div class="row">
            <div>
              <label>kGlobal（全体スケール）</label><br>
              <input id="cfg_kGlobal" type="number" value="1.0" step="0.05">
            </div>
            <div>
              <label>wF107</label><br>
              <input id="cfg_wF107" type="number" value="0.004" step="0.001">
            </div>
            <div>
              <label>wAp</label><br>
              <input id="cfg_wAp" type="number" value="0.01" step="0.002">
            </div>
          </div>
          <div class="row">
            <div>
              <label>wDst</label><br>
              <input id="cfg_wDst" type="number" value="-0.002" step="0.001">
            </div>
            <div>
              <label>pX（日中指数）</label><br>
              <input id="cfg_pX" type="number" value="1.5" step="0.1">
            </div>
            <div>
              <label>latShape（赤道異常）</label><br>
              <input id="cfg_latShape" type="number" value="0.4" step="0.05">
            </div>
          </div>
          <div class="row">
            <div>
              <label>latHighCut（高緯度減衰）</label><br>
              <input id="cfg_latHighCut" type="number" value="0.5" step="0.05">
            </div>
            <div>
              <label>β_flare</label><br>
              <input id="cfg_betaFlare" type="number" value="0.5" step="0.05">
            </div>
            <div>
              <label>k_X</label><br>
              <input id="cfg_kX" type="number" value="1.0" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>k_M</label><br>
              <input id="cfg_kM" type="number" value="0.3" step="0.1">
            </div>
            <div>
              <label>biasThresh%（提案閾値）</label><br>
              <input id="cfg_biasThresh" type="number" value="15" step="1">
            </div>
            <div>
              <label>suggestGain（提案の強さ）</label><br>
              <input id="cfg_suggestGain" type="number" value="0.5" step="0.1">
            </div>
          </div>
        </div>
        <div class="row">
          <button onclick="saveConfig()">設定を保存</button>
          <button class="secondary" onclick="loadConfig(true)">保存値を再読込</button>
        </div>
      </div>

      <!-- Control buttons -->
      <div class="card">
        <div class="card-header">
          <h2>7. 実行</h2>
          <span>予報＆描画</span>
        </div>
        <div class="row">
          <button onclick="runForecast()">TEC予報を計算</button>
          <button class="secondary" onclick="resetAll()">リセット</button>
        </div>
        <div id="runInfo" class="small"></div>
      </div>
    </div>

    <!-- MAIN AREA -->
    <div class="main">
      <div class="card" style="flex:0 0 auto;">
        <div class="slider-row">
          <span>時間スライダー（0〜48h / 15分刻み）</span>
          <input type="range" id="timeSlider" min="0" max="192" value="0" oninput="onSliderChange()">
          <span id="timeLabel">t=0.00h (UTC ?)</span>
        </div>
        <div class="row small">
          <div>
            背景画像（地図）: <input type="file" id="bgFile" accept="image/png,image/jpeg">
          </div>
          <div>
            透明度:
            <input id="bgAlpha" type="range" min="0" max="1" step="0.05" value="0.4" style="width:100px;" oninput="drawTecMap()">
          </div>
          <div>
            地図スケール:
            <input id="bgScale" type="range" min="0.5" max="2" step="0.05" value="1.0" style="width:100px;" oninput="drawTecMap()">
          </div>
        </div>
      </div>

      <div class="canvas-row">
        <canvas id="tecCanvas"></canvas>
        <canvas id="verifyCanvas"></canvas>
      </div>

      <div class="card" style="flex:0 0 35%;">
        <div class="row">
          <div style="flex:2;">
            <h3>8. 検証レポート & 係数提案</h3>
            <pre id="verifyReport">(まだ検証されていません)</pre>
          </div>
          <div style="flex:1;">
            <h3>9. 現在の TEC 値</h3>
            <pre id="pointInfo">マップ上をクリックすると、その格子点のTECと位置が表示されます。</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   グローバル状態
   ========================= */
let gGrid = null;              // {latArr, lonArr, nLat, nLon}
let gForecastFrames = [];      // [timeIndex][iLat][iLon]
let gForecastTimes = [];       // Date objects in UTC
let gForecastStart = null;     // Date UTC
let gBgImage = null;           // background map (optional)

let gVerifyColorScale = [
  { limit: 10,  color: "#00ff00" },
  { limit: 20,  color: "#ffff00" },
  { limit: 30,  color: "#ff9900" },
  { limit: 999, color: "#ff0000" }
];

const STORAGE_KEY_CONFIG = "swifttec_config_v2";
const STORAGE_KEY_VCOL = "swifttec_vcol_v2";

/* =========================
   ユーティリティ
   ========================= */
function logInfo(msg) {
  const div = document.getElementById("runInfo");
  div.textContent = msg;
}
function clamp(v, a, b) {
  return v < a ? a : (v > b ? b : v);
}

/* 日付文字列 → Date UTC */
function parseBomValidTime(text) {
  // Header行: "# VALID DATE/TIME: 11/11/2025 00:00:00UTC"
  const lines = text.split(/\r?\n/);
  for (const line of lines) {
    const m = line.match(/VALID DATE\/TIME:\s*(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/i);
    if (m) {
      const d = parseInt(m[1],10);
      const mo = parseInt(m[2],10);
      const y = parseInt(m[3],10);
      const hh = parseInt(m[4],10);
      const mm = parseInt(m[5],10);
      const ss = parseInt(m[6],10);
      return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
    }
  }
  return null;
}

/* BoM TEC ファイルをパース */
function parseBoM(text) {
  const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
  if (!lines.length) throw new Error("空のテキストです。");

  let latMin, latMax, latStep, nLat;
  let lonMin, lonMax, lonStep, nLon;

  for (const line of lines) {
    if (/LATITUDE GRID/i.test(line)) {
      const m = line.match(/LATITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
      if (m) {
        latMin = parseFloat(m[1]);
        latMax = parseFloat(m[2]);
        latStep = parseFloat(m[3]);
        nLat = parseInt(m[4],10);
      }
    } else if (/LONGITUDE GRID/i.test(line)) {
      const m = line.match(/LONGITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
      if (m) {
        lonMin = parseFloat(m[1]);
        lonMax = parseFloat(m[2]);
        lonStep = parseFloat(m[3]);
        nLon = parseInt(m[4],10);
      }
    }
  }
  if (latMin === undefined || lonMin === undefined) {
    throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません。");
  }

  // 値行だけ抽出（#で始まらない行）
  const valLines = lines.filter(l => !l.trim().startsWith("#"));
  const values = [];
  for (const ln of valLines) {
    const parts = ln.split(/[, ]+/).map(x => x.trim()).filter(x => x.length>0);
    for (const p of parts) {
      const v = parseFloat(p);
      if (!isNaN(v)) values.push(v);
    }
  }
  if (values.length !== nLat*nLon) {
    throw new Error(`データ数が不一致です: ${values.length} vs nLat*nLon=${nLat*nLon}`);
  }

  const latArr = [];
  for (let i=0;i<nLat;i++) {
    latArr.push(latMin + latStep*i);
  }
  const lonArr = [];
  for (let j=0;j<nLon;j++) {
    lonArr.push(lonMin + lonStep*j);
  }
  const grid = new Array(nLat);
  let idx = 0;
  for (let i=0;i<nLat;i++) {
    grid[i] = new Array(nLon);
    for (let j=0;j<nLon;j++) {
      grid[i][j] = values[idx++];
    }
  }
  const validTime = parseBomValidTime(text);
  return { latArr, lonArr, nLat, nLon, grid, validTime };
}

/* =========================
   太陽位置（簡易）: cosχ
   ========================= */
function dayOfYearUTC(date) {
  const start = new Date(Date.UTC(date.getUTCFullYear(),0,1,0,0,0));
  const diff = (date - start) / 86400000;
  return 1 + diff;
}
function solarDeclinationRad(date) {
  // 簡易: δ ≈ 23.44° * sin(2π*(N-80)/365)
  const N = dayOfYearUTC(date);
  const rad = Math.PI/180;
  return 23.44*rad * Math.sin(2*Math.PI*(N-80)/365.0);
}
function subsolarLongitudeDeg(date) {
  // 簡易: 正午に 0°、UTに応じて 15°/h ずらす
  const utH = date.getUTCHours() + date.getUTCMinutes()/60 + date.getUTCSeconds()/3600;
  let lon = - (utH - 12)*15; // 正午で0°, 0UTで -180°
  while (lon < -180) lon += 360;
  while (lon > 180) lon -= 360;
  return lon;
}
function cosSolarZenith(date, latDeg, lonDeg) {
  const rad = Math.PI/180;
  const phi = latDeg*rad;
  const delta = solarDeclinationRad(date);
  const lonS = subsolarLongitudeDeg(date)*rad;
  const lam = lonDeg*rad;
  const h = lam - lonS; // 簡易ローカル時角
  const coschi = Math.sin(phi)*Math.sin(delta) + Math.cos(phi)*Math.cos(delta)*Math.cos(h);
  return coschi;
}

/* =========================
   予報計算
   ========================= */
function runForecast() {
  try {
    const bomTexts = [
      document.getElementById("bomInput1").value,
      document.getElementById("bomInput2").value,
      document.getElementById("bomInput3").value,
      document.getElementById("bomInput4").value,
      document.getElementById("bomInput5").value,
      document.getElementById("bomInput6").value
    ];
    const snaps = [];
    const info = [];
    for (let i=0;i<bomTexts.length;i++) {
      const t = bomTexts[i];
      if (!t.trim()) continue;
      try {
        const b = parseBoM(t);
        b.index = i+1;
        snaps.push(b);
        info.push(`BoM #${i+1}: ${b.nLat}x${b.nLon}, VALID=${b.validTime ? b.validTime.toISOString() : "不明"}`);
      } catch(e) {
        info.push(`BoM #${i+1}: エラー → ${e.message}`);
      }
    }
    document.getElementById("bomInfo").textContent = snaps.length
      ? "読み取り成功: " + snaps.length + "枚\n" + info.join("\n")
      : "BoMが1枚も読み取れませんでした。";

    if (!snaps.length) {
      throw new Error("少なくとも BoM を1枚入力してください。");
    }

    // グリッド共通性チェック（簡易）
    const base = snaps[0];
    const { nLat, nLon, latArr, lonArr } = base;
    for (const s of snaps) {
      if (s.nLat !== nLat || s.nLon !== nLon) {
        throw new Error("BoMごとに格子サイズが異なります。");
      }
    }
    gGrid = { nLat, nLon, latArr, lonArr };

    // 時刻
    snaps.sort((a,b) => {
      const ta = a.validTime ? a.validTime.getTime() : 0;
      const tb = b.validTime ? b.validTime.getTime() : 0;
      return ta - tb;
    });
    gForecastStart = snaps[0].validTime || new Date();
    const forecastHours = 48;
    const dtMin = 15;
    const nSteps = Math.round(forecastHours*60/dtMin);

    gForecastFrames = new Array(nSteps+1);
    gForecastTimes = new Array(nSteps+1);

    // 係数設定読み込み
    const cfg = getConfigFromUI();

    // 太陽活動スケール
    const F107 = parseFloat(document.getElementById("inpF107").value) || 150;
    const Ap = parseFloat(document.getElementById("inpAp").value) || 10;
    const Dst = parseFloat(document.getElementById("inpDst").value) || -20;
    const Xray = parseFloat(document.getElementById("inpXray").value) || 1e-6;

    const Ssolar = computeSolarScale(F107, Ap, Dst, Xray, cfg);

    // Deep Flare Net 8領域からフレア係数
    const Sflare = computeFlareScale(cfg);

    // === 1. BoMスナップから T0, A を推定（各格子ごとに最小二乗） ===
    const K = snaps.length;
    const T0 = new Array(nLat);
    const Aamp = new Array(nLat);
    for (let i=0;i<nLat;i++) {
      T0[i] = new Array(nLon);
      Aamp[i] = new Array(nLon);
    }

    // 各スナップ時間の cosχ を準備: coschi[k][i][j]
    const coschi = [];
    for (let k=0;k<K;k++) {
      const snap = snaps[k];
      coschi[k] = new Array(nLat);
      const t = snap.validTime || gForecastStart;
      for (let i=0;i<nLat;i++) {
        coschi[k][i] = new Array(nLon);
        const lat = latArr[i];
        for (let j=0;j<nLon;j++) {
          const lon = lonArr[j];
          const c = cosSolarZenith(t, lat, lon);
          coschi[k][i][j] = c;
        }
      }
    }

    const pX = cfg.pX;
    for (let i=0;i<nLat;i++) {
      for (let j=0;j<nLon;j++) {
        let S_B = 0, S_Bf = 0, S_f = 0, S_f2 = 0;
        for (let k=0;k<K;k++) {
          const B = snaps[k].grid[i][j];
          const c = coschi[k][i][j];
          let f = c > 0 ? Math.pow(c, pX) : 0;
          S_B += B;
          S_f += f;
          S_f2 += f*f;
          S_Bf += B*f;
        }
        const N = K;
        const D = N*S_f2 - S_f*S_f;
        let t0, a;
        if (Math.abs(D) < 1e-6) {
          t0 = S_B / N;
          a = 0;
        } else {
          t0 = (S_B*S_f2 - S_f*S_Bf) / D;
          a  = (N*S_Bf - S_f*S_B) / D;
        }
        if (!isFinite(t0)) t0 = 0;
        if (!isFinite(a)) a = 0;
        if (t0 < 0) t0 = 0;
        T0[i][j] = t0;
        Aamp[i][j] = a;
      }
    }

    // === 2. 48時間・15分刻みで予報を生成 ===
    for (let step=0; step<=nSteps; step++) {
      const frame = new Array(nLat);
      const t = new Date(gForecastStart.getTime() + step*dtMin*60000);
      gForecastTimes[step] = t;
      const delta = solarDeclinationRad(t);
      const lonS = subsolarLongitudeDeg(t);
      const rad = Math.PI/180;
      for (let i=0;i<nLat;i++) {
        frame[i] = new Array(nLon);
        const lat = latArr[i];
        const phi = lat*rad;
        const sinphi = Math.sin(phi);
        const cosphi = Math.cos(phi);
        // 緯度補正 wLat（赤道異常と高緯度減衰）
        const wLat = computeLatWeight(lat, cfg);

        for (let j=0;j<nLon;j++) {
          const lon = lonArr[j];
          const lam = lon*rad;
          const h = (lam - lonS*rad);
          const coschi_t = sinphi*Math.sin(delta) + cosphi*Math.cos(delta)*Math.cos(h);
          const fDay = coschi_t > 0 ? Math.pow(coschi_t, cfg.pX) : 0;

          let T = T0[i][j] + Aamp[i][j]*fDay;
          if (T < 0) T = 0;

          // 太陽活動・フレア・緯度補正
          const scale = cfg.kGlobal * Ssolar * Sflare * wLat;
          frame[i][j] = T * scale;
        }
      }
      gForecastFrames[step] = fixLocalVShape(frame, nLat, nLon, 0.85);
    }

    logInfo(`予報計算完了: frames=${gForecastFrames.length}, grid=${nLat}x${nLon}`);
    const slider = document.getElementById("timeSlider");
    slider.min = 0;
    slider.max = nSteps;
    slider.value = 0;
    updateTimeLabel();
    drawTecMap();
  } catch(e) {
    logInfo("エラー: " + e.message);
    console.error(e);
  }
}

/* 太陽活動スケール（かなり簡易） */
function computeSolarScale(F107, Ap, Dst, Xray, cfg) {
  const F0 = 100;
  const dF = (F107 - F0);
  let S = 1.0 + cfg.wF107 * dF;
  S += cfg.wAp * (Ap - 10);
  S += cfg.wDst * Dst; // Dst<0 で減衰・増加どちらかはチューニング

  // X-rayをログスケールで弱く反映
  if (Xray > 0) {
    const X0 = 1e-7;
    const lx = Math.log10(Xray / X0);
    S += 0.05*lx;
  }
  if (S < 0.2) S = 0.2;
  if (S > 3.0) S = 3.0;
  return S;
}

/* 緯度補正: 赤道異常＋高緯度減衰 */
function computeLatWeight(latDeg, cfg) {
  const x = Math.abs(latDeg)/40; // ±40付近にピーク
  let w = 1 + cfg.latShape * (1 - (x-1)*(x-1)); // 赤道異常イメージ
  if (w < 0.3) w = 0.3;

  if (Math.abs(latDeg) > 60) {
    const f = (Math.abs(latDeg)-60)/30; // 60〜90
    const gh = cfg.latHighCut;
    w *= (1 - f*(1-gh)); // 60で1、90でgh
  }
  return w;
}

/* ローカルなV字谷補正 */
function fixLocalVShape(frame, nLat, nLon, threshold) {
  const out = new Array(nLat);
  for (let i=0;i<nLat;i++) {
    out[i] = new Array(nLon);
    for (let j=0;j<nLon;j++) {
      const T0 = frame[i][j];
      if (!isFinite(T0)) {
        out[i][j] = T0;
        continue;
      }
      let sum=0, cnt=0;
      for (let di=-1;di<=1;di++) {
        for (let dj=-1;dj<=1;dj++) {
          if (di===0 && dj===0) continue;
          const ii = i+di;
          const jj = (j+dj + nLon)%nLon;
          if (ii<0 || ii>=nLat) continue;
          const Tv = frame[ii][jj];
          if (!isFinite(Tv)) continue;
          sum += Tv;
          cnt++;
        }
      }
      if (cnt===0) {
        out[i][j]=T0;
        continue;
      }
      const neigh = sum/cnt;
      if (T0 < threshold*neigh) {
        const alpha = 0.7;
        out[i][j] = T0*(1-alpha)+neigh*alpha;
      } else {
        out[i][j]=T0;
      }
    }
  }
  return out;
}

/* Deep Flare Net 8領域 → global flare scale */
function computeFlareScale(cfg) {
  let I = 0;
  for (let r=1;r<=8;r++) {
    const use = document.getElementById("fu"+r).checked;
    if (!use) continue;
    const Px = parseFloat(document.getElementById("fx"+r).value) || 0;
    const Pm = parseFloat(document.getElementById("fm"+r).value) || 0;
    const Fx = cfg.kX * (Px/100);
    const Fm = cfg.kM * (Pm/100);
    // 簡易な visibility 重み: 中心(R8)=1, 他は0.6
    const wVis = (r===8) ? 1.0 : 0.6;
    I += (Fx + Fm) * wVis;
  }
  const S = 1 + cfg.betaFlare * I;
  return clamp(S, 0.5, 3.0);
}

/* =========================
   設定のロード/セーブ
   ========================= */
function getConfigFromUI() {
  const cfg = {
    kGlobal: parseFloat(document.getElementById("cfg_kGlobal").value) || 1.0,
    wF107: parseFloat(document.getElementById("cfg_wF107").value) || 0.004,
    wAp: parseFloat(document.getElementById("cfg_wAp").value) || 0.01,
    wDst: parseFloat(document.getElementById("cfg_wDst").value) || -0.002,
    pX: parseFloat(document.getElementById("cfg_pX").value) || 1.5,
    latShape: parseFloat(document.getElementById("cfg_latShape").value) || 0.4,
    latHighCut: parseFloat(document.getElementById("cfg_latHighCut").value) || 0.5,
    betaFlare: parseFloat(document.getElementById("cfg_betaFlare").value) || 0.5,
    kX: parseFloat(document.getElementById("cfg_kX").value) || 1.0,
    kM: parseFloat(document.getElementById("cfg_kM").value) || 0.3,
    biasThresh: parseFloat(document.getElementById("cfg_biasThresh").value) || 15,
    suggestGain: parseFloat(document.getElementById("cfg_suggestGain").value) || 0.5
  };
  return cfg;
}
function setConfigToUI(cfg) {
  document.getElementById("cfg_kGlobal").value = cfg.kGlobal;
  document.getElementById("cfg_wF107").value = cfg.wF107;
  document.getElementById("cfg_wAp").value = cfg.wAp;
  document.getElementById("cfg_wDst").value = cfg.wDst;
  document.getElementById("cfg_pX").value = cfg.pX;
  document.getElementById("cfg_latShape").value = cfg.latShape;
  document.getElementById("cfg_latHighCut").value = cfg.latHighCut;
  document.getElementById("cfg_betaFlare").value = cfg.betaFlare;
  document.getElementById("cfg_kX").value = cfg.kX;
  document.getElementById("cfg_kM").value = cfg.kM;
  document.getElementById("cfg_biasThresh").value = cfg.biasThresh;
  document.getElementById("cfg_suggestGain").value = cfg.suggestGain;
}
function saveConfig() {
  const cfg = getConfigFromUI();
  localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(cfg));
  logInfo("係数設定を保存しました。");
}
function loadConfig(fromStoredOnly=false) {
  const s = localStorage.getItem(STORAGE_KEY_CONFIG);
  if (s) {
    try {
      const cfg = JSON.parse(s);
      setConfigToUI(cfg);
      if (fromStoredOnly) logInfo("保存されていた係数設定を再読込しました。");
    } catch(e) {
      console.warn(e);
    }
  } else if (fromStoredOnly) {
    logInfo("保存された設定がありません。デフォルト値を使用します。");
  }
}

/* =========================
   TEC マップ描画
   ========================= */
function getTecCanvasSize() {
  const canvas = document.getElementById("tecCanvas");
  const parent = canvas.parentElement;
  const w = parent.clientWidth * 0.75;
  const h = parent.clientHeight-4;
  return {w, h};
}
function resizeCanvases() {
  const tecCanvas = document.getElementById("tecCanvas");
  const verifyCanvas = document.getElementById("verifyCanvas");
  const sz = getTecCanvasSize();
  tecCanvas.width = sz.w;
  tecCanvas.height = sz.h;

  const pv = verifyCanvas.parentElement;
  const vh = pv.clientHeight-4;
  verifyCanvas.width = 200;
  verifyCanvas.height = vh;
}
window.addEventListener("resize", () => {
  resizeCanvases();
  drawTecMap();
  drawVerifyMap();
});

function onSliderChange() {
  updateTimeLabel();
  drawTecMap();
}

function updateTimeLabel() {
  const slider = document.getElementById("timeSlider");
  const idx = parseInt(slider.value,10);
  const hours = idx*15/60;
  let label = `t=${hours.toFixed(2)}h`;
  if (gForecastTimes && gForecastTimes[idx]) {
    const t = gForecastTimes[idx];
    label += ` (UTC ${t.toISOString().replace('T',' ').substring(0,16)})`;
  }
  document.getElementById("timeLabel").textContent = label;
}

/* TEC カラースケール（固定: 0〜120 TECU） */
function tecColor(val) {
  const vmax = 120;
  const v = clamp(val, 0, vmax)/vmax;
  // 0-0.4: green系, 0.4-0.55: white, 0.55-0.7: yellow, 0.7-1: orange→red
  let r=0,g=0,b=0;
  if (v<=0.4) {
    // dark green → bright green
    const t = v/0.4;
    r = 0;
    g = 60 + 195*t;
    b = 0;
  } else if (v<=0.55) {
    const t = (v-0.4)/0.15;
    r = 200 + 55*t;
    g = 200 + 55*t;
    b = 200 + 55*t;
  } else if (v<=0.7) {
    const t = (v-0.55)/0.15;
    r = 255;
    g = 255;
    b = 255*(1-t);
  } else {
    const t = (v-0.7)/0.3;
    r = 255;
    g = 200*(1-t);
    b = 0;
  }
  return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
}

function drawTecMap() {
  const canvas = document.getElementById("tecCanvas");
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#000000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  if (!gForecastFrames.length || !gGrid) return;
  const slider = document.getElementById("timeSlider");
  const idx = parseInt(slider.value,10);
  const frame = gForecastFrames[idx];
  const {nLat, nLon, latArr, lonArr} = gGrid;

  // 背景画像
  if (gBgImage) {
    const alpha = parseFloat(document.getElementById("bgAlpha").value) || 0.4;
    const scale = parseFloat(document.getElementById("bgScale").value) || 1.0;
    const iw = gBgImage.width*scale;
    const ih = gBgImage.height*scale;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.drawImage(gBgImage,
      (canvas.width - iw)/2,
      (canvas.height - ih)/2,
      iw, ih);
    ctx.restore();
  }

  // グリッド描画
  const padL = 40, padR = 30, padT = 20, padB = 20;
  const plotW = canvas.width - padL - padR;
  const plotH = canvas.height - padT - padB;
  const cellW = plotW / nLon;
  const cellH = plotH / nLat;

  // TEC min/max for scaling legend
  let minT = Infinity, maxT = -Infinity;
  for (let i=0;i<nLat;i++) {
    for (let j=0;j<nLon;j++) {
      const v = frame[i][j];
      if (!isFinite(v)) continue;
      if (v<minT) minT=v;
      if (v>maxT) maxT=v;
    }
  }

  for (let i=0;i<nLat;i++) {
    for (let j=0;j<nLon;j++) {
      const v = frame[i][j];
      if (!isFinite(v)) continue;
      const col = tecColor(v);
      ctx.fillStyle = col;
      const x = padL + j*cellW;
      const y = padT + (nLat-1-i)*cellH; // lat -90 bottom, +90 top
      ctx.fillRect(x, y, cellW+0.5, cellH+0.5);
    }
  }

  // 緯度経度ラベル（5度刻み）
  ctx.strokeStyle = "rgba(255,255,255,0.15)";
  ctx.lineWidth = 1;
  ctx.font = "10px system-ui";
  ctx.fillStyle = "#e5e7eb";

  for (let lon=-180; lon<=180; lon+=30) {
    const j = (lon - lonArr[0]) / (lonArr[1]-lonArr[0]);
    if (j < 0 || j > nLon-1) continue;
    const x = padL + j*cellW;
    ctx.beginPath();
    ctx.moveTo(x, padT);
    ctx.lineTo(x, padT+plotH);
    ctx.stroke();
    ctx.fillText(`${lon}°`, x-10, padT+plotH+12);
  }
  for (let lat=-60; lat<=60; lat+=30) {
    const i = (lat - latArr[0]) / (latArr[1]-latArr[0]);
    if (i < 0 || i > nLat-1) continue;
    const y = padT + (nLat-1-i)*cellH;
    ctx.beginPath();
    ctx.moveTo(padL, y);
    ctx.lineTo(padL+plotW, y);
    ctx.stroke();
    ctx.fillText(`${lat}°`, 4, y+3);
  }

  // カラーバー
  const barX = canvas.width - 24;
  const barY = padT;
  const barH = plotH;
  const barW = 12;
  for (let k=0;k<barH;k++) {
    const vv = (barH-1-k)/barH * 120;
    ctx.fillStyle = tecColor(vv);
    ctx.fillRect(barX, barY+k, barW, 1);
  }
  ctx.strokeStyle = "#e5e7eb";
  ctx.strokeRect(barX, barY, barW, barH);
  ctx.font = "9px system-ui";
  ctx.fillStyle = "#e5e7eb";
  ctx.fillText("TECU", barX-4, barY-4);
  ctx.fillText("0", barX+barW+2, barY+barH);
  ctx.fillText("120", barX+barW+2, barY+8);

  // クリックで格子点情報
  canvas.onclick = function(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left;
    const y = ev.clientY - rect.top;
    if (x<padL || x>padL+plotW || y<padT || y>padT+plotH) return;
    const j = Math.floor((x-padL)/cellW);
    const iInv = Math.floor((y-padT)/cellH);
    const i = nLat-1 - iInv;
    const lat = latArr[i];
    const lon = lonArr[j];
    const v = frame[i][j];
    const t = gForecastTimes[parseInt(document.getElementById("timeSlider").value,10)];
    const info = `lat=${lat.toFixed(1)}°, lon=${lon.toFixed(1)}°\n` +
                 `TEC ≈ ${v.toFixed(2)} TECU\n` +
                 `t(UTC) = ${t.toISOString()}`;
    document.getElementById("pointInfo").textContent = info;
  };
}

/* =========================
   背景画像読み込み
   ========================= */
document.getElementById("bgFile").addEventListener("change", (ev) => {
  const file = ev.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(e) {
    const img = new Image();
    img.onload = function() {
      gBgImage = img;
      drawTecMap();
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
});

/* =========================
   検証: 9分割誤差マップ
   ========================= */
function runVerification() {
  if (!gForecastFrames.length || !gGrid) {
    logInfo("先にTEC予報を計算してください。");
    return;
  }
  try {
    const texts = [
      document.getElementById("verifyInput1").value,
      document.getElementById("verifyInput2").value,
      document.getElementById("verifyInput3").value,
      document.getElementById("verifyInput4").value
    ];
    const snaps = [];
    for (let i=0;i<texts.length;i++) {
      const t = texts[i];
      if (!t.trim()) continue;
      try {
        const b = parseBoM(t);
        b.index = i+1;
        snaps.push(b);
      } catch(e) {
        console.warn("Verify BoM error:", e);
      }
    }
    if (!snaps.length) {
      logInfo("検証用BoMが読み取れませんでした。");
      return;
    }
    snaps.sort((a,b)=> (a.validTime||0) - (b.validTime||0));

    const {nLat, nLon, latArr, lonArr} = gGrid;

    // 9領域集計
    const sumAbs = Array(9).fill(0);
    const sumRef = Array(9).fill(0);
    const sumBias = Array(9).fill(0);
    const count = Array(9).fill(0);

    let sumAbsAll=0, sumRefAll=0, sumBiasAll=0, countAll=0;

    // カテゴリバイアス
    let sumBiasLowDay=0, sumRefLowDay=0, cntLowDay=0;
    let sumBiasHigh=0, sumRefHigh=0, cntHigh=0;

    const cfg = getConfigFromUI();
    const rad = Math.PI/180;

    for (let k=0;k<gForecastFrames.length;k++) {
      const t = gForecastTimes[k];
      // 一番近い verify snap を探す
      let best=null, bestDt=1e15;
      for (const s of snaps) {
        if (!s.validTime) continue;
        const dt = Math.abs(s.validTime - t);
        if (dt<bestDt) {
          bestDt = dt;
          best = s;
        }
      }
      if (!best) continue;
      // 2時間以上離れていたらスキップ（適宜調整）
      if (bestDt > 2*3600*1000) continue;

      const frame = gForecastFrames[k];
      const Bgrid = best.grid;
      const delta = solarDeclinationRad(t);
      const lonS = subsolarLongitudeDeg(t)*rad;

      for (let i=0;i<nLat;i++) {
        const lat = latArr[i];
        const phi = lat*rad;
        const sinphi = Math.sin(phi);
        const cosphi = Math.cos(phi);
        for (let j=0;j<nLon;j++) {
          const F = frame[i][j];
          const B = Bgrid[i][j];
          if (!isFinite(F) || !isFinite(B) || B<=0) continue;

          const absE = Math.abs(F-B);
          const bias = F-B;
          sumAbsAll += absE;
          sumRefAll += B;
          sumBiasAll += bias;
          countAll++;

          // 9領域index
          const latBand = (lat>=30) ? 0 : (lat<=-30 ? 2 : 1);
          const lonDeg = lonArr[j];
          let lonBand;
          if (lonDeg < -60) lonBand = 0;
          else if (lonDeg <= 60) lonBand = 1;
          else lonBand = 2;
          const idx = latBand*3 + lonBand;

          sumAbs[idx] += absE;
          sumRef[idx] += B;
          sumBias[idx] += bias;
          count[idx]++;

          // 日中/夜間分類
          const lam = lonDeg*rad;
          const h = lam - lonS;
          const coschi_t = sinphi*Math.sin(delta) + cosphi*Math.cos(delta)*Math.cos(h);

          if (Math.abs(lat) < 30 && coschi_t > 0.3) {
            sumBiasLowDay += bias;
            sumRefLowDay += B;
            cntLowDay++;
          }
          if (Math.abs(lat) > 60) {
            sumBiasHigh += bias;
            sumRefHigh += B;
            cntHigh++;
          }
        }
      }
    }

    const mapeAll = sumRefAll>0 ? (sumAbsAll/sumRefAll*100) : 0;
    const biasAll = sumRefAll>0 ? (sumBiasAll/sumRefAll*100) : 0;

    const errPct = [];
    const biasPct = [];
    for (let r=0;r<9;r++) {
      errPct[r] = sumRef[r]>0 ? (sumAbs[r]/sumRef[r]*100) : 0;
      biasPct[r] = sumRef[r]>0 ? (sumBias[r]/sumRef[r]*100) : 0;
    }

    // 9マスマップを描画
    drawVerifyMap(errPct, biasPct);

    // 係数提案
    const lines = [];
    lines.push(`Global: MAPE=${mapeAll.toFixed(1)}%, Bias=${biasAll.toFixed(1)}%`);

    const cfgBiasTh = cfg.biasThresh;
    const gGain = cfg.suggestGain;

    if (Math.abs(biasAll) >= cfgBiasTh) {
      const sign = biasAll>0 ? "過大評価" : "過小評価";
      const factor = 1 - gGain*(biasAll/100);
      lines.push(`→ 全体的に ${sign} 気味です。kGlobal を約 ${factor.toFixed(2)} 倍にすることを提案します。`);
    }

    if (sumRefLowDay>0) {
      const bLD = sumBiasLowDay/sumRefLowDay*100;
      lines.push(`Low-lat Daytime Bias = ${bLD.toFixed(1)}%`);
      if (Math.abs(bLD) >= cfgBiasTh) {
        const sign = bLD>0 ? "昼側だけ高め" : "昼側だけ低め";
        const factor = 1 - gGain*(bLD/100);
        lines.push(`→ 低緯度日中で ${sign} です。pX（日中指数）や F10.7係数を ${factor.toFixed(2)} 倍方向で調整するとよさそうです。`);
      }
    }

    if (sumRefHigh>0) {
      const bH = sumBiasHigh/sumRefHigh*100;
      lines.push(`High-lat Bias = ${bH.toFixed(1)}%`);
      if (Math.abs(bH) >= cfgBiasTh) {
        const sign = bH>0 ? "高緯度のTECが高め" : "高緯度のTECが低め";
        const factor = 1 - gGain*(bH/100);
        lines.push(`→ ${sign} です。latHighCut を ${factor.toFixed(2)} 倍方向で調整するとよさそうです。`);
      }
    }

    const report = [];
    report.push("=== 9領域 MAPE / Bias ===");
    const names = [
      "R1 北高緯度・西","R2 北高緯度・中","R3 北高緯度・東",
      "R4 中緯度・西","R5 中緯度・中","R6 中緯度・東",
      "R7 南高緯度・西","R8 南高緯度・中","R9 南高緯度・東"
    ];
    for (let r=0;r<9;r++) {
      report.push(`${names[r]}: MAPE=${errPct[r].toFixed(1)}%, Bias=${biasPct[r].toFixed(1)}% (N=${count[r]})`);
    }
    report.push("");
    report.push("=== 係数調整のヒント ===");
    report.push(...lines);

    document.getElementById("verifyReport").textContent = report.join("\n");
    logInfo("検証完了。");

  } catch(e) {
    logInfo("検証中にエラー: " + e.message);
    console.error(e);
  }
}

function clearVerification() {
  document.getElementById("verifyReport").textContent = "(まだ検証されていません)";
  const canvas = document.getElementById("verifyCanvas");
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

/* 検証マップ描画 */
function drawVerifyMap(errPct=null, biasPct=null) {
  const canvas = document.getElementById("verifyCanvas");
  const ctx = canvas.getContext("2d");
  ctx.fillStyle = "#000";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const w = canvas.width;
  const h = canvas.height;
  const pad = 10;
  const gridW = w - pad*2;
  const gridH = h - pad*2 - 20;
  const cellW = gridW/3;
  const cellH = gridH/3;

  // 枠とラベル
  ctx.strokeStyle = "#9ca3af";
  ctx.lineWidth = 1;
  ctx.strokeRect(pad, pad, gridW, gridH);
  ctx.font = "10px system-ui";
  ctx.fillStyle = "#e5e7eb";
  ctx.fillText("誤差9分割", pad, h-6);

  if (!errPct || !biasPct) return;

  function colorForErr(v) {
    for (const band of gVerifyColorScale) {
      if (v <= band.limit) return band.color;
    }
    return "#ffffff";
  }

  const namesShort = ["R1","R2","R3","R4","R5","R6","R7","R8","R9"];

  let idx=0;
  for (let row=0; row<3; row++) {
    for (let col=0; col<3; col++) {
      const x = pad + col*cellW;
      const y = pad + row*cellH;
      const e = errPct[idx];
      const b = biasPct[idx];
      ctx.fillStyle = colorForErr(e);
      ctx.fillRect(x+1,y+1,cellW-2,cellH-2);
      ctx.strokeStyle = "#111827";
      ctx.strokeRect(x+1,y+1,cellW-2,cellH-2);

      ctx.fillStyle = "#000000";
      ctx.globalAlpha = 0.7;
      ctx.fillRect(x+1,y+1,32,14);
      ctx.globalAlpha = 1.0;

      ctx.fillStyle = "#e5e7eb";
      ctx.fillText(namesShort[idx], x+4, y+12);
      ctx.fillText(`${e.toFixed(0)}%`, x+4, y+25);
      ctx.fillText(`B=${b.toFixed(0)}%`, x+4, y+38);
      idx++;
    }
  }
}

/* 検証色スケール適用・保存 */
function applyVerifyColorScale() {
  const limits = [
    parseFloat(document.getElementById("vLimit1").value)||10,
    parseFloat(document.getElementById("vLimit2").value)||20,
    parseFloat(document.getElementById("vLimit3").value)||30,
    parseFloat(document.getElementById("vLimit4").value)||999
  ];
  const colors = [
    document.getElementById("vColor1").value,
    document.getElementById("vColor2").value,
    document.getElementById("vColor3").value,
    document.getElementById("vColor4").value
  ];
  gVerifyColorScale = [];
  for (let i=0;i<4;i++) {
    gVerifyColorScale.push({limit: limits[i], color: colors[i]});
  }
  localStorage.setItem(STORAGE_KEY_VCOL, JSON.stringify(gVerifyColorScale));
  drawVerifyMap([0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]); // 軽く再描画
}
function resetVerifyColorScale() {
  gVerifyColorScale = [
    { limit: 10,  color: "#00ff00" },
    { limit: 20,  color: "#ffff00" },
    { limit: 30,  color: "#ff9900" },
    { limit: 999, color: "#ff0000" }
  ];
  document.getElementById("vLimit1").value = 10;
  document.getElementById("vLimit2").value = 20;
  document.getElementById("vLimit3").value = 30;
  document.getElementById("vLimit4").value = 999;
  document.getElementById("vColor1").value = "#00ff00";
  document.getElementById("vColor2").value = "#ffff00";
  document.getElementById("vColor3").value = "#ff9900";
  document.getElementById("vColor4").value = "#ff0000";
  localStorage.removeItem(STORAGE_KEY_VCOL);
  drawVerifyMap();
}

/* =========================
   リセットなど
   ========================= */
function resetAll() {
  gGrid = null;
  gForecastFrames = [];
  gForecastTimes = [];
  gForecastStart = null;
  clearVerification();
  logInfo("内部状態をリセットしました。BoMを入れ直して下さい。");
}

/* =========================
   初期化
   ========================= */
window.addEventListener("load", () => {
  resizeCanvases();
  loadConfig(false);
  const s = localStorage.getItem(STORAGE_KEY_VCOL);
  if (s) {
    try {
      gVerifyColorScale = JSON.parse(s);
      document.getElementById("vLimit1").value = gVerifyColorScale[0].limit;
      document.getElementById("vLimit2").value = gVerifyColorScale[1].limit;
      document.getElementById("vLimit3").value = gVerifyColorScale[2].limit;
      document.getElementById("vLimit4").value = gVerifyColorScale[3].limit;
      document.getElementById("vColor1").value = gVerifyColorScale[0].color;
      document.getElementById("vColor2").value = gVerifyColorScale[1].color;
      document.getElementById("vColor3").value = gVerifyColorScale[2].color;
      document.getElementById("vColor4").value = gVerifyColorScale[3].color;
    } catch(e) {
      console.warn(e);
    }
  }
  drawTecMap();
  drawVerifyMap();
});
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>SWIFT-TEC v4 (Leaflet版)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- 自作CSS -->
  <link rel="stylesheet" href="style.css" />
</head>

<body>
<div class="page">

  <!-- ========================== 左パネル ========================== -->
  <div class="sidebar">
    <h2>SWIFT-TEC v4</h2>

    <!-- BoM入力 -->
    <div class="card">
      <h3>1. BoM TEC 貼り付け</h3>
      <textarea id="bomInput" placeholder="BoMのTECをここに貼り付け"></textarea>
      <button onclick="loadBom()">BoM 読み込み</button>
    </div>

    <!-- 予報設定 -->
    <div class="card">
      <h3>2. 予報パラメータ</h3>
      <label>F10.7:</label>
      <input id="f107" type="number" value="150">
      <label>フレア係数:</label>
      <input id="flareK" type="number" value="1.0" step="0.1">

      <button onclick="computeForecast()">予報生成</button>
    </div>

    <!-- バイアス補正（3×3領域） -->
    <div class="card">
      <h3>3. 9領域バイアス補正</h3>

      <table class="biasTable">
        <tr><th></th><th>W</th><th>C</th><th>E</th></tr>

        <tr>
          <th>N</th>
          <td><input id="biasNW" type="number" step="0.1" value="0"></td>
          <td><input id="biasN" type="number" step="0.1" value="0"></td>
          <td><input id="biasNE" type="number" step="0.1" value="0"></td>
        </tr>

        <tr>
          <th>M</th>
          <td><input id="biasW" type="number" step="0.1" value="0"></td>
          <td><input id="biasC" type="number" step="0.1" value="0"></td>
          <td><input id="biasE" type="number" step="0.1" value="0"></td>
        </tr>

        <tr>
          <th>S</th>
          <td><input id="biasSW" type="number" step="0.1" value="0"></td>
          <td><input id="biasS" type="number" step="0.1" value="0"></td>
          <td><input id="biasSE" type="number" step="0.1" value="0"></td>
        </tr>
      </table>
    </div>

    <!-- 時間スライダー -->
    <div class="card">
      <h3>4. 時間スライダー</h3>
      <input id="timeSlider" type="range" min="0" max="192" value="0"
             oninput="updateTime()">
      <div id="timeLabel">t = 0.0h</div>
    </div>

    <!-- 出力ログ -->
    <div class="card">
      <h3>ログ</h3>
      <pre id="logArea"></pre>
    </div>
  </div>

  <!-- ========================== 右パネル ========================== -->
  <div class="main">
    <div id="mapContainer">
      <div id="map"></div>
      <canvas id="tecCanvas"></canvas>
    </div>

    <div class="card">
      <h3>クリック地点の情報</h3>
      <pre id="clickInfo">マップをクリックしてください</pre>
    </div>
  </div>

</div>

<!-- JSファイル読込 -->
<script src="script-core.js"></script>
<script src="script-map.js"></script>

</body>
</html>
/* ================================
   全体レイアウト
================================ */

body {
  margin: 0;
  padding: 0;
  background: #0f1525;
  color: #e8ecf7;
  font-family: "Segoe UI", sans-serif;
  overflow: hidden;
}

.page {
  display: flex;
  height: 100vh;
}

/* ================================
   左パネル（スクロール）
================================ */

.sidebar {
  width: 330px;
  background: #131b30;
  padding: 12px;
  box-sizing: border-box;
  overflow-y: auto;
  border-right: 2px solid #222b3f;
}

.sidebar h2 {
  margin-top: 0;
  font-size: 20px;
  color: #89b4ff;
  text-align: center;
}

/* カード */
.card {
  background: #1a233a;
  padding: 12px;
  margin-bottom: 16px;
  border-radius: 8px;
  border: 1px solid #2c3755;
}

.card h3 {
  margin-top: 0;
  margin-bottom: 8px;
  font-size: 16px;
  color: #aac7ff;
}

/* ================================
   入力 UI
================================ */

textarea {
  width: 100%;
  height: 120px;
  background: #0d1424;
  color: #e8ecf7;
  border-radius: 6px;
  border: 1px solid #34446b;
  padding: 8px;
  resize: vertical;
}

input[type="number"],
input[type="text"] {
  width: 90px;
  padding: 6px;
  border-radius: 6px;
  background: #0d1424;
  border: 1px solid #34446b;
  color: #e8ecf7;
  margin-bottom: 6px;
}

button {
  margin-top: 8px;
  padding: 8px 12px;
  background: #3759ff;
  border: none;
  border-radius: 6px;
  color: white;
  font-weight: bold;
  cursor: pointer;
}

button:hover {
  background: #1f3ff0;
}

/* ================================
   バイアス補正 (3×3)
================================ */

.biasTable {
  width: 100%;
  text-align: center;
  border-collapse: collapse;
}

.biasTable th {
  color: #aac7ff;
  padding: 4px;
}

.biasTable td {
  padding: 4px;
}

.biasTable input {
  width: 70px;
  text-align: right;
}

/* ================================
   メイン（右側）
================================ */

.main {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  padding: 6px;
}

/* ================================
   Leaflet 地図領域
================================ */

#mapContainer {
  flex: 1;
  position: relative;
  border-radius: 8px;
  border: 2px solid #2c3755;
  overflow: hidden;
  min-height: 400px;
}

#map {
  width: 100%;
  height: 100%;
}

#tecCanvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;   /* マップ操作を妨げない */
}

/* ================================
   ログ／クリック情報
================================ */

pre {
  background: #0d1424;
  padding: 10px;
  border-radius: 6px;
  border: 1px solid #34446b;
  max-height: 200px;
  overflow-y: auto;
  white-space: pre-wrap;
}
/* ============================================================
   SWIFT-TEC v4  (core logic)
   - BoM parsing
   - Forecast model
   - Bias correction (3×3)
   - TEC → Leaflet heatmap projection
   ============================================================ */

/* -------------------------------
   グローバル変数
-------------------------------- */
let gGrid = null;
let gForecastFrames = [];
let gForecastTimes = [];
let gForecastStart = null;

// 3×3 バイアス補正テーブル
// 全領域 1.0（=補正なし）
let gBiasMatrix = [
  [1.0, 1.0, 1.0],   // 南（lat -90〜-30）
  [1.0, 1.0, 1.0],   // 中緯度（lat -30〜30）
  [1.0, 1.0, 1.0]    // 北（lat 30〜90）
];

// Leaflet に描画するための Canvas
let tecCanvas, tecCtx;

/* ============================================================
   1. BoM テキスト → TEC グリッド解析
   ============================================================ */

function parseBoM(text) {
  const lines = text.split(/\r?\n/).filter(x => x.trim().length > 0);

  let latMin, latMax, latStep, nLat;
  let lonMin, lonMax, lonStep, nLon;
  let validTime = null;

  for (const L of lines) {
    if (/LATITUDE GRID/i.test(L)) {
      const m = L.match(/:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/);
      latMin = parseFloat(m[1]);
      latMax = parseFloat(m[2]);
      latStep = parseFloat(m[3]);
      nLat   = parseInt(m[4]);
    }
    if (/LONGITUDE GRID/i.test(L)) {
      const m = L.match(/:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/);
      lonMin = parseFloat(m[1]);
      lonMax = parseFloat(m[2]);
      lonStep = parseFloat(m[3]);
      nLon   = parseInt(m[4]);
    }
    if (/VALID DATE\/TIME/i.test(L)) {
      const m = L.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d\d):(\d\d):(\d\d)/);
      validTime = new Date(Date.UTC(m[3], m[2] - 1, m[1], m[4], m[5], m[6]));
    }
  }

  if (!nLat || !nLon) {
    throw new Error("緯度 / 経度 グリッド情報が見つかりません");
  }

  // 数値行だけ抽出（# と GRID 行を除外）
  const valLines = lines.filter(L => !L.startsWith("#") && !/GRID/.test(L));

  const nums = [];
  for (const row of valLines) {
    const parts = row.split(/[, ]+/).filter(x => x.trim().length > 0);
    for (const p of parts) {
      const v = parseFloat(p);
      if (!isNaN(v)) nums.push(v);
    }
  }

  if (nums.length !== nLat * nLon) {
    throw new Error(`データ数不一致: ${nums.length} != ${nLat * nLon}`);
  }

  // 緯度配列（南→北）
  const latArr = [];
  for (let i = 0; i < nLat; i++) latArr.push(latMin + latStep * i);

  // 経度配列（-180 → 180）
  const lonArr = [];
  for (let j = 0; j < nLon; j++) lonArr.push(lonMin + lonStep * j);

  // 2D グリッド化
  const grid = [];
  let k = 0;
  for (let i = 0; i < nLat; i++) {
    grid[i] = [];
    for (let j = 0; j < nLon; j++) {
      grid[i][j] = nums[k++];
    }
  }

  return { latArr, lonArr, nLat, nLon, grid, validTime };
}


/* ============================================================
   2. 太陽位置モデル（簡易 IRI 風）
   ============================================================ */

function dayOfYearUTC(date) {
  const start = new Date(Date.UTC(date.getUTCFullYear(), 0, 1));
  return 1 + (date - start) / 86400000;
}

function solarDeclinationRad(date) {
  const N = dayOfYearUTC(date);
  return 23.44 * Math.PI/180 * Math.sin(2 * Math.PI * (N - 80) / 365);
}

function subsolarLongitudeDeg(date) {
  const UT = date.getUTCHours() + date.getUTCMinutes()/60;
  let lon = -(UT - 12) * 15;
  if (lon < -180) lon += 360;
  if (lon > 180) lon -= 360;
  return lon;
}


/* ============================================================
   3. 予報モデル（簡略版 IRI × Solar × Flare）
   ============================================================ */

function computeForecast(snaps, cfg) {
  const base = snaps[0];

  const { nLat, nLon, latArr, lonArr } = base;
  gGrid = { nLat, nLon, latArr, lonArr };

  snaps.sort((a, b) => a.validTime - b.validTime);
  gForecastStart = snaps[0].validTime;

  const pX = cfg.pX;

  /* ---- A(t)・T0 回帰フィット ---- */
  const T0 = [];     // 夜間 TEC
  const Aamp = [];   // 日中変動量

  for (let i = 0; i < nLat; i++) {
    T0[i] = [];
    Aamp[i] = [];
    for (let j = 0; j < nLon; j++) {

      let S_B = 0, S_f = 0, S_f2 = 0, S_Bf = 0;

      for (const s of snaps) {
        const date = s.validTime;
        const delta = solarDeclinationRad(date);
        const lonS = subsolarLongitudeDeg(date);

        const phi = latArr[i] * Math.PI/180;
        const lam = lonArr[j] * Math.PI/180;
        const h = lam - lonS * Math.PI/180;

        const c = Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(h);
        const f = Math.max(0, Math.pow(Math.max(0, c), pX));

        const B = s.grid[i][j];

        S_B += B;
        S_f += f;
        S_f2 += f*f;
        S_Bf += B*f;
      }

      const N = snaps.length;
      const D = N*S_f2 - S_f*S_f;

      let t0, aAmp;
      if (Math.abs(D) < 1e-8) {
        t0 = S_B / N;
        aAmp = 0;
      } else {
        t0 = (S_B * S_f2 - S_f * S_Bf) / D;
        aAmp = (N * S_Bf - S_f * S_B) / D;
      }

      if (!isFinite(t0)) t0 = 0;
      if (!isFinite(aAmp)) aAmp = 0;

      T0[i][j] = Math.max(0, t0);
      Aamp[i][j] = aAmp;
    }
  }

  /* ---- 48h / 15min 予報 ---- */
  const dtMin = 15;
  const steps = Math.round(48 * 60 / dtMin);

  gForecastFrames = [];
  gForecastTimes = [];

  for (let s = 0; s <= steps; s++) {
    const t = new Date(gForecastStart.getTime() + s * dtMin * 60000);
    gForecastTimes.push(t);

    const delta = solarDeclinationRad(t);
    const lonS = subsolarLongitudeDeg(t);

    const frame = [];

    for (let i = 0; i < nLat; i++) {
      frame[i] = [];

      const phi = latArr[i] * Math.PI/180;
      const sinphi = Math.sin(phi);
      const cosphi = Math.cos(phi);

      for (let j = 0; j < nLon; j++) {

        const lam = lonArr[j] * Math.PI/180;
        const h = lam - lonS*Math.PI/180;

        const c = sinphi*Math.sin(delta) + cosphi*Math.cos(delta)*Math.cos(h);
        const fDay = Math.max(0, Math.pow(Math.max(0, c), pX));

        let val = T0[i][j] + Aamp[i][j] * fDay;
        if (val < 0) val = 0;

        // 全体スケール
        val *= cfg.kGlobal;

        // 3×3 バイアス補正
        val *= biasFactorFor(latArr[i], lonArr[j]);

        frame[i][j] = val;
      }
    }

    gForecastFrames.push(frame);
  }
}


/* ============================================================
   4. 3×3 バイアス補正
   ============================================================ */

function biasFactorFor(lat, lon) {
  // lat -90 → 90, lon -180 → 180

  let il;
  if (lat < -30) il = 0; 
  else if (lat < 30) il = 1;
  else il = 2;

  let jl;
  if (lon < -60) jl = 0;
  else if (lon < 60) jl = 1;
  else jl = 2;

  return gBiasMatrix[il][jl];
}


/* ============================================================
   5. TEC カラーマップ
   ============================================================ */

function tecColor(v) {
  const vmax = 120;
  const x = Math.max(0, Math.min(1, v / vmax));

  let r, g, b;

  if (x < 0.4) {
    const t = x / 0.4;
    r = 0;
    g = 60 + 195 * t;
    b = 0;
  }
  else if (x < 0.55) {
    const t = (x - 0.4) / 0.15;
    r = 200 + 55 * t;
    g = 200 + 55 * t;
    b = 200 + 55 * t;
  }
  else if (x < 0.7) {
    const t = (x - 0.55) / 0.15;
    r = 255;
    g = 255;
    b = 255 * (1 - t);
  }
  else {
    const t = (x - 0.7) / 0.3;
    r = 255;
    g = 200 * (1 - t);
    b = 0;
  }

  return `rgb(${r|0},${g|0},${b|0})`;
}


/* ============================================================
   6. Leaflet へ描画する Canvas 更新
   ============================================================ */

function drawTecFrame(frame) {
  if (!tecCanvas) {
    tecCanvas = document.getElementById("tecCanvas");
    tecCtx = tecCanvas.getContext("2d");
  }

  const { nLat, nLon, latArr, lonArr } = gGrid;

  const W = tecCanvas.width;
  const H = tecCanvas.height;

  tecCtx.clearRect(0,0,W,H);

  for (let i = 0; i < nLat; i++) {
    const lat = latArr[i];

    for (let j = 0; j < nLon; j++) {
      const lon = lonArr[j];
      const val = frame[i][j];
      const col = tecColor(val);

      // Leaflet 座標 → ピクセル変換
      const p1 = map.latLngToContainerPoint([lat, lon]);
      const p2 = map.latLngToContainerPoint([lat + gGrid.latArr[1] - gGrid.latArr[0],
                                             lon + gGrid.lonArr[1] - gGrid.lonArr[0]]);

      const x = p1.x;
      const y = p1.y;
      const w = p2.x - p1.x;
      const h = p1.y - p2.y;

      tecCtx.fillStyle = col;
      tecCtx.fillRect(x, y - h, w, h);
    }
  }
}

/* ============================================================
   7. 外部から呼ぶ API
   ============================================================ */

function runForecastFromUI(snaps, cfg) {
  computeForecast(snaps, cfg);
}

function updateBiasMatrix(newBias) {
  gBiasMatrix = newBias;
}

function drawFrameAt(index) {
  drawTecFrame(gForecastFrames[index]);
}
/* ============================================================
   SWIFT-TEC v4  (Leaflet map controller)
   - Map Init
   - Canvas overlay
   - Zoom / Pan Sync
   - TEC sampling on click
   ============================================================ */

let map;
let tecCanvas, tecCtx;
let currentFrameIndex = 0;

/* ------------------------------------------------------------
   1. Leaflet 地図初期化（OpenStreetMap / Carto / etc）
------------------------------------------------------------ */
function initMap() {
  map = L.map('map', {
    center: [0, 140],     // 初期位置（あなたがよく使う日本寄り）
    zoom: 3,
    zoomControl: true,
    worldCopyJump: true
  });

  // 標準の TileLayer
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 9,
    minZoom: 2,
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  /* ---- TEC Canvas Layer 準備 ---- */
  tecCanvas = document.getElementById("tecCanvas");
  tecCtx = tecCanvas.getContext("2d");

  // Leaflet の overlayPane に Canvas を追加
  const pane = map.getPanes().overlayPane;
  pane.appendChild(tecCanvas);

  resizeTecCanvas();
  map.on("move zoom zoomend moveend resize", () => {
    resizeTecCanvas();
    redrawTEC();
  });

  // クリック時：TEC値を取得
  map.on("click", handleMapClick);
}

/* ------------------------------------------------------------
   2. Canvas のサイズ更新（Leaflet 地図に合わせる）
------------------------------------------------------------ */
function resizeTecCanvas() {
  const mapSize = map.getSize();
  tecCanvas.width = mapSize.x;
  tecCanvas.height = mapSize.y;

  const topLeft = map.containerPointToLayerPoint([0, 0]);
  L.setPosition(tecCanvas, topLeft);
}

/* ------------------------------------------------------------
   3. TEC の再描画（現在フレームを Leaflet 座標に投影）
------------------------------------------------------------ */
function redrawTEC() {
  if (!gForecastFrames.length) return;
  drawTecFrame(gForecastFrames[currentFrameIndex]);
}

/* ------------------------------------------------------------
   4. 時間スライダー → TEC 再描画
------------------------------------------------------------ */
function setFrameFromSlider(index) {
  currentFrameIndex = index;
  redrawTEC();
}

/* ------------------------------------------------------------
   5. TEC 値を地図クリックで取得
------------------------------------------------------------ */
function handleMapClick(e) {
  if (!gGrid || !gForecastFrames.length) return;

  const lat = e.latlng.lat;
  const lon = e.latlng.lng;

  /* --- 緯度はそのままマッチ --- */

  // 経度は -180〜180 に正規化
  let lonNorm = lon;
  if (lonNorm > 180) lonNorm -= 360;
  if (lonNorm < -180) lonNorm += 360;

  // 最も近い格子点を検索
  const { latArr, lonArr, nLat, nLon } = gGrid;

  const i = nearestIndex(latArr, lat);
  const j = nearestIndex(lonArr, lonNorm);

  const val = gForecastFrames[currentFrameIndex][i][j];

  // 表示
  const info = 
    `Lat: ${lat.toFixed(2)}°\n`+
    `Lon: ${lonNorm.toFixed(2)}°\n`+
    `TEC: ${val.toFixed(2)} TECU\n`+
    `Time: ${gForecastTimes[currentFrameIndex].toISOString().replace('T',' ').replace('.000Z','Z')}`;

  document.getElementById("pointInfo").textContent = info;
}

/* ------------------------------------------------------------
   6. 最近傍格子点を返す
------------------------------------------------------------ */
function nearestIndex(arr, v) {
  let best = 0;
  let minDiff = Math.abs(arr[0] - v);

  for (let i = 1; i < arr.length; i++) {
    const d = Math.abs(arr[i] - v);
    if (d < minDiff) {
      minDiff = d;
      best = i;
    }
  }
  return best;
}

/* ------------------------------------------------------------
   7. 外部 API
------------------------------------------------------------ */
function updateTECFrame(index) {
  currentFrameIndex = index;
  redrawTEC();
}

<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v3 – TEC Forecast (加算版, Sstorm+Sflare)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }

    h1, h2, h3 {
      margin: 0 0 4px 0;
      letter-spacing: 0.03em;
    }

    h1 { font-size: 20px; }
    h2 { font-size: 16px; margin-top: 12px; }
    h3 { font-size: 13px; margin-top: 8px; }

    .page {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 380px;
      padding: 12px 14px;
      border-right: 1px solid rgba(255,255,255,0.12);
      background: radial-gradient(circle at top, #1f2937 0, #050816 55%);
      overflow-y: auto;
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .section {
      margin-bottom: 10px;
      padding: 8px 10px;
      border-radius: 10px;
      background: rgba(15, 23, 42, 0.85);
      border: 1px solid rgba(148,163,184,0.35);
    }

    label {
      font-size: 12px;
      display: block;
      margin-top: 4px;
    }

    input[type="text"],
    input[type="number"],
    input[type="datetime-local"],
    textarea {
      width: 100%;
      font-size: 12px;
      font-family: SFMono-Regular, ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: #020617;
      color: #e5e7eb;
      border-radius: 6px;
      border: 1px solid rgba(148,163,184,0.6);
      padding: 4px 6px;
      margin-top: 2px;
    }

    textarea {
      min-height: 70px;
      resize: vertical;
    }

    button {
      margin-top: 6px;
      padding: 6px 10px;
      font-size: 12px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: linear-gradient(135deg, #22c55e, #14b8a6);
      color: #0b1120;
      font-weight: 600;
      box-shadow: 0 4px 10px rgba(34,197,94,0.35);
    }

    button.secondary {
      background: linear-gradient(135deg, #3b82f6, #06b6d4);
      box-shadow: 0 4px 10px rgba(37,99,235,0.35);
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
      box-shadow: none;
    }

    .status {
      margin-top: 6px;
      font-size: 11px;
      line-height: 1.3;
      color: #e5e7eb;
      white-space: pre-line;
    }

    .map-container {
      flex: 1;
      position: relative;
    }

    #map {
      height: 100%;
      width: 100%;
    }

    .timeline {
      padding: 6px 10px 10px;
      background: rgba(15,23,42,0.95);
      border-top: 1px solid rgba(148,163,184,0.35);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .timeline label {
      margin: 0;
      font-size: 12px;
    }

    #timeSlider {
      flex: 1;
    }

    #timeLabel {
      font-variant-numeric: tabular-nums;
      font-size: 12px;
      min-width: 140px;
    }

    .legend {
      position: absolute;
      right: 10px;
      bottom: 60px;
      width: 18px;
      height: 180px;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(148,163,184,0.6);
      box-shadow: 0 4px 14px rgba(15,23,42,0.9);
      background: linear-gradient(
        to top,
        #450a0a 0%,
        #b91c1c 20%,
        #f97316 40%,
        #eab308 55%,
        #22c55e 70%,
        #0ea5e9 85%,
        #172554 100%
      );
    }

    .legend-labels {
      position: absolute;
      right: 36px;
      bottom: 60px;
      font-size: 10px;
      color: #e5e7eb;
      text-align: right;
      line-height: 1.4;
    }

    .legend-labels div {
      position: relative;
    }

    .legend-labels span {
      background: rgba(15,23,42,0.9);
      padding: 1px 5px;
      border-radius: 999px;
      border: 1px solid rgba(148,163,184,0.4);
    }

    .legend-labels .v0   { bottom: 0;   }
    .legend-labels .v20  { bottom: 30px;}
    .legend-labels .v40  { bottom: 60px;}
    .legend-labels .v60  { bottom: 90px;}
    .legend-labels .v80  { bottom: 120px;}
    .legend-labels .v100 { bottom: 150px;}

    .badge {
      display: inline-block;
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(56,189,248,0.16);
      border: 1px solid rgba(56,189,248,0.7);
      color: #e0f2fe;
      margin-left: 4px;
    }

    .hint {
      font-size: 10px;
      color: #9ca3af;
      margin-top: 2px;
    }

    .two-col {
      display: flex;
      gap: 6px;
    }
    .two-col > div {
      flex: 1;
    }

    ::placeholder {
      color: #6b7280;
    }
  </style>
</head>
<body>
<div class="page">
  <!-- ───────────── Sidebar ───────────── -->
  <div class="sidebar">
    <h1>SWIFT-TEC v3</h1>
    <div style="font-size:11px; color:#9ca3af; margin-bottom:8px;">
      Sstorm / Sflare <span class="badge">加算モデル</span><br>
      BaseTEC = BoM − ΔSstorm(実測Kp) − ΔSflare
    </div>

    <!-- 1. BoM TEC & Base 時刻 -->
    <div class="section">
      <h2>1. BoM TEC（現況グリッド）</h2>
      <label>
        BoM TEC テキスト
        <textarea id="bomTecText" placeholder="# PRODUCT NAME: GLOBAL TEC GRIDDED MAP&#10;# ...&#10;12.20, 12.20, 12.20, ..."></textarea>
      </label>
      <div class="two-col">
        <div>
          <label>
            Base 時刻 (UTC, BoM VALID と合わせる)
            <input type="datetime-local" id="baseTimeUtc" />
          </label>
        </div>
        <div>
          <label>
            予報時間 (時間, 例: 48)
            <input type="number" id="forecastHours" value="48" min="1" max="120" />
          </label>
        </div>
      </div>
      <div class="hint">
        ※ BoMテキストは IRI-2020 GLOBAL TEC GRID のその時刻1枚分。
      </div>
    </div>

    <!-- 2. Kp 実測 -->
    <div class="section">
      <h2>2. Kp 実測 (3h, JSON)</h2>
      <label>
        Kp 実測 JSON
        <textarea id="kpObsText" placeholder='[["time_tag","Kp","a_running","station_count"],["2025-11-26 00:00:00.000","3.33","18","8"], ...]'></textarea>
      </label>
      <div class="hint">
        形式はあなたが貼ってくれた JSON 配列そのまま。<br>
        time_tag, Kp 列を使用。
      </div>
    </div>

    <!-- 3. Kp 3日予報 -->
    <div class="section">
      <h2>3. Kp 3日予報 (JSON)</h2>
      <label>
        Kp 3日予報 JSON
        <textarea id="kpForecastText" placeholder='形式は実測Kpと同じ JSON 配列推奨&#10;※ NOAA 3-day を整形して使う想定'></textarea>
      </label>
      <div class="hint">
        予報時刻 t では、まずこの予報Kpを参照。<br>
        見つからない場合は実測Kpをフォールバック。
      </div>
    </div>

    <!-- 4. Flare 設定 -->
    <div class="section">
      <h2>4. フレア設定 (簡易 JSON)</h2>
      <label>
        フレア JSON
        <textarea id="flareConfigText" placeholder='[{"start":"2025-11-26T06:00:00Z","end":"2025-11-26T09:00:00Z","class":"X2.0"}]'></textarea>
      </label>
      <div class="hint">
        class は C / M / X クラス。<br>
        例: "M5.0", "X1.0"。<br>
        加算は全体Daysideベース &amp; 合計最大 15 TEC にクリップ。
      </div>
    </div>

    <!-- 5. 計算 -->
    <div class="section">
      <h2>5. 計算</h2>
      <button id="btnComputeBase">BaseTEC を計算 (逆補正)</button>
      <button id="btnGenerateForecast" class="secondary">予報TEC を生成 (Base + ΔSstorm + ΔSflare)</button>
      <div id="status" class="status"></div>
    </div>
  </div>

  <!-- ───────────── Main / Map ───────────── -->
  <div class="main">
    <div class="map-container">
      <div id="map"></div>
      <div class="legend"></div>
      <div class="legend-labels">
        <div class="v0"><span>0 TECU</span></div>
        <div class="v20"><span>20</span></div>
        <div class="v40"><span>40</span></div>
        <div class="v60"><span>60</span></div>
        <div class="v80"><span>80</span></div>
        <div class="v100"><span>100+</span></div>
      </div>
    </div>
    <div class="timeline">
      <label for="timeSlider">時刻スライダー</label>
      <input type="range" id="timeSlider" min="0" max="0" step="1" value="0" />
      <div id="timeLabel">Base 未計算</div>
    </div>
  </div>
</div>

<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
  // ===================== グローバル状態 =====================

  let bomMeta = null;        // { latMeta, lonMeta, latValues, lonValues, grid }
  let baseGrid = null;       // [lat][lon] Base TEC
  let kpObsList = [];        // 実測 Kp { time: Date, kp }
  let kpForecastList = [];   // 予報 Kp { time: Date, kp }
  let flareList = [];        // フレア設定
  let forecastTimes = [];    // Date[]
  let forecastGrids = [];    // [timeIndex][lat][lon]
  let baseTimeUtc = null;    // Date

  // Leaflet
  let map;
  let cellLayers = [];       // { rect, i, j }
  let latEdges = [];
  let lonEdges = [];

  // ===================== 初期化 =====================

  window.addEventListener("DOMContentLoaded", () => {
    initMap();

    document.getElementById("btnComputeBase").addEventListener("click", () => {
      try {
        computeBaseTec();
      } catch (e) {
        console.error(e);
        setStatus("BaseTEC 計算中にエラー: " + e.message);
        alert("BaseTEC 計算エラー: " + e.message);
      }
    });

    document.getElementById("btnGenerateForecast").addEventListener("click", () => {
      try {
        generateForecastTec();
      } catch (e) {
        console.error(e);
        setStatus("予報計算中にエラー: " + e.message);
        alert("予報TEC 計算エラー: " + e.message);
      }
    });

    document.getElementById("timeSlider").addEventListener("input", (ev) => {
      const idx = Number(ev.target.value);
      drawGridAtIndex(idx);
    });

    setStatus("BoM, Kp実測, Kp予報, フレアを入力して BaseTEC → 予報TEC の順で実行してください。");
  });

  // ===================== BoM TEC パーサ =====================

  function parseBomTec(text) {
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);

    let latMeta = null;
    let lonMeta = null;
    const dataLines = [];

    for (const line of lines) {
      if (line.startsWith("# LATITUDE GRID")) {
        // 例: "# LATITUDE GRID (min,max,step,n):  -90 90 2 91"
        const part = line.split(":")[1].trim();
        const [minStr, maxStr, stepStr, nStr] = part.split(/\s+/);
        latMeta = {
          min: parseFloat(minStr),
          max: parseFloat(maxStr),
          step: parseFloat(stepStr),
          n: parseInt(nStr, 10)
        };
      } else if (line.startsWith("# LONGITUDE GRID")) {
        // 例: "# LONGITUDE GRID (min,max,step,n): -180 180 5 73"
        const part = line.split(":")[1].trim();
        const [minStr, maxStr, stepStr, nStr] = part.split(/\s+/);
        lonMeta = {
          min: parseFloat(minStr),
          max: parseFloat(maxStr),
          step: parseFloat(stepStr),
          n: parseInt(nStr, 10)
        };
      } else if (!line.startsWith("#")) {
        dataLines.push(line);
      }
    }

    if (!latMeta || !lonMeta) {
      throw new Error("LATITUDE / LONGITUDE GRID のメタ情報が見つかりません。");
    }

    // データ本体
    const grid = dataLines.map(row => {
      return row.split(/,/).map(v => parseFloat(v.trim())).filter(v => !Number.isNaN(v));
    });

    if (grid.length !== latMeta.n) {
      console.warn("BoM TEC: 行数が lat n と一致しません:", grid.length, latMeta.n);
    }

    // 緯度・経度中心値
    const latValues = [];
    for (let i = 0; i < latMeta.n; i++) {
      latValues.push(latMeta.min + latMeta.step * i);
    }

    const lonValues = [];
    for (let j = 0; j < lonMeta.n; j++) {
      lonValues.push(lonMeta.min + lonMeta.step * j);
    }

    return {
      latMeta,
      lonMeta,
      latValues,
      lonValues,
      grid
    };
  }

  // ===================== Kp JSON パーサ =====================

  function parseKpJson(text) {
    if (!text.trim()) return [];
    let arr;
    try {
      arr = JSON.parse(text);
    } catch (e) {
      throw new Error("Kp JSON の解析に失敗しました: " + e.message);
    }
    if (!Array.isArray(arr) || arr.length < 2) {
      return [];
    }

    const header = arr[0];
    const timeIdx = header.indexOf("time_tag");
    const kpIdx   = header.indexOf("Kp");

    if (timeIdx === -1 || kpIdx === -1) {
      throw new Error("Kp JSON に time_tag または Kp 列が存在しません。");
    }

    const list = [];
    for (let i = 1; i < arr.length; i++) {
      const row = arr[i];
      if (!Array.isArray(row)) continue;
      const timeStr = String(row[timeIdx]);
      const kpStr   = String(row[kpIdx]);

      // "2025-11-26 00:00:00.000" → "2025-11-26T00:00:00.000Z"
      const iso = timeStr.replace(" ", "T") + "Z";
      const dt  = new Date(iso);
      if (isNaN(dt.getTime())) continue;

      const kp = parseFloat(kpStr);
      if (Number.isNaN(kp)) continue;

      list.push({ time: dt, kp });
    }

    list.sort((a, b) => a.time - b.time);
    return list;
  }

  /**
   * 指定時刻 t 直前の Kp を取得 (3h分解能を想定)
   * 見つからない場合: 先頭 or null
   */
  function getKpAtTime(list, t) {
    if (!list || list.length === 0) return null;
    let best = null;
    for (const item of list) {
      if (item.time <= t) {
        if (!best || item.time > best.time) {
          best = item;
        }
      }
    }
    if (best) return best.kp;
    // 全て未来なら最初の値を返す
    return list[0].kp;
  }

  // ===================== フレア設定 =====================

  function parseFlareConfig(text) {
    if (!text.trim()) return [];
    let arr;
    try {
      arr = JSON.parse(text);
    } catch (e) {
      throw new Error("フレア JSON の解析に失敗しました: " + e.message);
    }
    if (!Array.isArray(arr)) {
      throw new Error("フレア JSON は配列である必要があります。");
    }

    return arr.map(raw => {
      const start = new Date(raw.start);
      const end   = new Date(raw.end);
      const cls   = String(raw.class || "").toUpperCase();
      const ampBase = flareClassToAmp(cls);  // 最大 15 TEC に近づくような重み

      return {
        start,
        end,
        classStr: cls,
        ampBase
      };
    }).filter(f => !isNaN(f.start.getTime()) && !isNaN(f.end.getTime()));
  }

  /**
   * フレアクラス → ベース振幅 [TEC] (最大 15 TEC 目安)
   * ※ ここは DeepflareNet などの結果に合わせて調整して OK
   */
  function flareClassToAmp(classStr) {
    if (!classStr) return 0;
    const m = classStr.match(/^([A-Z])(\d+(\.\d+)?)?/);
    if (!m) return 0;
    const letter = m[1].toUpperCase();
    const mag = parseFloat(m[2] || "1.0");

    let base;
    switch (letter) {
      case "X":
        base = 15; // Xクラスは全振りで 15 TEC
        break;
      case "M":
        base = 8;  // Mクラス中規模
        break;
      case "C":
        base = 3;  // Cクラス小さめ
        break;
      default:
        base = 0;
        break;
    }
    // 簡易：倍率は 0.1〜1.0 に正規化
    let factor = mag / 10.0;
    if (factor < 0.1) factor = 0.1;
    if (factor > 1.0) factor = 1.0;
    return base * factor;
  }

  /**
   * Sflare: 指定緯度・経度・時刻での ΔTEC_flare [加算, 最大15TEC]
   * - 今回は簡易モデル：Dayside 全体への増加 + 正午ピーク
   * - あなたの DeepflareNet 9領域モデルをここに差し替えてOK
   */
  function computeFlareDeltaTEC(latDeg, lonDeg, tUtc, flareList) {
    if (!flareList || flareList.length === 0) return 0;

    let total = 0;
    for (const f of flareList) {
      if (tUtc < f.start || tUtc > f.end) continue;

      // ローカル太陽時 (単純に経度から算出)
      const hoursLocal = (tUtc.getUTCHours() + tUtc.getUTCMinutes()/60 + lonDeg / 15 + 24) % 24;
      const diff = Math.abs(hoursLocal - 12); // 正午からの差 [0〜12]
      let dayFactor = Math.cos(diff * Math.PI / 12); // 正午 1, 6/18時 0, 夜側 < 0
      if (dayFactor < 0) dayFactor = 0; // 夜側は 0

      const dTec = f.ampBase * dayFactor;
      total += dTec;
    }

    // 合計 15 TEC でクリップ（設計どおり）
    return Math.min(total, 15.0);
  }

  // ===================== Sstorm モデル (加算型 ΔTEC) =====================

  /**
   * Sstorm: ΔTEC_storm [TECU] を返す加算モデル
   * - 引数: 緯度 [deg], Kp
   * - ここは Mukhtarov et al. の近似式に差し替えて OK
   * - 現状: 簡易モデル (中緯度で最大, Kp 依存)
   */
  function computeStormDeltaTEC(latDeg, kp) {
    if (!Number.isFinite(kp) || kp <= 1) return 0;

    const absLat = Math.abs(latDeg);
    let wLat;

    // 中緯度 (20〜60) で最大になるような重み
    if (absLat <= 20) {
      wLat = 0.4;
    } else if (absLat <= 60) {
      // 20〜60 を 0.4→1.0 で線形
      wLat = 0.4 + (absLat - 20) / 40 * 0.6;
    } else {
      // 高緯度は少し下げる
      wLat = 0.5;
    }

    const kpEff = Math.max(0, kp - 1); // Kp > 1 から有効
    const delta = wLat * kpEff * 2.0;  // 1Kpあたり約2TEC (中緯度で最大)

    // 最大 20 TEC 程度にクリップ
    return Math.min(delta, 20.0);
  }

  // ===================== BaseTEC 計算 =====================

  function computeBaseTec() {
    const bomText = document.getElementById("bomTecText").value.trim();
    if (!bomText) {
      throw new Error("BoM TEC テキストが空です。");
    }

    const baseTimeStr = document.getElementById("baseTimeUtc").value;
    if (!baseTimeStr) {
      throw new Error("Base 時刻 (UTC) が指定されていません。");
    }
    baseTimeUtc = new Date(baseTimeStr);
    if (isNaN(baseTimeUtc.getTime())) {
      throw new Error("Base 時刻の形式が不正です。");
    }

    const kpObsText = document.getElementById("kpObsText").value.trim();
    if (!kpObsText) {
      throw new Error("Kp 実測 JSON が入力されていません。");
    }

    bomMeta = parseBomTec(bomText);
    kpObsList = parseKpJson(kpObsText);
    flareList = parseFlareConfig(document.getElementById("flareConfigText").value.trim());

    if (!kpObsList.length) {
      throw new Error("Kp 実測が1件もパースできませんでした。");
    }

    const kpBase = getKpAtTime(kpObsList, baseTimeUtc);
    const latValues = bomMeta.latValues;
    const lonValues = bomMeta.lonValues;
    const gridObs   = bomMeta.grid;

    const nLat = latValues.length;
    const nLon = lonValues.length;

    // 座標のエッジ配列を準備 (描画用)
    prepareLatLonEdges(bomMeta);

    // 緯度ごとの ΔSstorm(base) を事前計算
    const stormBaseByLat = new Array(nLat);
    for (let i = 0; i < nLat; i++) {
      stormBaseByLat[i] = computeStormDeltaTEC(latValues[i], kpBase);
    }

    // Base TEC = BoM – ΔSstorm – ΔSflare
    baseGrid = new Array(nLat);
    for (let i = 0; i < nLat; i++) {
      baseGrid[i] = new Array(nLon);
      const lat = latValues[i];
      for (let j = 0; j < nLon; j++) {
        const lon = lonValues[j];
        const tecObs   = gridObs[i][j];
        const dStorm   = stormBaseByLat[i];
        const dFlare   = computeFlareDeltaTEC(lat, lon, baseTimeUtc, flareList);
        const tecBase  = Math.max(0, tecObs - dStorm - dFlare); // 負値は0でクリップ
        baseGrid[i][j] = tecBase;
      }
    }

    // Base 時刻のみのグリッドを保持
    forecastTimes = [new Date(baseTimeUtc.getTime())];
    forecastGrids = [cloneGrid(baseGrid)];

    initGridLayers();       // Leaflet のセルを初期化
    updateTimeSlider();     // スライダー 0 のみに
    drawGridAtIndex(0);     // Base を描画

    setStatus(
      "BaseTEC を計算しました。\n" +
      "Base 時刻 (UTC): " + baseTimeUtc.toISOString() + "\n" +
      "Kp(Base): " + (kpBase != null ? kpBase.toFixed(2) : "N/A") + "\n" +
      "ΔSstorm, ΔSflare を Base から引いて静穏TECを抽出。"
    );
  }

  // ===================== 予報 TEC 計算 =====================

  function generateForecastTec() {
    if (!baseGrid || !bomMeta || !baseTimeUtc) {
      throw new Error("先に BaseTEC を計算してください。");
    }

    const kpForecastText = document.getElementById("kpForecastText").value.trim();
    if (!kpForecastText) {
      throw new Error("Kp 3日予報 JSON が入力されていません。");
    }
    kpForecastList = parseKpJson(kpForecastText);

    // flare 再読込（更新を反映）
    flareList = parseFlareConfig(document.getElementById("flareConfigText").value.trim());

    const hours = Number(document.getElementById("forecastHours").value || "48");
    if (!Number.isFinite(hours) || hours <= 0) {
      throw new Error("予報時間が不正です。");
    }

    const latValues = bomMeta.latValues;
    const lonValues = bomMeta.lonValues;
    const nLat = latValues.length;
    const nLon = lonValues.length;

    forecastTimes = [];
    forecastGrids = [];

    // 0時間目は Base (既に baseGrid で逆補正済み)
    for (let h = 0; h <= hours; h++) {
      const t = new Date(baseTimeUtc.getTime() + h * 3600 * 1000);
      forecastTimes.push(t);

      // 予報Kp優先、なければ実測Kpでフォールバック
      let kp = getKpAtTime(kpForecastList, t);
      if (kp == null) {
        kp = getKpAtTime(kpObsList, t);
      }
      if (kp == null) kp = 0;

      // 緯度別 ΔSstorm(t)
      const stormByLat = new Array(nLat);
      for (let i = 0; i < nLat; i++) {
        stormByLat[i] = computeStormDeltaTEC(latValues[i], kp);
      }

      const grid = new Array(nLat);
      for (let i = 0; i < nLat; i++) {
        grid[i] = new Array(nLon);
        const lat = latValues[i];
        for (let j = 0; j < nLon; j++) {
          const lon = lonValues[j];
          const baseTec = baseGrid[i][j];
          const dStorm  = stormByLat[i];
          const dFlare  = computeFlareDeltaTEC(lat, lon, t, flareList);
          const tec     = Math.max(0, baseTec + dStorm + dFlare);
          grid[i][j] = tec;
        }
      }
      forecastGrids.push(grid);
    }

    updateTimeSlider();
    drawGridAtIndex(0);

    setStatus(
      "予報TEC を生成しました。\n" +
      "時間分解能: 1h, 合計 " + forecastTimes.length + " ステップ\n" +
      "BaseTEC + ΔSstorm(Kp予報) + ΔSflare で計算。"
    );
  }

  // ===================== Leaflet 関連 =====================

  function initMap() {
    map = L.map("map", {
      worldCopyJump: true,
      center: [0, 0],
      zoom: 2,
      zoomControl: true,
      attributionControl: false
    });

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 5,
      minZoom: 1
    }).addTo(map);
  }

  function prepareLatLonEdges(meta) {
    const { latMeta, lonMeta, latValues, lonValues } = meta;
    const latStep = latMeta.step;
    const lonStep = lonMeta.step;

    latEdges = new Array(latValues.length);
    lonEdges = new Array(lonValues.length);

    for (let i = 0; i < latValues.length; i++) {
      const c = latValues[i];
      let low  = c - latStep / 2;
      let high = c + latStep / 2;
      if (low < -90) low = -90;
      if (high > 90) high = 90;
      latEdges[i] = { low, high };
    }

    for (let j = 0; j < lonValues.length; j++) {
      const c = lonValues[j];
      let low  = c - lonStep / 2;
      let high = c + lonStep / 2;
      if (low < -180) low = -180;
      if (high > 180) high = 180;
      lonEdges[j] = { low, high };
    }
  }

  function initGridLayers() {
    // 既存セルを削除
    for (const obj of cellLayers) {
      map.removeLayer(obj.rect);
    }
    cellLayers = [];

    if (!bomMeta || !latEdges.length || !lonEdges.length) return;

    const nLat = bomMeta.latValues.length;
    const nLon = bomMeta.lonValues.length;

    for (let i = 0; i < nLat; i++) {
      const latBand = latEdges[i];
      for (let j = 0; j < nLon; j++) {
        const lonBand = lonEdges[j];
        const rect = L.rectangle(
          [
            [latBand.low,  lonBand.low],
            [latBand.high, lonBand.high]
          ],
          {
            stroke: false,
            fillOpacity: 0.82,
            fillColor: "#000000"
          }
        );
        rect.addTo(map);
        cellLayers.push({ rect, i, j });
      }
    }
  }

  function drawGridAtIndex(index) {
    if (!baseGrid || !bomMeta) return;

    const slider = document.getElementById("timeSlider");
    const timeLabel = document.getElementById("timeLabel");

    let grid;
    let t;
    if (forecastGrids.length > 1 && forecastGrids[index]) {
      grid = forecastGrids[index];
      t = forecastTimes[index];
    } else {
      grid = baseGrid;
      t = baseTimeUtc;
    }

    if (!cellLayers.length) {
      initGridLayers();
    }

    // TEC → 色のマッピング
    // 0〜100 TECU を想定して HSL で青→緑→黄→赤
    function tecToColor(tec) {
      const v = Math.max(0, Math.min(100, tec || 0));
      const ratio = v / 100; // 0〜1
      // 0: 青(230deg), 0.5: 緑(120deg), 1.0: 赤(10deg)
      const hue = 230 - 220 * ratio;
      const sat = 100;
      const light = 50;
      return `hsl(${hue}, ${sat}%, ${light}%)`;
    }

    for (const obj of cellLayers) {
      const v = grid[obj.i][obj.j];
      obj.rect.setStyle({
        fillColor: tecToColor(v)
      });
    }

    if (t) {
      const iso = t.toISOString().replace(".000Z", "Z");
      timeLabel.textContent = iso;
    } else {
      timeLabel.textContent = "Base 未計算";
    }

    slider.value = index;
  }

  function updateTimeSlider() {
    const slider = document.getElementById("timeSlider");
    if (forecastGrids.length > 1) {
      slider.min = 0;
      slider.max = forecastGrids.length - 1;
      slider.value = 0;
    } else {
      slider.min = 0;
      slider.max = 0;
      slider.value = 0;
    }
  }

  // ===================== ユーティリティ =====================

  function cloneGrid(grid) {
    return grid.map(row => row.slice());
  }

  function setStatus(msg) {
    const el = document.getElementById("status");
    if (el) el.textContent = msg;
  }
</script>
</body>
</html>

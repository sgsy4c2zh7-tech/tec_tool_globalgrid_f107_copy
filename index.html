<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v3 – TEC Forecast & Verification Tool (Leaflet版, 7日予報)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin: 0 0 4px 0;
      letter-spacing: 0.03em;
    }
    h1 { font-size: 20px; }
    h2 { font-size: 16px; }
    h3 { font-size: 14px; }

    .page {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 430px;
      min-width: 360px;
      max-width: 480px;
      border-right: 1px solid #222b3f;
      padding: 10px;
      overflow-y: auto;
      background: radial-gradient(circle at top, #1c2740 0, #050814 55%, #050814 100%);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
      min-width: 0;
      overflow-y: auto;
    }

    .card {
      background: rgba(10, 16, 32, 0.96);
      border: 1px solid #222b3f;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 4px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .card-header span {
      font-size: 11px;
      opacity: 0.7;
    }

    textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #334;
      background: #050814;
      color: #f5f5f5;
      font-family: "Consolas","Menlo",monospace;
    }
    input[type="number"],
    input[type="text"],
    input[type="color"],
    select {
      background: #050814;
      border-radius: 4px;
      border: 1px solid #334;
      color: #f5f5f5;
      font-size: 11px;
      padding: 2px 4px;
      font-family: inherit;
    }
    input[type="checkbox"] {
      transform: scale(0.9);
    }
    label {
      font-size: 11px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-bottom: 4px;
      align-items: center;
      flex-wrap: wrap;
    }
    .row > div {
      flex: 1;
      min-width: 80px;
    }
    button {
      border-radius: 4px;
      border: 1px solid #3b82f6;
      background: #1d4ed8;
      color: #f9fafb;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary {
      border-color: #4b5563;
      background: #111827;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .small {
      font-size: 10px;
      opacity: 0.8;
    }
    pre {
      font-size: 11px;
      background: #050814;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #222b3f;
      white-space: pre-wrap;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }
    th, td {
      border: 1px solid #222b3f;
      padding: 2px 4px;
      text-align: center;
    }
    th {
      background: #111827;
    }
    .flex-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-card { flex: 0 0 auto; }
    .map-card {
      flex: 1 1 auto;
      min-height: 55vh;
      display: flex;
    }
    .output-card { flex: 0 0 auto; }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
    }
    #timeSlider {
      flex: 1;
    }

    #tecMap {
      flex: 1;
      height: 100%;
      min-height: 360px;
      border-radius: 8px;
      overflow: hidden;
    }
    .leaflet-container {
      background: #000;
    }
    .tec-canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .leaflet-control.tec-legend {
      background: rgba(5, 8, 20, 0.95);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #222b3f;
      color: #f5f5f5;
      font-size: 10px;
      line-height: 1.3;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
    }
    .tec-legend-title {
      text-align: center;
      margin-bottom: 4px;
      font-weight: 600;
      letter-spacing: 0.05em;
    }
    .tec-legend-bar {
      width: 18px;
      height: 130px;
      margin: 0 auto 4px auto;
      border-radius: 4px;
      border: 1px solid #444;
    }
    .tec-legend-labels {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
    }

    #verifyCanvas {
      width: 220px;
      height: 220px;
      background: #050814;
      border-radius: 6px;
      border: 1px solid #222b3f;
    }

    .output-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .output-col {
      flex: 1;
      min-width: 200px;
      display: flex;
      flex-direction: column;
    }

    .output-col pre {
      max-height: 220px;
      overflow-y: auto;
    }

    hr {
      border: none;
      border-top: 1px solid #222b3f;
      margin: 4px 0;
    }

    .focus-btn {
      width: 100%;
      font-size: 9px;
      padding: 3px 2px;
    }
  </style>
</head>
<body>
  <div class="page">
    <!-- ============= サイドバー ============= -->
    <div class="sidebar">
      <div class="card">
        <div class="card-header">
          <h1>SWIFT-TEC v3</h1>
          <span>Global TEC Forecast & Verification (7-day)</span>
        </div>
        <div class="small">
          ・BoM TEC（最大9枚）から <b>7日 / 1h</b> 予報を生成<br>
          ・F10.7 / Ap / Dst / X-ray / Deep Flare Net / 磁気嵐（Mukhtarov rTECベース）を反映<br>
          ・NOAAテキストから F10.7(t) / Kp(t) を自動読取（任意）<br>
          ・BoM 実測（最大4枚）で 3×3 領域ごとの誤差検証<br>
          ・Leaflet 地図で TEC / GPS誤差を確認、地域フォーカスも可能
        </div>
      </div>

      <!-- 1. BoM TEC 予報用 -->
      <div class="card">
        <div class="card-header">
          <h2>1. BoM TEC（予報用 最大9枚）</h2>
          <span>World0000_tec.txt などをコピペ</span>
        </div>
        <div class="row small">
          <div>BoM #1</div><div>BoM #2</div><div>BoM #3</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput1" placeholder="# PRODUCT NAME..."></textarea></div>
          <div><textarea id="bomInput2"></textarea></div>
          <div><textarea id="bomInput3"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #4</div><div>BoM #5</div><div>BoM #6</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput4"></textarea></div>
          <div><textarea id="bomInput5"></textarea></div>
          <div><textarea id="bomInput6"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #7</div><div>BoM #8</div><div>BoM #9</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput7"></textarea></div>
          <div><textarea id="bomInput8"></textarea></div>
          <div><textarea id="bomInput9"></textarea></div>
        </div>
        <div class="row">
          <button onclick="saveBomInputs()">BoM入力を保存</button>
          <button class="secondary" onclick="clearBomInputsStorage()">保存を削除</button>
        </div>
        <div class="small" id="bomInfo">
          ※「BoM入力を保存」を押した時点の内容をブラウザに保存。次回起動時に自動復元。
        </div>
      </div>

      <!-- 2. 太陽活動パラメータ -->
      <div class="card">
        <div class="card-header">
          <h2>2. 太陽活動パラメータ</h2>
          <span>NOAA / 京都WDC / GOES 代表値（手動 or 補正用）</span>
        </div>
        <div class="row">
          <div>
            <label>F10.7 [sfu]（基準値）</label><br>
            <input id="inpF107" type="number" value="150" step="1">
          </div>
          <div>
            <label>Ap Index</label><br>
            <input id="inpAp" type="number" value="10" step="1">
          </div>
          <div>
            <label>Dst [nT]</label><br>
            <input id="inpDst" type="number" value="-20" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>X-ray (代表値 W/m²)</label><br>
            <input id="inpXray" type="number" value="1e-6" step="1e-7">
          </div>
        </div>
        <div class="small">
          ※F10.7(t) / Kp(t) を NOAA テキストから読取る場合も、ここは「ベース値」や「補正値」として使えます。
        </div>
      </div>

      <!-- 2b. NOAA F10.7 / Kp テキスト -->
      <div class="card">
        <div class="card-header">
          <h2>2b. NOAA F10.7 / Kp テキスト</h2>
          <span>テキストを丸ごと貼り付け → 自動読取</span>
        </div>
        <div class="small">
          NOAAの45日F10.7予報・3日Kp予報などを Ctrl+A → Ctrl+C でコピーして貼り付け。<br>
          形式が合わない場合は、簡易フォーマット：<br>
          F10.7: <code>YYYY MM DD F10.7</code><br>
          Kp: <code>YYYY-MM-DD HH Kp</code><br>
          に整形すると確実です。
        </div>
        <div class="row">
          <div>
            <label>F10.7 予報テキスト</label><br>
            <textarea id="noaaF107Text" placeholder="NOAAのF10.7予報テキストを丸ごと貼り付け"></textarea>
          </div>
        </div>
        <div class="row">
          <div>
            <label>Kp 予報テキスト</label><br>
            <textarea id="noaaKpText" placeholder="NOAAのKp予報テキストを丸ごと貼り付け"></textarea>
          </div>
        </div>
        <div class="small">
          「TEC予報を計算」ボタンを押したときに自動でパースし、F10.7(t) / Kp(t) に反映します。
        </div>
      </div>

      <!-- 3. Deep Flare Net 9領域 -->
      <div class="card">
        <div class="card-header">
          <h2>3. Deep Flare Net 領域</h2>
          <span>9分割フレア確率（3×3）</span>
        </div>
        <div class="small">
          太陽円盤を 3×3 の 9領域に分割し、各領域ごとの Xクラス / Mクラス発生確率 [%] を入力。<br>
          位置イメージ：<br>
          R1=北西, R2=北, R3=北東 / R4=西, R5=中央, R6=東 / R7=南西, R8=南, R9=南東
        </div>
        <table>
          <thead>
            <tr>
              <th>ID</th><th>位置イメージ</th><th>P(X≥) %</th><th>P(M≥) %</th><th>使用</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>R1</td><td>北西</td>
              <td><input id="fx1" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm1" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu1" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R2</td><td>北</td>
              <td><input id="fx2" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm2" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu2" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R3</td><td>北東</td>
              <td><input id="fx3" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm3" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu3" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R4</td><td>西</td>
              <td><input id="fx4" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm4" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu4" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R5</td><td>中央</td>
              <td><input id="fx5" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm5" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu5" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R6</td><td>東</td>
              <td><input id="fx6" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm6" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu6" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R7</td><td>南西</td>
              <td><input id="fx7" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm7" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu7" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R8</td><td>南</td>
              <td><input id="fx8" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm8" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu8" type="checkbox" checked></td>
            </tr>
            <tr>
              <td>R9</td><td>南東</td>
              <td><input id="fx9" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm9" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu9" type="checkbox" checked></td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- 4. 検証用 BoM -->
      <div class="card">
        <div class="card-header">
          <h2>4. 検証用 BoM TEC（最大4枚）</h2>
          <span>予報期間中の実測</span>
        </div>
        <div class="row small">
          <div>Verify #1</div><div>Verify #2</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput1"></textarea></div>
          <div><textarea id="verifyInput2"></textarea></div>
        </div>
        <div class="row small">
          <div>Verify #3</div><div>Verify #4</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput3"></textarea></div>
          <div><textarea id="verifyInput4"></textarea></div>
        </div>
        <div class="row">
          <button onclick="runVerification()">検証を実行</button>
          <button class="secondary" onclick="clearVerification()">検証クリア</button>
        </div>
        <div class="small">
          検証では地球を緯度×経度で3×3の9領域に分割し、<br>
          各領域の MAPE（誤差%）と Bias（過大/過小）を算出します。
        </div>
      </div>

      <!-- 5. 検証マップ色設定 -->
      <div class="card">
        <div class="card-header">
          <h2>5. 検証マップ色設定</h2>
          <span>誤差(%) → 色を任意設定</span>
        </div>
        <div class="small">
          誤差の上限と色を設定。例）10%まで緑、20%まで黄、30%までオレンジ、それ以上赤。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>誤差上限%</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="vLimit1" type="number" value="10" style="width:50px;"></td>
              <td><input id="vColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="vLimit2" type="number" value="20" style="width:50px;"></td>
              <td><input id="vColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="vLimit3" type="number" value="30" style="width:50px;"></td>
              <td><input id="vColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="vLimit4" type="number" value="999" style="width:50px;"></td>
              <td><input id="vColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyVerifyColorScale()">色設定を反映</button>
          <button class="secondary" onclick="resetVerifyColorScale()">初期化</button>
        </div>
      </div>

      <!-- 6. TEC カラーマップ設定 -->
      <div class="card">
        <div class="card-header">
          <h2>6. TEC カラーマップ設定</h2>
          <span>TEC値 → 色を任意設定</span>
        </div>
        <div class="small">
          TEC [TECU] の上限と色を設定。色は Leaflet 地図と凡例に反映されます。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>TEC上限[TECU]</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="tLimit1" type="number" value="10" style="width:60px;"></td>
              <td><input id="tColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="tLimit2" type="number" value="30" style="width:60px;"></td>
              <td><input id="tColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="tLimit3" type="number" value="60" style="width:60px;"></td>
              <td><input id="tColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="tLimit4" type="number" value="120" style="width:60px;"></td>
              <td><input id="tColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyTecColorScale()">TEC色を反映</button>
          <button class="secondary" onclick="resetTecColorScale()">初期化</button>
        </div>
      </div>

      <!-- 7. GPS L1誤差 カラーマップ設定 -->
      <div class="card">
        <div class="card-header">
          <h2>7. GPS L1誤差 カラーマップ</h2>
          <span>誤差[m] → 色を任意設定</span>
        </div>
        <div class="small">
          L1即位誤差 [m] の上限と色を設定。TEC×kL1 で換算。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>誤差上限[m]</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="gLimit1" type="number" value="5" style="width:60px;"></td>
              <td><input id="gColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="gLimit2" type="number" value="10" style="width:60px;"></td>
              <td><input id="gColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="gLimit3" type="number" value="20" style="width:60px;"></td>
              <td><input id="gColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="gLimit4" type="number" value="40" style="width:60px;"></td>
              <td><input id="gColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyGpsColorScale()">GPS色を反映</button>
          <button class="secondary" onclick="resetGpsColorScale()">初期化</button>
        </div>
      </div>

      <!-- 8. 磁気嵐 / 電離圏嵐パラメータ -->
      <div class="card">
        <div class="card-header">
          <h2>8. 磁気嵐 / 電離圏嵐パラメータ</h2>
          <span>CME / 高速太陽風 からのイベント包絡</span>
        </div>
        <div class="row">
          <div>
            <label>磁気嵐開始 [h]</label><br>
            <input id="stormStartH" type="number" value="0" step="1">
          </div>
          <div>
            <label>磁気嵐継続時間 [h]</label><br>
            <input id="stormDurH" type="number" value="0" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>磁気嵐強度 Kp (0–9, イベント用)</label><br>
            <input id="stormKp" type="number" value="0" step="0.5" min="0" max="9">
          </div>
          <div>
            <label>電離圏嵐ピーク遅れ [h]</label><br>
            <input id="ionoDelayH" type="number" value="0" step="1">
          </div>
        </div>
        <div class="small">
          ・NOAA Kp テキストがある場合 → Kp(t) はそちらを優先。<br>
          ・ここは「CME到来時間帯だけ上乗せ」などのイベント包絡用。<br>
          Smag_env = 1 + 0.3×(Kp_event/9), Siono_env = 1 + 0.5×(Kp_event/9) を適用。
        </div>
      </div>

      <!-- 9. 係数設定 -->
      <div class="card">
        <div class="card-header">
          <h2>9. 係数設定（Advanced）</h2>
          <span>バイアス提案・昼夜境界・GPS変換</span>
        </div>
        <div class="small">※いじり過ぎる前に現在値をどこかにメモ推奨。</div>
        <div class="flex-col">
          <div class="row">
            <div>
              <label>kGlobal（全体スケール）</label><br>
              <input id="cfg_kGlobal" type="number" value="0.55" step="0.05">
            </div>
            <div>
              <label>wF107</label><br>
              <input id="cfg_wF107" type="number" value="0.004" step="0.001">
            </div>
            <div>
              <label>wAp</label><br>
              <input id="cfg_wAp" type="number" value="0.01" step="0.002">
            </div>
          </div>
          <div class="row">
            <div>
              <label>wDst</label><br>
              <input id="cfg_wDst" type="number" value="-0.002" step="0.001">
            </div>
            <div>
              <label>pX（日中指数）</label><br>
              <input id="cfg_pX" type="number" value="0.2" step="0.05">
            </div>
            <div>
              <label>latShape（赤道異常）</label><br>
              <input id="cfg_latShape" type="number" value="0.45" step="0.05">
            </div>
          </div>
          <div class="row">
            <div>
              <label>latHighCut（高緯度調整）</label><br>
              <input id="cfg_latHighCut" type="number" value="1.05" step="0.05">
            </div>
            <div>
              <label>β_flare</label><br>
              <input id="cfg_betaFlare" type="number" value="0.5" step="0.05">
            </div>
            <div>
              <label>k_X</label><br>
              <input id="cfg_kX" type="number" value="1.0" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>k_M</label><br>
              <input id="cfg_kM" type="number" value="0.3" step="0.1">
            </div>
            <div>
              <label>biasThresh%（提案閾値）</label><br>
              <input id="cfg_biasThresh" type="number" value="15" step="1">
            </div>
            <div>
              <label>suggestGain（提案の強さ）</label><br>
              <input id="cfg_suggestGain" type="number" value="0.5" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>dayEdgeCosWidth（昼夜境界の滑らかさ）</label><br>
              <input id="cfg_dayEdgeCosWidth" type="number" value="0.2" step="0.05">
            </div>
            <div>
              <label>kL1（TEC→L1誤差[m/TECU]）</label><br>
              <input id="cfg_kL1" type="number" value="0.16" step="0.01">
            </div>
          </div>
        </div>
        <div class="row">
          <button onclick="saveConfig()">設定を保存</button>
          <button class="secondary" onclick="loadConfig(true)">保存値を再読込</button>
        </div>
      </div>

      <!-- 10. 地域フォーカス -->
      <div class="card">
        <div class="card-header">
          <h2>10. 地域フォーカス</h2>
          <span>地図ズームに反映</span>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('japan')">日本</button>
          <button class="focus-btn" onclick="focusRegion('northAmerica')">北アメリカ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('southAmerica')">南アメリカ</button>
          <button class="focus-btn" onclick="focusRegion('europe')">ヨーロッパ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('africa')">アフリカ</button>
          <button class="focus-btn" onclick="focusRegion('australia')">オーストラリア</button>
        </div>
        <hr>
        <div class="small">手動指定（緯度・経度 範囲）</div>
        <div class="row">
          <div>
            <label>Lat min</label><br>
            <input id="focusLatMin" type="number" value="-10" step="1">
          </div>
          <div>
            <label>Lat max</label><br>
            <input id="focusLatMax" type="number" value="50" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Lon min</label><br>
            <input id="focusLonMin" type="number" value="120" step="1">
          </div>
          <div>
            <label>Lon max</label><br>
            <input id="focusLonMax" type="number" value="150" step="1">
          </div>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="applyManualFocus()">手動フォーカス適用</button>
          <button class="focus-btn secondary" onclick="resetFocus()">全体表示</button>
        </div>
      </div>

      <!-- 11. 実行 -->
      <div class="card">
        <div class="card-header">
          <h2>11. 実行</h2>
          <span>予報 & 描画</span>
        </div>
        <div class="row">
          <button onclick="runForecast()">TEC予報を計算</button>
          <button class="secondary" onclick="resetAll()">リセット</button>
        </div>
        <div id="runInfo" class="small"></div>
      </div>
    </div>

    <!-- ============= メイン領域 ============= -->
    <div class="main">
      <!-- 上段：時間スライダー＋透明度＋表示モード -->
      <div class="card slider-card">
        <div class="slider-row">
          <span>時間スライダー（0〜7日 / 1h刻み）</span>
          <input type="range" id="timeSlider" min="0" max="168" value="0" oninput="onSliderChange()">
          <span id="timeLabel">t = 0.00 h</span>
        </div>
        <div class="row small" style="margin-top:4px;">
          <div style="flex:1;">
            TEC透明度:
            <input id="tecAlpha" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;" oninput="onTecAlphaChange()">
          </div>
          <div style="flex:1;">
            表示モード:
            <select id="mapModeSelect" onchange="changeMapMode()">
              <option value="tec">TEC [TECU]</option>
              <option value="gps">GPS L1誤差 [m]</option>
            </select>
          </div>
          <div style="flex:2;">
            <span class="small">※地図をズーム／ドラッグして、任意の地域の TEC / GPS誤差 分布を確認できます。</span>
          </div>
        </div>
      </div>

      <!-- 中段：Leaflet 地図 -->
      <div class="card map-card">
        <div id="tecMap"></div>
      </div>

      <!-- 下段：検証マップ＋レポート＋クリックTEC値＋式 -->
      <div class="card output-card">
        <div class="output-row">
          <div class="output-col" style="flex:0 0 240px; max-width:260px;">
            <h3>12. 検証 3×3 マップ</h3>
            <canvas id="verifyCanvas"></canvas>
          </div>
          <div class="output-col" style="flex:2;">
            <h3>13. 検証レポート & 係数提案</h3>
            <pre id="verifyReport">(まだ検証されていません)</pre>
            <h3>14. 現在の計算式</h3>
            <pre id="formulaText">(kGlobal, 太陽活動, フレア, 磁気嵐(Mukhtarov), 緯度依存を含めた最新式をここに表示)</pre>
          </div>
          <div class="output-col" style="flex:1;">
            <h3>15. 現在の TEC / GPS値</h3>
            <pre id="pointInfo">地図上をクリックすると、その格子点のTEC・GPS L1誤差と位置が表示されます。</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ============ グローバル状態 ============ */
    const FORECAST_HOURS = 24 * 7;   // ★ 7日分
    const DT_MINUTES     = 60;       // ★ 1時間刻み

    let gGrid = null;              // {latArr, lonArr, nLat, nLon}
    let gForecastFrames = [];      // [step][iLat][iLon] TEC
    let gForecastTimes = [];       // Date[]
    let gForecastStart = null;     // Date (UTC, from first BoM)
    let currentStepIndex = 0;

    let gVerifyColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 20,  color: "#ffff00" },
      { limit: 30,  color: "#ff9900" },
      { limit: 999, color: "#ff0000" }
    ];

    // TEC カラー
    let gTecColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 30,  color: "#ffff00" },
      { limit: 60,  color: "#ff9900" },
      { limit: 120, color: "#ff0000" }
    ];

    // GPS L1 誤差 カラー
    let gGpsColorScale = [
      { limit: 5,  color: "#00ff00" },
      { limit: 10, color: "#ffff00" },
      { limit: 20, color: "#ff9900" },
      { limit: 40, color: "#ff0000" }
    ];

    // NOAA 由来の F10.7(t), Kp(t) シリーズ
    let gF107Series = []; // [{time: Date(UTC昼ごろ), value}]
    let gKpSeries   = []; // [{time: Date(UTC), kp}]

    // Leaflet 関連
    let map = null;
    let tecCanvas = null;
    let tecCtx = null;
    let tecLegendControl = null;
    let tecAlpha = 0.8;

    let lastVerifyResult = null;
    let mapMode = "tec";   // 'tec' or 'gps'

    // 地域フォーカス
    let currentFocus = null; // {latMin,latMax,lonMin,lonMax}

    const STORAGE_KEY_CONFIG   = "swifttec_config_v4_7d_mukhtarov";
    const STORAGE_KEY_VCOL     = "swifttec_vcol_v3";
    const STORAGE_KEY_BOM      = "swifttec_bom_inputs_v4";  // ★ 9枚対応版
    const STORAGE_KEY_TCOL     = "swifttec_teccol_v3";
    const STORAGE_KEY_GCOL     = "swifttec_gpscol_v1";

    function logInfo(msg) {
      const div = document.getElementById("runInfo");
      if (div) div.textContent = msg;
      console.log(msg);
    }
    function clamp(v, a, b) { return v < a ? a : (v > b ? b : v); }

    /* ===== 日付パース: VALID DATE/TIME: 11/11/2025 00:00:00UTC ===== */
    function parseBomValidTime(text) {
      const lines = text.split(/\r?\n/);
      for (const line of lines) {
        const m = line.match(/VALID DATE\/TIME:\s*(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/i);
        if (m) {
          const d  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const y  = parseInt(m[3],10);
          const hh = parseInt(m[4],10);
          const mm = parseInt(m[5],10);
          const ss = parseInt(m[6],10);
          return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
        }
      }
      return null;
    }

    /* ====== BoM TEC テキスト → 格子データ ====== */
    function parseBoM(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (!lines.length) throw new Error("空のテキストです。");

      let latMin, latMax, latStep, nLat;
      let lonMin, lonMax, lonStep, nLon;

      for (const line of lines) {
        if (/LATITUDE GRID/i.test(line)) {
          const m = line.match(/LATITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            latMin  = parseFloat(m[1]);
            latMax  = parseFloat(m[2]);
            latStep = parseFloat(m[3]);
            nLat    = parseInt(m[4],10);
          }
        } else if (/LONGITUDE GRID/i.test(line)) {
          const m = line.match(/LONGITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            lonMin  = parseFloat(m[1]);
            lonMax  = parseFloat(m[2]);
            lonStep = parseFloat(m[3]);
            nLon    = parseInt(m[4],10);
          }
        }
      }
      if (latMin === undefined || lonMin === undefined) {
        throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません。");
      }

      const valLines = lines.filter(l => !l.trim().startsWith("#") && !/GRID/i.test(l));
      const values = [];
      for (const ln of valLines) {
        const parts = ln.split(/[, ]+/).map(x => x.trim()).filter(x => x.length>0);
        for (const p of parts) {
          const v = parseFloat(p);
          if (!isNaN(v)) values.push(v);
        }
      }
      if (values.length !== nLat*nLon) {
        throw new Error(`データ数が不一致です: ${values.length} vs ${nLat*nLon}`);
      }

      const latArr = [];
      for (let i=0;i<nLat;i++) latArr.push(latMin + latStep*i);
      const lonArr = [];
      for (let j=0;j<nLon;j++) lonArr.push(lonMin + lonStep*j);

      const grid = new Array(nLat);
      let idx = 0;
      for (let i=0;i<nLat;i++) {
        grid[i] = new Array(nLon);
        for (let j=0;j<nLon;j++) {
          grid[i][j] = values[idx++];
        }
      }

      const validTime = parseBomValidTime(text);
      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============ BoM 入力保存 ============ */
    function saveBomInputs() {
      const data = {
        bomInput1: document.getElementById("bomInput1").value,
        bomInput2: document.getElementById("bomInput2").value,
        bomInput3: document.getElementById("bomInput3").value,
        bomInput4: document.getElementById("bomInput4").value,
        bomInput5: document.getElementById("bomInput5").value,
        bomInput6: document.getElementById("bomInput6").value,
        bomInput7: document.getElementById("bomInput7").value,
        bomInput8: document.getElementById("bomInput8").value,
        bomInput9: document.getElementById("bomInput9").value,
      };
      localStorage.setItem(STORAGE_KEY_BOM, JSON.stringify(data));
      logInfo("BoM入力を保存しました。（次回起動時に自動復元）");
    }

    function loadBomInputsFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_BOM);
      if (!s) return;
      try {
        const data = JSON.parse(s);
        if (data.bomInput1 !== undefined) document.getElementById("bomInput1").value = data.bomInput1;
        if (data.bomInput2 !== undefined) document.getElementById("bomInput2").value = data.bomInput2;
        if (data.bomInput3 !== undefined) document.getElementById("bomInput3").value = data.bomInput3;
        if (data.bomInput4 !== undefined) document.getElementById("bomInput4").value = data.bomInput4;
        if (data.bomInput5 !== undefined) document.getElementById("bomInput5").value = data.bomInput5;
        if (data.bomInput6 !== undefined) document.getElementById("bomInput6").value = data.bomInput6;
        if (data.bomInput7 !== undefined) document.getElementById("bomInput7").value = data.bomInput7;
        if (data.bomInput8 !== undefined) document.getElementById("bomInput8").value = data.bomInput8;
        if (data.bomInput9 !== undefined) document.getElementById("bomInput9").value = data.bomInput9;
      } catch(e) {
        console.warn("BoM入力の復元に失敗:", e);
      }
    }

    function clearBomInputsStorage() {
      localStorage.removeItem(STORAGE_KEY_BOM);
      logInfo("保存されていた BoM 入力を削除しました。（テキスト内容はそのまま）");
    }

    /* ============ Config（係数＋嵐＋境界＋kL1） ============ */
    function getConfigFromUI() {
      return {
        kGlobal:     parseFloat(document.getElementById("cfg_kGlobal").value)  || 0.55,
        wF107:       parseFloat(document.getElementById("cfg_wF107").value)    || 0.004,
        wAp:         parseFloat(document.getElementById("cfg_wAp").value)      || 0.01,
        wDst:        parseFloat(document.getElementById("cfg_wDst").value)     || -0.002,
        pX:          parseFloat(document.getElementById("cfg_pX").value)       || 0.2,
        latShape:    parseFloat(document.getElementById("cfg_latShape").value) || 0.45,
        latHighCut:  parseFloat(document.getElementById("cfg_latHighCut").value) || 1.05,
        betaFlare:   parseFloat(document.getElementById("cfg_betaFlare").value)|| 0.5,
        kX:          parseFloat(document.getElementById("cfg_kX").value)       || 1.0,
        kM:          parseFloat(document.getElementById("cfg_kM").value)       || 0.3,
        biasThresh:  parseFloat(document.getElementById("cfg_biasThresh").value)|| 15,
        suggestGain: parseFloat(document.getElementById("cfg_suggestGain").value)|| 0.5,
        dayEdgeCosWidth: parseFloat(document.getElementById("cfg_dayEdgeCosWidth").value) || 0.2,
        kL1:         parseFloat(document.getElementById("cfg_kL1").value)      || 0.16,
        // 嵐パラメータ（イベント用包絡）
        stormStartH: parseFloat(document.getElementById("stormStartH").value) || 0,
        stormDurH:   parseFloat(document.getElementById("stormDurH").value)   || 0,
        stormKp:     parseFloat(document.getElementById("stormKp").value)     || 0,
        ionoDelayH:  parseFloat(document.getElementById("ionoDelayH").value)  || 0
      };
    }

    function applyConfigToUI(cfg) {
      document.getElementById("cfg_kGlobal").value     = cfg.kGlobal;
      document.getElementById("cfg_wF107").value       = cfg.wF107;
      document.getElementById("cfg_wAp").value         = cfg.wAp;
      document.getElementById("cfg_wDst").value        = cfg.wDst;
      document.getElementById("cfg_pX").value          = cfg.pX;
      document.getElementById("cfg_latShape").value    = cfg.latShape;
      document.getElementById("cfg_latHighCut").value  = cfg.latHighCut;
      document.getElementById("cfg_betaFlare").value   = cfg.betaFlare;
      document.getElementById("cfg_kX").value          = cfg.kX;
      document.getElementById("cfg_kM").value          = cfg.kM;
      document.getElementById("cfg_biasThresh").value  = cfg.biasThresh;
      document.getElementById("cfg_suggestGain").value = cfg.suggestGain;
      document.getElementById("cfg_dayEdgeCosWidth").value = cfg.dayEdgeCosWidth;
      document.getElementById("cfg_kL1").value         = cfg.kL1;

      document.getElementById("stormStartH").value = cfg.stormStartH || 0;
      document.getElementById("stormDurH").value   = cfg.stormDurH   || 0;
      document.getElementById("stormKp").value     = cfg.stormKp     || 0;
      document.getElementById("ionoDelayH").value  = cfg.ionoDelayH  || 0;

      updateFormulaText(); // 係数が変わったら式も更新
    }

    function saveConfig() {
      const cfg = getConfigFromUI();
      localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(cfg));
      logInfo("係数設定を保存しました。");
      updateFormulaText();
    }

    function loadConfig(apply) {
      const s = localStorage.getItem(STORAGE_KEY_CONFIG);
      if (!s) {
        if (apply) logInfo("保存された係数がありません。初期値を使用。");
        return null;
      }
      try {
        const cfg = JSON.parse(s);
        if (apply) applyConfigToUI(cfg);
        return cfg;
      } catch(e) {
        console.warn("Configの復元に失敗:", e);
        return null;
      }
    }

    /* ============ 検証マップ色設定 ============ */
    function applyVerifyColorScale() {
      const limits = [
        parseFloat(document.getElementById("vLimit1").value) || 10,
        parseFloat(document.getElementById("vLimit2").value) || 20,
        parseFloat(document.getElementById("vLimit3").value) || 30,
        parseFloat(document.getElementById("vLimit4").value) || 999
      ];
      const cols = [
        document.getElementById("vColor1").value || "#00ff00",
        document.getElementById("vColor2").value || "#ffff00",
        document.getElementById("vColor3").value || "#ff9900",
        document.getElementById("vColor4").value || "#ff0000"
      ];
      gVerifyColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_VCOL, JSON.stringify(gVerifyColorScale));
      logInfo("検証色スケールを保存しました。");
      drawVerifyMap(lastVerifyResult);
    }

    function resetVerifyColorScale() {
      gVerifyColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 20,  color: "#ffff00" },
        { limit: 30,  color: "#ff9900" },
        { limit: 999, color: "#ff0000" }
      ];
      document.getElementById("vLimit1").value = 10;
      document.getElementById("vLimit2").value = 20;
      document.getElementById("vLimit3").value = 30;
      document.getElementById("vLimit4").value = 999;
      document.getElementById("vColor1").value = "#00ff00";
      document.getElementById("vColor2").value = "#ffff00";
      document.getElementById("vColor3").value = "#ff9900";
      document.getElementById("vColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_VCOL, JSON.stringify(gVerifyColorScale));
      drawVerifyMap(lastVerifyResult);
    }

    function loadVerifyColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_VCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gVerifyColorScale = arr;
        document.getElementById("vLimit1").value = arr[0].limit;
        document.getElementById("vLimit2").value = arr[1].limit;
        document.getElementById("vLimit3").value = arr[2].limit;
        document.getElementById("vLimit4").value = arr[3].limit;
        document.getElementById("vColor1").value = arr[0].color;
        document.getElementById("vColor2").value = arr[1].color;
        document.getElementById("vColor3").value = arr[2].color;
        document.getElementById("vColor4").value = arr[3].color;
      } catch(e) {
        console.warn("検証色スケール復元に失敗:", e);
      }
    }

    /* ============ TEC / GPS カラーマップ設定 ============ */
    function applyTecColorScale() {
      const limits = [
        parseFloat(document.getElementById("tLimit1").value) || 10,
        parseFloat(document.getElementById("tLimit2").value) || 30,
        parseFloat(document.getElementById("tLimit3").value) || 60,
        parseFloat(document.getElementById("tLimit4").value) || 120
      ];
      const cols = [
        document.getElementById("tColor1").value || "#00ff00",
        document.getElementById("tColor2").value || "#ffff00",
        document.getElementById("tColor3").value || "#ff9900",
        document.getElementById("tColor4").value || "#ff0000"
      ];
      gTecColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
           localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      logInfo("TECカラースケールを保存しました。");
      updateTecLegend();
      drawTecOverlay();
    }

    function resetTecColorScale() {
      gTecColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 30,  color: "#ffff00" },
        { limit: 60,  color: "#ff9900" },
        { limit: 120, color: "#ff0000" }
      ];
      document.getElementById("tLimit1").value = 10;
      document.getElementById("tLimit2").value = 30;
      document.getElementById("tLimit3").value = 60;
      document.getElementById("tLimit4").value = 120;
      document.getElementById("tColor1").value = "#00ff00";
      document.getElementById("tColor2").value = "#ffff00";
      document.getElementById("tColor3").value = "#ff9900";
      document.getElementById("tColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      updateTecLegend();
      drawTecOverlay();
    }

    function loadTecColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_TCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gTecColorScale = arr;
        document.getElementById("tLimit1").value = arr[0].limit;
        document.getElementById("tLimit2").value = arr[1].limit;
        document.getElementById("tLimit3").value = arr[2].limit;
        document.getElementById("tLimit4").value = arr[3].limit;
        document.getElementById("tColor1").value = arr[0].color;
        document.getElementById("tColor2").value = arr[1].color;
        document.getElementById("tColor3").value = arr[2].color;
        document.getElementById("tColor4").value = arr[3].color;
      } catch(e) {
        console.warn("TECカラースケール復元に失敗:", e);
      }
    }

    /* ============ GPS L1 カラーマップ設定 ============ */
    function applyGpsColorScale() {
      const limits = [
        parseFloat(document.getElementById("gLimit1").value) || 5,
        parseFloat(document.getElementById("gLimit2").value) || 10,
        parseFloat(document.getElementById("gLimit3").value) || 20,
        parseFloat(document.getElementById("gLimit4").value) || 40
      ];
      const cols = [
        document.getElementById("gColor1").value || "#00ff00",
        document.getElementById("gColor2").value || "#ffff00",
        document.getElementById("gColor3").value || "#ff9900",
        document.getElementById("gColor4").value || "#ff0000"
      ];
      gGpsColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      logInfo("GPS色スケールを保存しました。");
      updateTecLegend();
      drawTecOverlay();
    }

    function resetGpsColorScale() {
      gGpsColorScale = [
        { limit: 5,  color: "#00ff00" },
        { limit: 10, color: "#ffff00" },
        { limit: 20, color: "#ff9900" },
        { limit: 40, color: "#ff0000" }
      ];
      document.getElementById("gLimit1").value = 5;
      document.getElementById("gLimit2").value = 10;
      document.getElementById("gLimit3").value = 20;
      document.getElementById("gLimit4").value = 40;
      document.getElementById("gColor1").value = "#00ff00";
      document.getElementById("gColor2").value = "#ffff00";
      document.getElementById("gColor3").value = "#ff9900";
      document.getElementById("gColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      updateTecLegend();
      drawTecOverlay();
    }

    function loadGpsColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_GCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gGpsColorScale = arr;
        document.getElementById("gLimit1").value = arr[0].limit;
        document.getElementById("gLimit2").value = arr[1].limit;
        document.getElementById("gLimit3").value = arr[2].limit;
        document.getElementById("gLimit4").value = arr[3].limit;
        document.getElementById("gColor1").value = arr[0].color;
        document.getElementById("gColor2").value = arr[1].color;
        document.getElementById("gColor3").value = arr[2].color;
        document.getElementById("gColor4").value = arr[3].color;
      } catch(e) {
        console.warn("GPS色スケール復元に失敗:", e);
      }
    }

    /* ============ 共通：カラースケールから色取得 ============ */
    function getColorFromScale(value, scaleArr) {
      if (!scaleArr || !scaleArr.length) return "#000000";
      for (let i=0;i<scaleArr.length;i++) {
        if (value <= scaleArr[i].limit) return scaleArr[i].color;
      }
      return scaleArr[scaleArr.length-1].color;
    }

    /* ============ NOAA F10.7 / Kp テキストパーサ ============ */
    function parseNoaaF107Text() {
      gF107Series = [];
      const txt = document.getElementById("noaaF107Text").value;
      if (!txt.trim()) return;
      const lines = txt.split(/\r?\n/);
      for (const ln of lines) {
        // 形式例: "2025 11 29  145.2"
        let m = ln.match(/(\d{4})\s+(\d{1,2})\s+(\d{1,2})\s+([0-9.]+)/);
        if (!m) {
          // 形式例: "2025-11-29 145.2"
          m = ln.match(/(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+([0-9.]+)/);
        }
        if (m) {
          const y  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const d  = parseInt(m[3],10);
          const v  = parseFloat(m[4]);
          if (!isNaN(v)) {
            const t = new Date(Date.UTC(y, mo-1, d, 12, 0, 0)); // 正午を代表時刻とする
            gF107Series.push({ time: t, value: v });
          }
        }
      }
      gF107Series.sort((a,b)=>a.time-b.time);
      logInfo(`F10.7テキストから ${gF107Series.length} 点を読取りました。`);
    }

    function getF107ForTime(tUTC) {
      const base = parseFloat(document.getElementById("inpF107").value) || 150;
      if (!gF107Series.length || !(tUTC instanceof Date)) return base;
      const tMs = tUTC.getTime();
      let best = gF107Series[0];
      let bestDiff = Math.abs(tMs - best.time.getTime());
      for (const e of gF107Series) {
        const diff = Math.abs(tMs - e.time.getTime());
        if (diff < bestDiff) {
          bestDiff = diff;
          best = e;
        }
      }
      return best.value;
    }

    function parseNoaaKpText() {
      gKpSeries = [];
      const txt = document.getElementById("noaaKpText").value;
      if (!txt.trim()) return;
      const lines = txt.split(/\r?\n/);
      for (const ln of lines) {
        // 簡易形式: "2025-11-29 03 4.67"
        let m = ln.match(/(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})\s+(\d{1,2})\s+([0-9.]+)/);
        if (!m) {
          // 別形式: "2025 11 29 03 4.67"
          m = ln.match(/(\d{4})\s+(\d{1,2})\s+(\d{1,2})\s+(\d{1,2})\s+([0-9.]+)/);
        }
        if (m) {
          const y  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const d  = parseInt(m[3],10);
          const hh = parseInt(m[4],10);
          const v  = parseFloat(m[5]);
          if (!isNaN(v)) {
            const t = new Date(Date.UTC(y, mo-1, d, hh, 0, 0));
            gKpSeries.push({ time: t, kp: v });
          }
        }
      }
      gKpSeries.sort((a,b)=>a.time-b.time);
      logInfo(`Kpテキストから ${gKpSeries.length} 点を読取りました。`);
    }

    function getKpForTime(tUTC) {
      if (!gKpSeries.length || !(tUTC instanceof Date)) return 0;
      const tMs = tUTC.getTime();
      let best = gKpSeries[0];
      let bestDiff = Math.abs(tMs - best.time.getTime());
      for (const e of gKpSeries) {
        const diff = Math.abs(tMs - e.time.getTime());
        if (diff < bestDiff) {
          bestDiff = diff;
          best = e;
        }
      }
      return best.kp;
    }

    /* ============ Deep Flare Net 9領域 → 有効確率 ============ */
    function getDeepFlareEffectiveProbabilities() {
      let sumPX = 0, sumPM = 0, cnt = 0;
      for (let i=1;i<=9;i++) {
        const use = document.getElementById("fu"+i).checked;
        if (!use) continue;
        const px = parseFloat(document.getElementById("fx"+i).value) || 0;
        const pm = parseFloat(document.getElementById("fm"+i).value) || 0;
        sumPX += px;
        sumPM += pm;
        cnt++;
      }
      if (!cnt) return { PX: 0, PM: 0 };
      return { PX: sumPX/cnt, PM: sumPM/cnt };
    }

    /* ============ 季節・ローカル時刻・緯度依存関数 ============ */
    function getDayOfYear(date) {
      const start = Date.UTC(date.getUTCFullYear(), 0, 1);
      const t = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      return Math.floor((t - start) / 86400000) + 1;
    }

    function getSeasonForTime(date) {
      if (!(date instanceof Date)) return "spring";
      const doy = getDayOfYear(date);
      // ざっくり: 冬(355–79), 春(80–171), 夏(172–263), 秋(264–354)
      if (doy >= 80 && doy <= 171) return "spring";
      if (doy >= 172 && doy <= 263) return "summer";
      if (doy >= 264 && doy <= 354) return "autumn";
      return "winter";
    }

    function getLocalTimeHours(dateUTC, lonDeg) {
      const utcH = dateUTC.getUTCHours() + dateUTC.getUTCMinutes()/60 + dateUTC.getUTCSeconds()/3600;
      let lt = utcH + lonDeg/15;
      lt = lt % 24;
      if (lt < 0) lt += 24;
      return lt;
    }

    function getDayFactor(latDeg, ltHours, cfg) {
      // シンプルに LT=12 で最大, LT=0/24 で最小になる cos カーブ
      const w = 2*Math.PI*(ltHours-12)/24;
      let f = 0.5 + 0.5*Math.cos(w); // 0–1
      // 極夜の影響を少しだけ。高緯度は夜に減衰しやすい。
      const absLat = Math.abs(latDeg);
      if (absLat > 60) {
        const fLat = (absLat-60)/30; // 60→90°
        f *= (1 - 0.5*fLat);         // 0.5 まで減衰
      }
      // pX を「日中の尖り具合」として少し効かせる
      const pX = cfg.pX || 0.2;
      f = Math.pow(f, 1/(1+pX));
      return clamp(f, 0.1, 1.5);
    }

    function getLatWeight(latDeg, cfg) {
      const absLat = Math.abs(latDeg);
      const latShape = cfg.latShape || 0.45;
      const latHighCut = cfg.latHighCut || 1.05;

      // 赤道異常風のイメージ: ±15°付近を少し持ち上げる
      const phi = (absLat-15)/20;
      let W = 1 + latShape * Math.exp(-phi*phi);

      // 高緯度側のカット
      if (absLat > 60) {
        const f = (absLat-60)/30; // 60→90° で 0→1
        W *= (1 - f*(1-latHighCut));
      }
      return clamp(W, 0.2, 2.0);
    }

    /* ============ Mukhtarov rTEC モデル（枠組み） ============ */
    // ★係数テーブルは論文の p_nm(Season) を手入力で入れる前提。
    const MukP = {
      spring: { p: [
        [0,0,0,0,0], // n=0, m=0..4
        [0,0,0,0,0], // n=1
        [0,0,0,0,0], // n=2
      ]},
      summer: { p: [
        [0,0,0,0,0],
        [0,0,0,0,0],
        [0,0,0,0,0],
      ]},
      autumn: { p: [
        [0,0,0,0,0],
        [0,0,0,0,0],
        [0,0,0,0,0],
      ]},
      winter: { p: [
        [0,0,0,0,0],
        [0,0,0,0,0],
        [0,0,0,0,0],
      ]}
    };

    // 基底関数 f_m(φ, LT) の素直な例。
    // （実際の係数・形は Mukhtarov 本文の定義に合わせて編集してください）
    function muk_fm(m, latDeg, ltHours) {
      const phi = latDeg * Math.PI/180;
      const omega = 2*Math.PI*ltHours/24;
      switch(m) {
        case 0: return 1.0;
        case 1: return Math.cos(omega);
        case 2: return Math.sin(omega);
        case 3: return Math.cos(2*phi);
        case 4: return Math.sin(2*phi);
        default: return 0;
      }
    }

    // rTEC(φ,LT,Kp,Season) = Σ_n Σ_m p_nm(Season) f_m(φ,LT) Kp^n
    function rTEC_Mukhtarov(latDeg, ltHours, kp, seasonName) {
      const s = MukP[seasonName] || MukP.spring;
      const p = s.p;
      const kpPow = [1, kp, kp*kp];
      let sum = 0;
      for (let n=0;n<=2;n++) {
        for (let m=0;m<=4;m++) {
          const pnm = p[n][m] || 0;
          if (pnm === 0) continue;
          sum += pnm * muk_fm(m, latDeg, ltHours) * kpPow[n];
        }
      }
      // rTEC は「相対変化」として利用。過大な発散を防ぐためクリップ。
      return clamp(sum, -0.9, 5.0);
    }

    function getStormScale(latDeg, lonDeg, tUTC, cfg) {
      if (!gForecastStart || !(tUTC instanceof Date)) {
        const seasonName = getSeasonForTime(tUTC || new Date());
        const lt = getLocalTimeHours(tUTC || new Date(), lonDeg);
        const kp = getKpForTime(tUTC || new Date());
        const r = rTEC_Mukhtarov(latDeg, lt, kp, seasonName);
        return 1 + r;
      }

      const seasonName = getSeasonForTime(tUTC);
      const lt = getLocalTimeHours(tUTC, lonDeg);
      let kp = getKpForTime(tUTC);

      // イベント包絡 (CME / HSS)
      const relH = (tUTC.getTime() - gForecastStart.getTime())/3600000;
      if (cfg.stormDurH > 0) {
        const t0 = cfg.stormStartH || 0;
        const t1 = t0 + cfg.stormDurH;
        if (relH >= t0 && relH <= t1) {
          kp += cfg.stormKp || 0;
        }
      }

      const r = rTEC_Mukhtarov(latDeg, lt, kp, seasonName);
      return 1 + r;
    }

    /* ============ 太陽活動スケール・フレアスケール ============ */
    function computeSolarScale(F107, Ap, Dst, Xray, cfg) {
      const wF107 = cfg.wF107 || 0.004;
      const wAp   = cfg.wAp   || 0.01;
      const wDst  = cfg.wDst  || -0.002;

      const dF   = (F107-150)*wF107;
      const dAp  = (Ap-10)*wAp;
      const dDst = (Dst+20)*wDst;
      // X線は 10^(-5) 付近で1程度の寄与になるように
      const xTerm = Xray > 0 ? Math.log10(Xray) + 6 : 0;

      let S = 1 + dF + dAp + dDst + 0.1*xTerm;
      return clamp(S, 0.3, 3.0);
    }

    function computeFlareScale(cfg) {
      const { PX, PM } = getDeepFlareEffectiveProbabilities(); // [%]
      const beta  = cfg.betaFlare || 0.5;
      const kX    = cfg.kX || 1.0;
      const kM    = cfg.kM || 0.3;
      const fx = (PX/100) * kX;
      const fm = (PM/100) * kM;
      const S  = 1 + beta * (fx + fm);
      return clamp(S, 0.5, 3.0);
    }

    /* ============ Leaflet 初期化 & オーバーレイ ============ */
    function initMap() {
      map = L.map("tecMap", {
        worldCopyJump: true
      }).setView([0, 0], 2);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 7,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);

      tecCanvas = document.createElement("canvas");
      tecCanvas.className = "tec-canvas-overlay";
      document.getElementById("tecMap").appendChild(tecCanvas);
      tecCtx = tecCanvas.getContext("2d");

      map.on("move zoom", onMapViewChanged);
      map.on("resize", onMapViewChanged);
      map.on("click", onMapClick);

      tecLegendControl = L.control({ position: "bottomright" });
      tecLegendControl.onAdd = function() {
        const div = L.DomUtil.create("div", "leaflet-control tec-legend");
        div.innerHTML = `
          <div class="tec-legend-title">TEC [TECU]</div>
          <div class="tec-legend-bar" id="tecLegendBar"></div>
          <div class="tec-legend-labels"><span>Low</span><span>High</span></div>
        `;
        return div;
      };
      tecLegendControl.addTo(map);

      updateTecLegend();
      resizeTecCanvas();
    }

    function resizeTecCanvas() {
      const mapDiv = document.getElementById("tecMap");
      if (!mapDiv || !tecCanvas) return;
      const w = mapDiv.clientWidth;
      const h = mapDiv.clientHeight;
      if (tecCanvas.width !== w || tecCanvas.height !== h) {
        tecCanvas.width = w;
        tecCanvas.height = h;
      }
    }

    function onMapViewChanged() {
      resizeTecCanvas();
      drawTecOverlay();
    }

    function updateTecLegend() {
      const bar = document.getElementById("tecLegendBar");
      if (!bar) return;
      const titleEl = document.querySelector(".tec-legend-title");
      let scale, unit;
      if (mapMode === "gps") {
        scale = gGpsColorScale;
        unit = "GPS L1誤差 [m]";
      } else {
        scale = gTecColorScale;
        unit = "TEC [TECU]";
      }
      if (titleEl) titleEl.textContent = unit;

      if (!scale || !scale.length) {
        bar.style.background = "#000";
        return;
      }
      const max = scale[scale.length-1].limit || 1;
      const stops = [];
      for (let i=0;i<scale.length;i++) {
        const c = scale[i].color;
        const p = (scale[i].limit / max) * 100;
        const prevP = i === 0 ? 0 : (scale[i-1].limit / max)*100;
        if (i === 0) {
          stops.push(`${c} 0%`, `${c} ${p}%`);
        } else {
          stops.push(`${c} ${prevP}%`, `${c} ${p}%`);
        }
      }
      bar.style.background = `linear-gradient(to top, ${stops.join(",")})`;
    }

    function drawTecOverlay() {
      if (!tecCtx || !map || !gGrid || !gForecastFrames.length) {
        if (tecCtx) {
          tecCtx.clearRect(0,0,tecCanvas.width,tecCanvas.height);
        }
        return;
      }
      const frame = gForecastFrames[currentStepIndex];
      if (!frame) return;

      const cfg = getConfigFromUI();
      resizeTecCanvas();
      tecCtx.clearRect(0,0,tecCanvas.width,tecCanvas.height);
      tecCtx.globalAlpha = tecAlpha;

      const latArr = gGrid.latArr;
      const lonArr = gGrid.lonArr;
      const nLat = gGrid.nLat;
      const nLon = gGrid.nLon;

      const latStep = (nLat>1) ? (latArr[1]-latArr[0]) : 2;
      const lonStep = (nLon>1) ? (lonArr[1]-lonArr[0]) : 5;

      for (let i=0;i<nLat;i++) {
        for (let j=0;j<nLon;j++) {
          const TEC = frame[i][j];
          if (!isFinite(TEC)) continue;
          let value = TEC;
          if (mapMode === "gps") {
            value = TEC * (cfg.kL1 || 0.16);
          }
          const color = getColorFromScale(value, mapMode==="gps" ? gGpsColorScale : gTecColorScale);
          tecCtx.fillStyle = color;

          const lat = latArr[i];
          const lon = lonArr[j];
          const lat0 = lat - latStep/2;
          const lat1 = lat + latStep/2;
          const lon0 = lon - lonStep/2;
          const lon1 = lon + lonStep/2;

          const p0 = map.latLngToContainerPoint([lat0, lon0]);
          const p1 = map.latLngToContainerPoint([lat1, lon1]);
          const x = Math.min(p0.x, p1.x);
          const y = Math.min(p0.y, p1.y);
          const w = Math.abs(p1.x - p0.x);
          const h = Math.abs(p1.y - p0.y);

          tecCtx.fillRect(x, y, w, h);
        }
      }
    }

    function onMapClick(e) {
      if (!gGrid || !gForecastFrames.length) return;
      const lat = e.latlng.lat;
      const lon = e.latlng.lng;
      const idx = findNearestGridIndex(lat, lon);
      if (!idx) return;
      const frame = gForecastFrames[currentStepIndex];
      const TEC = frame[idx.iLat][idx.iLon];
      const cfg = getConfigFromUI();
      const gps = TEC * (cfg.kL1 || 0.16);
      const timeStr = gForecastTimes[currentStepIndex]
        ? gForecastTimes[currentStepIndex].toISOString()
        : `t=${currentStepIndex}h`;

      const msg =
        `Time (UTC) : ${timeStr}\n`+
        `lat, lon   : ${gGrid.latArr[idx.iLat].toFixed(1)}°, ${gGrid.lonArr[idx.iLon].toFixed(1)}°\n`+
        `TEC        : ${TEC.toFixed(2)} TECU\n`+
        `GPS L1 err : ${gps.toFixed(2)} m\n`+
        `※色は現在の表示モード(${mapMode==="tec"?"TEC":"GPS L1誤差"})に応じたスケールで描画。`;
      document.getElementById("pointInfo").textContent = msg;
    }

    function findNearestGridIndex(lat, lon) {
      if (!gGrid) return null;
      const latArr = gGrid.latArr;
      const lonArr = gGrid.lonArr;
      let bestI = 0, bestJ = 0;
      let bestD = Infinity;
      for (let i=0;i<latArr.length;i++) {
        for (let j=0;j<lonArr.length;j++) {
          const dLat = latArr[i] - lat;
          // 経度は worldCopyJump しているので 360°周期を考慮
          let dLon = lonArr[j] - lon;
          while (dLon > 180) dLon -= 360;
          while (dLon < -180) dLon += 360;
          const d2 = dLat*dLat + dLon*dLon;
          if (d2 < bestD) {
            bestD = d2;
            bestI = i;
            bestJ = j;
          }
        }
      }
      return { iLat: bestI, iLon: bestJ };
    }

    /* ============ 時間スライダー関連 ============ */
    function updateTimeLabel() {
      const label = document.getElementById("timeLabel");
      const slider = document.getElementById("timeSlider");
      const idx = parseInt(slider.value,10) || 0;
      currentStepIndex = idx;
      if (gForecastTimes && gForecastTimes[idx] instanceof Date) {
        const t = gForecastTimes[idx];
        label.textContent = `UTC ${t.getUTCFullYear()}-${String(t.getUTCMonth()+1).padStart(2,"0")}-${String(t.getUTCDate()).padStart(2,"0")} `+
                            `${String(t.getUTCHours()).padStart(2,"0")}:00`;
      } else {
        label.textContent = `t = ${idx} h`;
      }
    }

    function onSliderChange() {
      updateTimeLabel();
      drawTecOverlay();
    }

    function onTecAlphaChange() {
      tecAlpha = parseFloat(document.getElementById("tecAlpha").value) || 0.8;
      drawTecOverlay();
    }

    function changeMapMode() {
      const sel = document.getElementById("mapModeSelect");
      mapMode = sel.value;
      updateTecLegend();
      drawTecOverlay();
    }

    /* ============ 地域フォーカス ============ */
    function focusRegion(name) {
      let latMin, latMax, lonMin, lonMax;
      switch(name) {
        case "japan":
          latMin = 20;  latMax = 50;
          lonMin = 120; lonMax = 150;
          break;
        case "northAmerica":
          latMin = 10;  latMax = 70;
          lonMin = -140; lonMax = -60;
          break;
        case "southAmerica":
          latMin = -60; latMax = 15;
          lonMin = -90; lonMax = -30;
          break;
        case "europe":
          latMin = 30;  latMax = 70;
          lonMin = -10; lonMax = 40;
          break;
        case "africa":
          latMin = -40; latMax = 35;
          lonMin = -20; lonMax = 50;
          break;
        case "australia":
          latMin = -50; latMax = -10;
          lonMin = 110; lonMax = 160;
          break;
        default:
          resetFocus();
          return;
      }
      document.getElementById("focusLatMin").value = latMin;
      document.getElementById("focusLatMax").value = latMax;
      document.getElementById("focusLonMin").value = lonMin;
      document.getElementById("focusLonMax").value = lonMax;
      applyManualFocus();
    }

    function applyManualFocus() {
      if (!map) return;
      const latMin = parseFloat(document.getElementById("focusLatMin").value) || -60;
      const latMax = parseFloat(document.getElementById("focusLatMax").value) || 60;
      const lonMin = parseFloat(document.getElementById("focusLonMin").value) || -180;
      const lonMax = parseFloat(document.getElementById("focusLonMax").value) || 180;
      currentFocus = { latMin, latMax, lonMin, lonMax };
      const sw = L.latLng(latMin, lonMin);
      const ne = L.latLng(latMax, lonMax);
      map.fitBounds(L.latLngBounds(sw, ne));
    }

    function resetFocus() {
      currentFocus = null;
      if (!map) return;
      map.fitWorld();
    }

    /* ============ 検証 3×3 マップ ============ */
    function runVerification() {
      if (!gForecastFrames.length || !gGrid || !gForecastStart) {
        alert("先にTEC予報を計算してください。");
        return;
      }

      const texts = [
        document.getElementById("verifyInput1").value,
        document.getElementById("verifyInput2").value,
        document.getElementById("verifyInput3").value,
        document.getElementById("verifyInput4").value
      ].filter(t => t.trim().length>0);

      if (!texts.length) {
        alert("検証用 BoM テキストが入力されていません。");
        return;
      }

      const regions = []; // [3][3] { mapeSum, biasSum, count }
      for (let i=0;i<3;i++) {
        regions[i] = [];
        for (let j=0;j<3;j++) {
          regions[i][j] = { mapeSum:0, biasSum:0, count:0 };
        }
      }

      for (const txt of texts) {
        try {
          const parsed = parseBoM(txt);
          const gridV = parsed.grid;
          const tV    = parsed.validTime || gForecastStart;
          const stepIndex = Math.round((tV.getTime() - gForecastStart.getTime())/3600000);
          if (stepIndex < 0 || stepIndex >= gForecastFrames.length) continue;
          const frame = gForecastFrames[stepIndex];

          for (let i=0;i<gGrid.nLat;i++) {
            for (let j=0;j<gGrid.nLon;j++) {
              const obs = gridV[i][j];
              const fv  = frame[i][j];
              if (!isFinite(obs) || obs <= 0) continue;
              const err = fv - obs;
              const mape = Math.abs(err)/obs*100;
              const bias = err/obs*100;

              const lat = gGrid.latArr[i];
              const lon = gGrid.lonArr[j];
              const reg = getRegionIndex3x3(lat, lon);
              const r = regions[reg.i][reg.j];
              r.mapeSum += mape;
              r.biasSum += bias;
              r.count++;
            }
          }
        } catch(e) {
          console.warn("検証BoMのパース中にエラー:", e);
        }
      }

      const result = { cells: regions };
      lastVerifyResult = result;
      drawVerifyMap(result);
      updateVerifyReport(result);
      logInfo("検証を実行しました。");
    }

    function getRegionIndex3x3(lat, lon) {
      // 緯度: 南(-90〜-30) 中(-30〜30) 北(30〜90)
      // 経度: 西(-180〜-60) 中(-60〜60) 東(60〜180)
      const absLat = lat;
      let i;
      if (absLat < -30) i = 2;       // 南
      else if (absLat <= 30) i = 1;  // 中
      else i = 0;                    // 北

      let j;
      if (lon < -60) j = 0;          // 西
      else if (lon <= 60) j = 1;     // 中
      else j = 2;                    // 東
      return { i, j };
    }

    function drawVerifyMap(result) {
      const canvas = document.getElementById("verifyCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0,0,canvas.width,canvas.height);

      if (!result) {
        ctx.fillStyle = "#888";
        ctx.font = "10px system-ui";
        ctx.fillText("まだ検証されていません。", 10, 20);
        return;
      }

      const W = canvas.width;
      const H = canvas.height;
      const cellW = W/3;
      const cellH = H/3;

      ctx.font = "10px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      for (let i=0;i<3;i++) {
        for (let j=0;j<3;j++) {
          const r = result.cells[i][j];
          const cnt = r.count || 0;
          let mape = 0, bias = 0;
          if (cnt>0) {
            mape = r.mapeSum / cnt;
            bias = r.biasSum / cnt;
          }
          const x = j*cellW;
          const y = i*cellH;

          const col = getColorFromScale(mape, gVerifyColorScale);
          ctx.fillStyle = col;
          ctx.fillRect(x+1, y+1, cellW-2, cellH-2);

          ctx.strokeStyle = "#111";
          ctx.strokeRect(x+1, y+1, cellW-2, cellH-2);

          ctx.fillStyle = "#000";
          ctx.fillText(`${mape.toFixed(1)}%`, x+cellW/2, y+cellH/2-8);
          ctx.fillText(`Bias ${bias>=0?"+":""}${bias.toFixed(1)}%`, x+cellW/2, y+cellH/2+8);
        }
      }
    }

    function updateVerifyReport(result) {
      const pre = document.getElementById("verifyReport");
      if (!result) {
        pre.textContent = "(まだ検証されていません)";
        return;
      }
      const cfg = getConfigFromUI();
      const th = cfg.biasThresh || 15;
      const gain = cfg.suggestGain || 0.5;

      let text = "";
      const nameRow = ["北帯", "中緯度", "南帯"];
      const nameCol = ["西側", "中央", "東側"];

      for (let i=0;i<3;i++) {
        for (let j=0;j<3;j++) {
          const r = result.cells[i][j];
          if (!r.count) continue;
          const mape = r.mapeSum/r.count;
          const bias = r.biasSum/r.count;
          text += `[${nameRow[i]} × ${nameCol[j]}] N=${r.count}\n`;
          text += `  MAPE: ${mape.toFixed(1)}%, Bias: ${bias.toFixed(1)}%\n`;
          if (Math.abs(bias) > th) {
            const sign = bias>0 ? -1 : +1;
            const deltaK = sign * gain * Math.abs(bias)/100;
            text += `  → この帯はモデルが${bias>0?"過大":"過小"}傾向。\n`;
            text += `     kGlobal を ${deltaK>0?"+":""}${deltaK.toFixed(3)} 方向で調整する候補。\n`;
          }
          text += "\n";
        }
      }
      if (!text) text = "有効な検証点が十分ではありません。";

      pre.textContent = text;
    }

    function clearVerification() {
      lastVerifyResult = null;
      drawVerifyMap(null);
      document.getElementById("verifyReport").textContent = "(まだ検証されていません)";
    }

    /* ============ 予報計算 runForecast ============ */
    function runForecast() {
      try {
        logInfo("予報計算を開始します…");

        // NOAA テキストをパース（あれば）
        parseNoaaF107Text();
        parseNoaaKpText();

        // BoM 予報用 9枚をパース
        const bomTexts = [
          document.getElementById("bomInput1").value,
          document.getElementById("bomInput2").value,
          document.getElementById("bomInput3").value,
          document.getElementById("bomInput4").value,
          document.getElementById("bomInput5").value,
          document.getElementById("bomInput6").value,
          document.getElementById("bomInput7").value,
          document.getElementById("bomInput8").value,
          document.getElementById("bomInput9").value
        ].filter(t => t.trim().length>0);

        if (!bomTexts.length) {
          alert("BoM TEC（予報用）テキストを少なくとも1枚入力してください。");
          return;
        }

        const bomParsed = [];
        for (const txt of bomTexts) {
          const p = parseBoM(txt);
          bomParsed.push(p);
        }

        // グリッド形状を決定（1枚目基準）
        const base = bomParsed[0];
        gGrid = {
          latArr: base.latArr,
          lonArr: base.lonArr,
          nLat: base.nLat,
          nLon: base.nLon
        };

        // 代表観測時刻: 最も古い VALID DATE/TIME を t0 に
        let t0 = base.validTime || new Date();
        for (const b of bomParsed) {
          if (b.validTime && b.validTime < t0) t0 = b.validTime;
        }
        gForecastStart = t0;

        // 基準TEC T0 を 1枚目のグリッドでとりあえず作成
        const T0 = base.grid;

        // 7日 / 1h のフレームを準備
        const nSteps = Math.round(FORECAST_HOURS * 60 / DT_MINUTES) + 1;
        gForecastFrames = new Array(nSteps);
        gForecastTimes  = new Array(nSteps);
        const dtMs = DT_MINUTES * 60 * 1000;

        const cfg = getConfigFromUI();
        const Ap  = parseFloat(document.getElementById("inpAp").value)  || 10;
        const Dst = parseFloat(document.getElementById("inpDst").value) || -20;
        const Xray= parseFloat(document.getElementById("inpXray").value)|| 1e-6;

        const flareScale = computeFlareScale(cfg);

        for (let s=0;s<nSteps;s++) {
          const t = new Date(t0.getTime() + s*dtMs);
          gForecastTimes[s] = t;

          const F107 = getF107ForTime(t);
          const S_solar = computeSolarScale(F107, Ap, Dst, Xray, cfg);

          const frame = new Array(gGrid.nLat);
          for (let i=0;i<gGrid.nLat;i++) {
            frame[i] = new Array(gGrid.nLon);
            const lat = gGrid.latArr[i];
            for (let j=0;j<gGrid.nLon;j++) {
              const lon = gGrid.lonArr[j];
              const TEC0 = T0[i][j];

              const lt = getLocalTimeHours(t, lon);
              const fDay = getDayFactor(lat, lt, cfg);
              const Wlat = getLatWeight(lat, cfg);
              const Sstorm = getStormScale(lat, lon, t, cfg);

              let TEC = TEC0;
              TEC *= cfg.kGlobal || 0.55;
              TEC *= fDay;
              TEC *= Wlat;
              TEC *= S_solar;
              TEC *= flareScale;
              TEC *= Sstorm;

              frame[i][j] = Math.max(0, TEC);
            }
          }
          gForecastFrames[s] = frame;
        }

        // スライダーを予報長に合わせて更新
        const slider = document.getElementById("timeSlider");
        slider.max = nSteps-1;
        slider.value = 0;
        currentStepIndex = 0;
        updateTimeLabel();

        drawTecOverlay();
        updateFormulaText();
        logInfo(`予報計算完了: フレーム数 = ${nSteps}, 期間 = 約 ${FORECAST_HOURS} h`);
      } catch(e) {
        console.error(e);
        alert("予報計算中にエラーが発生しました: " + e.message);
      }
    }

    /* ============ 計算式表示 ============ */
    function updateFormulaText() {
      const cfg = getConfigFromUI();
      const txt =
`TEC(t, φ, λ) = T0(φ, λ)
  × kGlobal = ${cfg.kGlobal.toFixed(3)}
  × f_day(φ, LT; pX=${cfg.pX.toFixed(3)}, dayEdgeCosWidth=${cfg.dayEdgeCosWidth.toFixed(3)})
  × W_lat(φ; latShape=${cfg.latShape.toFixed(3)}, latHighCut=${cfg.latHighCut.toFixed(3)})
  × S_solar(F10.7(t), Ap=${cfg.wAp>=0?"":"-"}…, Dst…, X-ray; wF107=${cfg.wF107.toFixed(4)}, wAp=${cfg.wAp.toFixed(3)}, wDst=${cfg.wDst.toFixed(3)})
  × S_flare(Deep Flare Net 9領域; β_flare=${cfg.betaFlare.toFixed(3)}, kX=${cfg.kX.toFixed(3)}, kM=${cfg.kM.toFixed(3)})
  × S_storm_Mukhtarov(φ, LT, Kp(t), Season; p_nm)
    = 1 + rTEC(φ,LT,Kp,Season)
    = 1 + Σ_{n=0..2} Σ_{m=0..4} p_nm(Season) f_m(φ,LT) Kp^n

GPS L1 誤差[m] = TEC[TECU] × kL1 = TEC × ${cfg.kL1.toFixed(3)}
`;
      document.getElementById("formulaText").textContent = txt;
    }

    /* ============ リセット ============ */
    function resetAll() {
      gGrid = null;
      gForecastFrames = [];
      gForecastTimes = [];
      gForecastStart = null;
      currentStepIndex = 0;
      gF107Series = [];
      gKpSeries = [];
      lastVerifyResult = null;
      const slider = document.getElementById("timeSlider");
      slider.value = 0;
      document.getElementById("timeLabel").textContent = "t = 0 h";
      drawTecOverlay();
      drawVerifyMap(null);
      document.getElementById("verifyReport").textContent = "(まだ検証されていません)";
      document.getElementById("pointInfo").textContent =
        "地図上をクリックすると、その格子点のTEC・GPS L1誤差と位置が表示されます。";
      logInfo("モデルの状態をリセットしました。（入力テキストはそのまま）");
    }

    /* ============ 初期化 ============ */
    window.addEventListener("load", () => {
      initMap();
      loadBomInputsFromStorage();
      loadVerifyColorScaleFromStorage();
      loadTecColorScaleFromStorage();
      loadGpsColorScaleFromStorage();
      loadConfig(true);
      updateTimeLabel();
      drawVerifyMap(null);
      updateFormulaText();
      logInfo("SWIFT-TEC v3 (7日版, Mukhtarov rTEC枠組み) 起動完了。");
    });
  </script>
</body>
</html>

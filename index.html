<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v3 – TEC Forecast & Verification Tool (Leaflet版)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin: 0 0 4px 0;
      letter-spacing: 0.03em;
    }
    h1 { font-size: 20px; }
    h2 { font-size: 16px; }
    h3 { font-size: 14px; }

    .page {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 430px;
      min-width: 360px;
      max-width: 480px;
      border-right: 1px solid #222b3f;
      padding: 10px;
      overflow-y: auto;
      background: radial-gradient(circle at top, #1c2740 0, #050814 55%, #050814 100%);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
      min-width: 0;
      overflow-y: auto;
    }

    .card {
      background: rgba(10, 16, 32, 0.96);
      border: 1px solid #222b3f;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 4px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .card-header span {
      font-size: 11px;
      opacity: 0.7;
    }

    textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #334;
      background: #050814;
      color: #f5f5f5;
      font-family: "Consolas","Menlo",monospace;
    }
    input[type="number"],
    input[type="text"],
    input[type="color"],
    select {
      background: #050814;
      border-radius: 4px;
      border: 1px solid #334;
      color: #f5f5f5;
      font-size: 11px;
      padding: 2px 4px;
      font-family: inherit;
    }
    input[type="checkbox"] {
      transform: scale(0.9);
    }
    label {
      font-size: 11px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-bottom: 4px;
      align-items: center;
      flex-wrap: wrap;
    }
    .row > div {
      flex: 1;
      min-width: 80px;
    }
    button {
      border-radius: 4px;
      border: 1px solid #3b82f6;
      background: #1d4ed8;
      color: #f9fafb;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary {
      border-color: #4b5563;
      background: #111827;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .small {
      font-size: 10px;
      opacity: 0.8;
    }
    pre {
      font-size: 11px;
      background: #050814;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #222b3f;
      white-space: pre-wrap;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }
    th, td {
      border: 1px solid #222b3f;
      padding: 2px 4px;
      text-align: center;
    }
    th {
      background: #111827;
    }
    .flex-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-card { flex: 0 0 auto; }
    .map-card {
      flex: 1 1 auto;
      min-height: 55vh;
      display: flex;
    }
    .output-card { flex: 0 0 auto; }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      flex-wrap: wrap;
    }
    #timeSlider {
      flex: 1;
    }

    #tecMap {
      flex: 1;
      height: 100%;
      min-height: 360px;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .leaflet-container {
      background: #000;
    }
    .tec-canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .leaflet-control.tec-legend {
      background: rgba(5, 8, 20, 0.95);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #222b3f;
      color: #f5f5f5;
      font-size: 10px;
      line-height: 1.3;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
    }
    .tec-legend-title {
      text-align: center;
      margin-bottom: 4px;
      font-weight: 600;
      letter-spacing: 0.05em;
    }
    .tec-legend-bar {
      width: 18px;
      height: 130px;
      margin: 0 auto 4px auto;
      border-radius: 4px;
      border: 1px solid #444;
    }
    .tec-legend-labels {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
    }

    #verifyCanvas {
      width: 220px;
      height: 220px;
      background: #050814;
      border-radius: 6px;
      border: 1px solid #222b3f;
    }

    .output-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .output-col {
      flex: 1;
      min-width: 200px;
      display: flex;
      flex-direction: column;
    }

    .output-col pre {
      max-height: 220px;
      overflow-y: auto;
    }

    /* storm phase label */
    #stormPhaseLabel {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: rgba(15,23,42,0.8);
      white-space: nowrap;
    }

    /* small badge text */
    .badge {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 999px;
      border: 1px solid #4b5563;
      font-size: 10px;
      background: #111827;
    }
  </style>
</head>
<body>
  <div class="page">
    <!-- ============= サイドバー ============= -->
    <div class="sidebar">
      <div class="card">
        <div class="card-header">
          <h1>SWIFT-TEC v3</h1>
          <span>Global TEC Forecast & Verification</span>
        </div>
        <div class="small">
          ・BoM TEC（最大6枚）から 48h / 15min 予報を生成<br>
          ・F10.7 / Ap / Dst / X-ray / Deep Flare Net を反映<br>
          ・CME / 高速太陽風インプットで磁気嵐〜電離圏嵐を近似<br>
          ・Leaflet 地図で好きな地域をズーム & フォーカス<br>
          ・指定範囲バイアス補正で任意の領域だけTECを微調整
        </div>
      </div>

      <!-- 1. BoM TEC 予報用 -->
      <div class="card">
        <div class="card-header">
          <h2>1. BoM TEC（予報用 最大6枚）</h2>
          <span>World0000_tec.txt などをコピペ</span>
        </div>
        <div class="row small">
          <div>BoM #1</div><div>BoM #2</div><div>BoM #3</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput1" placeholder="# PRODUCT NAME..."></textarea></div>
          <div><textarea id="bomInput2"></textarea></div>
          <div><textarea id="bomInput3"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #4</div><div>BoM #5</div><div>BoM #6</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput4"></textarea></div>
          <div><textarea id="bomInput5"></textarea></div>
          <div><textarea id="bomInput6"></textarea></div>
        </div>
        <div class="row">
          <button onclick="saveBomInputs()">BoM入力を保存</button>
          <button class="secondary" onclick="clearBomInputsStorage()">保存を削除</button>
        </div>
        <div class="small" id="bomInfo">
          ※「BoM入力を保存」を押した時点の内容をブラウザに保存。<br>
          次回起動時に自動で復元されます。
        </div>
      </div>

      <!-- 2. 太陽活動パラメータ -->
      <div class="card">
        <div class="card-header">
          <h2>2. 太陽活動パラメータ</h2>
          <span>NOAA / 京都WDC / GOES 代表値</span>
        </div>
        <div class="row">
          <div>
            <label>F10.7 [sfu]</label><br>
            <input id="inpF107" type="number" value="150" step="1">
          </div>
          <div>
            <label>Ap Index</label><br>
            <input id="inpAp" type="number" value="10" step="1">
          </div>
          <div>
            <label>Dst [nT]</label><br>
            <input id="inpDst" type="number" value="-20" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>X-ray (代表値 W/m²)</label><br>
            <input id="inpXray" type="number" value="1e-6" step="1e-7">
          </div>
        </div>
        <div class="small">
          ※将来的に 27DO.txt / Kyoto Dst / GOES テキストから自動抽出も追加可能。<br>
          まずは代表値を手入力して挙動を確認。
        </div>
      </div>

      <!-- 3. 宇宙天気イベント（CME / HSS） -->
      <div class="card">
        <div class="card-header">
          <h2>3. CME / 高速太陽風</h2>
          <span>磁気嵐〜電離圏嵐モデル用</span>
        </div>
        <div class="row">
          <div>
            <label>CME到達時刻 (UTC)</label><br>
            <input id="stormCmeTime" type="text" placeholder="2025-11-25T00:00Z">
          </div>
        </div>
        <div class="row">
          <div>
            <label>高速太陽風(HSS)到達時刻 (UTC)</label><br>
            <input id="stormHssTime" type="text" placeholder="2025-11-25T06:00Z">
          </div>
        </div>
        <div class="row">
          <div>
            <label>予想 Bz_min [nT]（南向きは負）</label><br>
            <input id="stormBzMin" type="number" value="-10" step="1">
          </div>
          <div>
            <label>予想 Vsw [km/s]</label><br>
            <input id="stormVsw" type="number" value="600" step="10">
          </div>
        </div>
        <div class="row">
          <button onclick="updateStormModelFromUI()">嵐インデックス更新</button>
        </div>
        <div class="small" id="stormModelSummary">
          Stormモデル: 現在は静穏として扱います。
        </div>
      </div>

      <!-- 4. Deep Flare Net 8領域 -->
      <div class="card">
        <div class="card-header">
          <h2>4. Deep Flare Net 領域</h2>
          <span>8分割フレア確率</span>
        </div>
        <div class="small">
          8領域ごとに Xクラス / Mクラス発生確率 [%] を入力。<br>
          同じ場所に複数領域がある場合は「特異なもののみ」入力。
        </div>
        <table>
          <thead>
            <tr>
              <th>ID</th><th>位置イメージ</th><th>P(X≥) %</th><th>P(M≥) %</th><th>使用</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>R1</td><td>北西</td>
              <td><input id="fx1" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm1" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu1" type="checkbox" checked></td>
            </tr>
            <tr><td>R2</td><td>西</td>
              <td><input id="fx2" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm2" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu2" type="checkbox" checked></td>
            </tr>
            <tr><td>R3</td><td>南西</td>
              <td><input id="fx3" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm3" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu3" type="checkbox" checked></td>
            </tr>
            <tr><td>R4</td><td>南</td>
              <td><input id="fx4" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm4" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu4" type="checkbox" checked></td>
            </tr>
            <tr><td>R5</td><td>南東</td>
              <td><input id="fx5" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm5" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu5" type="checkbox" checked></td>
            </tr>
            <tr><td>R6</td><td>東</td>
              <td><input id="fx6" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm6" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu6" type="checkbox" checked></td>
            </tr>
            <tr><td>R7</td><td>北東</td>
              <td><input id="fx7" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm7" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu7" type="checkbox" checked></td>
            </tr>
            <tr><td>R8</td><td>中央</td>
              <td><input id="fx8" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm8" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu8" type="checkbox" checked></td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- 5. 検証用 BoM -->
      <div class="card">
        <div class="card-header">
          <h2>5. 検証用 BoM TEC（最大4枚）</h2>
          <span>予報期間中の実測</span>
        </div>
        <div class="row small">
          <div>Verify #1</div><div>Verify #2</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput1"></textarea></div>
          <div><textarea id="verifyInput2"></textarea></div>
        </div>
        <div class="row small">
          <div>Verify #3</div><div>Verify #4</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput3"></textarea></div>
          <div><textarea id="verifyInput4"></textarea></div>
        </div>
        <div class="row">
          <button onclick="runVerification()">検証を実行</button>
          <button class="secondary" onclick="clearVerification()">検証クリア</button>
        </div>
        <div class="small">
          検証では地球を緯度×経度で3×3の9領域に分割し、<br>
          各領域の MAPE（誤差%）と Bias（過大/過小）を算出します。
        </div>
      </div>

      <!-- 6. 検証マップ色設定 -->
      <div class="card">
        <div class="card-header">
          <h2>6. 検証マップ色設定</h2>
          <span>誤差(%) → 色を任意設定</span>
        </div>
        <div class="small">
          誤差の上限と色を設定。例）10%まで緑、20%まで黄、30%までオレンジ、それ以上赤。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>誤差上限%</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="vLimit1" type="number" value="10" style="width:50px;"></td>
              <td><input id="vColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="vLimit2" type="number" value="20" style="width:50px;"></td>
              <td><input id="vColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="vLimit3" type="number" value="30" style="width:50px;"></td>
              <td><input id="vColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="vLimit4" type="number" value="999" style="width:50px;"></td>
              <td><input id="vColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyVerifyColorScale()">色設定を反映</button>
          <button class="secondary" onclick="resetVerifyColorScale()">初期化</button>
        </div>
      </div>

      <!-- 7. 地域フォーカス & 指定範囲バイアス -->
      <div class="card">
        <div class="card-header">
          <h2>7. 地域フォーカス & 指定バイアス</h2>
          <span>地図ズーム & TEC補正</span>
        </div>
        <div class="small">
          ・プリセット地域や手動範囲で地図をフォーカス<br>
          ・同じ範囲にだけ TEC の +/-% バイアスを掛けられます。
        </div>
        <div class="row">
          <div>
            <label>フォーカス地域</label><br>
            <select id="focusPreset" onchange="onFocusPresetChange()">
              <option value="global">グローバル</option>
              <option value="japan">日本付近</option>
              <option value="europe">ヨーロッパ</option>
              <option value="na">北アメリカ</option>
              <option value="sa">南アメリカ</option>
              <option value="africa">アフリカ</option>
              <option value="custom">手動指定</option>
            </select>
          </div>
        </div>
        <div class="row small">
          <div>緯度範囲 [deg]</div><div>経度範囲 [deg]</div>
        </div>
        <div class="row">
          <div>
            minLat<br>
            <input id="focusLatMin" type="number" value="-90" step="1">
          </div>
          <div>
            maxLat<br>
            <input id="focusLatMax" type="number" value="90" step="1">
          </div>
          <div>
            minLon<br>
            <input id="focusLonMin" type="number" value="-180" step="1">
          </div>
          <div>
            maxLon<br>
            <input id="focusLonMax" type="number" value="180" step="1">
          </div>
        </div>
        <div class="row">
          <button onclick="applyFocusRegion()">地図をフォーカス</button>
        </div>
        <hr style="border-color:#1f2937;">
        <div class="row">
          <div>
            <label>この範囲のバイアス補正[%]</label><br>
            <input id="biasPct" type="number" value="0" step="1">
          </div>
        </div>
        <div class="row">
          <button onclick="applyBiasFromUI()">バイアスを保存</button>
          <button class="secondary" onclick="resetBiasRect()">バイアス解除</button>
        </div>
        <div class="small" id="biasInfo">
          現在、指定範囲バイアスは未設定です。
        </div>
      </div>

      <!-- 8. TEC カラーマップ設定 -->
      <div class="card">
        <div class="card-header">
          <h2>8. TEC カラーマップ設定</h2>
          <span>TEC値 → 色を任意設定</span>
        </div>
        <div class="small">
          TEC [TECU] の上限と色を設定。色は Leaflet 地図と凡例に反映されます。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>TEC上限[TECU]</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="tLimit1" type="number" value="10" style="width:60px;"></td>
              <td><input id="tColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="tLimit2" type="number" value="30" style="width:60px;"></td>
              <td><input id="tColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="tLimit3" type="number" value="60" style="width:60px;"></td>
              <td><input id="tColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="tLimit4" type="number" value="120" style="width:60px;"></td>
              <td><input id="tColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyTecColorScale()">TEC色を反映</button>
          <button class="secondary" onclick="resetTecColorScale()">初期化</button>
        </div>
      </div>

      <!-- 9. 係数設定 -->
      <div class="card">
        <div class="card-header">
          <h2>9. 係数設定（Advanced）</h2>
          <span>バイアス提案 & 嵐モデル用</span>
        </div>
        <div class="small">※いじり過ぎる前に現在値をどこかにメモ推奨。</div>
        <div class="flex-col">
          <div class="row">
            <div>
              <label>kGlobal（全体スケール）</label><br>
              <input id="cfg_kGlobal" type="number" value="1.0" step="0.05">
            </div>
            <div>
              <label>wF107</label><br>
              <input id="cfg_wF107" type="number" value="0.004" step="0.001">
            </div>
            <div>
              <label>wAp</label><br>
              <input id="cfg_wAp" type="number" value="0.01" step="0.002">
            </div>
          </div>
          <div class="row">
            <div>
              <label>wDst</label><br>
              <input id="cfg_wDst" type="number" value="-0.002" step="0.001">
            </div>
            <div>
              <label>pX（日中指数）</label><br>
              <input id="cfg_pX" type="number" value="1.5" step="0.1">
            </div>
            <div>
              <label>latShape（赤道異常）</label><br>
              <input id="cfg_latShape" type="number" value="0.4" step="0.05">
            </div>
          </div>
          <div class="row">
            <div>
              <label>latHighCut（高緯度減衰）</label><br>
              <input id="cfg_latHighCut" type="number" value="0.5" step="0.05">
            </div>
            <div>
              <label>β_flare</label><br>
              <input id="cfg_betaFlare" type="number" value="0.5" step="0.05">
            </div>
            <div>
              <label>k_X</label><br>
              <input id="cfg_kX" type="number" value="1.0" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>k_M</label><br>
              <input id="cfg_kM" type="number" value="0.3" step="0.1">
            </div>
            <div>
              <label>biasThresh%（提案閾値）</label><br>
              <input id="cfg_biasThresh" type="number" value="15" step="1">
            </div>
            <div>
              <label>suggestGain（提案の強さ）</label><br>
              <input id="cfg_suggestGain" type="number" value="0.5" step="0.1">
            </div>
          </div>

          <!-- 嵐モデル係数 -->
          <div class="row">
            <div>
              <label>kStormOnsetH（到達→嵐開始[h]）</label><br>
              <input id="cfg_kStormOnsetH" type="number" value="0.5" step="0.5">
            </div>
            <div>
              <label>kStormPeakH（立ち上がり〜ピーク[h]）</label><br>
              <input id="cfg_kStormPeakH" type="number" value="3" step="0.5">
            </div>
            <div>
              <label>kStormRecoverH（ピーク→回復[h]）</label><br>
              <input id="cfg_kStormRecoverH" type="number" value="24" step="1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>kStormBoost（正層嵐増幅係数）</label><br>
              <input id="cfg_kStormBoost" type="number" value="0.3" step="0.05">
            </div>
            <div>
              <label>kStormDecay（回復期減衰係数）</label><br>
              <input id="cfg_kStormDecay" type="number" value="0.05" step="0.01">
            </div>
          </div>
        </div>
        <div class="row">
          <button onclick="saveConfig()">設定を保存</button>
          <button class="secondary" onclick="loadConfig(true); updateFormulaText();">保存値を再読込</button>
        </div>
      </div>

      <!-- 10. 実行 -->
      <div class="card">
        <div class="card-header">
          <h2>10. 実行</h2>
          <span>予報 & 描画</span>
        </div>
        <div class="row">
          <button onclick="runForecast()">TEC予報を計算</button>
          <button class="secondary" onclick="resetAll()">リセット</button>
        </div>
        <div id="runInfo" class="small"></div>
      </div>
    </div>

    <!-- ============= メイン領域 ============= -->
    <div class="main">
      <!-- 上段：時間スライダー＋透明度 -->
      <div class="card slider-card">
        <div class="slider-row">
          <span>時間スライダー（0〜48h / 15分刻み）</span>
          <input type="range" id="timeSlider" min="0" max="192" value="0" oninput="onSliderChange()">
          <span id="timeLabel">t = 0.00 h</span>
          <span id="stormPhaseLabel">嵐フェーズ: 静穏</span>
        </div>
        <div class="row small" style="margin-top:4px;">
          <div style="flex:1;">
            TEC透明度:
            <input id="tecAlpha" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;" oninput="onTecAlphaChange()">
          </div>
          <div style="flex:2;">
            <span class="small">※地図をズーム／ドラッグして、任意の地域の TEC 分布を確認できます。</span>
          </div>
        </div>
      </div>

      <!-- 中段：Leaflet 地図 -->
      <div class="card map-card">
        <div id="tecMap"></div>
      </div>

      <!-- 下段：検証マップ＋レポート＋クリックTEC値 -->
      <div class="card output-card">
        <div class="output-row">
          <div class="output-col" style="flex:0 0 240px; max-width:260px;">
            <h3>11. 検証 3×3 マップ</h3>
            <canvas id="verifyCanvas"></canvas>
          </div>
          <div class="output-col" style="flex:2;">
            <h3>12. 検証レポート & 係数提案</h3>
            <pre id="verifyReport">(まだ検証されていません)</pre>
          </div>
          <div class="output-col" style="flex:1;">
            <h3>TEC & 嵐ステータス</h3>
            <pre id="pointInfo">地図上をクリックすると、その格子点のTECと位置が表示されます。</pre>
          </div>
        </div>
      </div>

      <!-- 計算式表示 -->
      <div class="card output-card">
        <div class="output-row">
          <div class="output-col">
            <h3>13. 現在の TEC 計算式</h3>
            <div class="row">
              <button onclick="updateFormulaText()">計算式を更新</button>
            </div>
            <pre id="formulaText">まだ計算式が生成されていません。</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ============ グローバル状態 ============ */
    let gGrid = null;              // {latArr, lonArr, nLat, nLon}
    let gForecastFrames = [];      // [step][iLat][iLon]
    let gForecastTimes = [];       // Date[]
    let gForecastStart = null;     // Date (UTC, from first BoM)
    let currentStepIndex = 0;

    let gVerifyColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 20,  color: "#ffff00" },
      { limit: 30,  color: "#ff9900" },
      { limit: 999, color: "#ff0000" }
    ];

    // TEC カラー（ユーザー設定可能）
    let gTecColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 30,  color: "#ffff00" },
      { limit: 60,  color: "#ff9900" },
      { limit: 120, color: "#ff0000" }
    ];

    // 指定範囲バイアス
    let gBiasRect = null; // {latMin,latMax,lonMin,lonMax,pct}

    // Leaflet 関連
    let map = null;
    let tecCanvas = null;
    let tecCtx = null;
    let tecLegendControl = null;
    let tecAlpha = 0.8;

    let focusRectLayer = null;
    let biasRectLayer = null;

    let lastVerifyResult = null;

    // 磁気嵐・電離圏嵐モデル
    let gStormModel = null;          // {baseTime, S, levelText, hasStorm}
    let gStormFactors = [];          // [step] multiplicative factor
    let gStormPhaseLabels = [];      // [step] phase text

    const STORAGE_KEY_CONFIG    = "swifttec_config_v3";
    const STORAGE_KEY_VCOL      = "swifttec_vcol_v3";
    const STORAGE_KEY_BOM       = "swifttec_bom_inputs_v3";
    const STORAGE_KEY_TCOL      = "swifttec_teccol_v3";
    const STORAGE_KEY_BIASRECT  = "swifttec_biasrect_v1";

    function logInfo(msg) {
      const div = document.getElementById("runInfo");
      if (div) div.textContent = msg;
      console.log(msg);
    }
    function clamp(v, a, b) { return v < a ? a : (v > b ? b : v); }

    /* ===== 日付パース: VALID DATE/TIME: 11/11/2025 00:00:00UTC ===== */
    function parseBomValidTime(text) {
      const lines = text.split(/\r?\n/);
      for (const line of lines) {
        const m = line.match(/VALID DATE\/TIME:\s*(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/i);
        if (m) {
          const d  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const y  = parseInt(m[3],10);
          const hh = parseInt(m[4],10);
          const mm = parseInt(m[5],10);
          const ss = parseInt(m[6],10);
          return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
        }
      }
      return null;
    }

    /* ====== BoM TEC テキスト → 格子データ ====== */
    function parseBoM(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (!lines.length) throw new Error("空のテキストです。");

      let latMin, latMax, latStep, nLat;
      let lonMin, lonMax, lonStep, nLon;

      for (const line of lines) {
        if (/LATITUDE GRID/i.test(line)) {
          const m = line.match(/LATITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            latMin  = parseFloat(m[1]);
            latMax  = parseFloat(m[2]);
            latStep = parseFloat(m[3]);
            nLat    = parseInt(m[4],10);
          }
        } else if (/LONGITUDE GRID/i.test(line)) {
          const m = line.match(/LONGITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            lonMin  = parseFloat(m[1]);
            lonMax  = parseFloat(m[2]);
            lonStep = parseFloat(m[3]);
            nLon    = parseInt(m[4],10);
          }
        }
      }
      if (latMin === undefined || lonMin === undefined) {
        throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません。");
      }

      const valLines = lines.filter(l => !l.trim().startsWith("#") && !/GRID/i.test(l));
      const values = [];
      for (const ln of valLines) {
        const parts = ln.split(/[, ]+/).map(x => x.trim()).filter(x => x.length>0);
        for (const p of parts) {
          const v = parseFloat(p);
          if (!isNaN(v)) values.push(v);
        }
      }
      if (values.length !== nLat*nLon) {
        throw new Error(`データ数が不一致です: ${values.length} vs ${nLat*nLon}`);
      }

      const latArr = [];
      for (let i=0;i<nLat;i++) latArr.push(latMin + latStep*i);
      const lonArr = [];
      for (let j=0;j<nLon;j++) lonArr.push(lonMin + lonStep*j);

      const grid = new Array(nLat);
      let idx = 0;
      for (let i=0;i<nLat;i++) {
        grid[i] = new Array(nLon);
        for (let j=0;j<nLon;j++) {
          grid[i][j] = values[idx++];
        }
      }

      const validTime = parseBomValidTime(text);
      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============ BoM 入力保存 ============ */
    function saveBomInputs() {
      const data = {
        bomInput1: document.getElementById("bomInput1").value,
        bomInput2: document.getElementById("bomInput2").value,
        bomInput3: document.getElementById("bomInput3").value,
        bomInput4: document.getElementById("bomInput4").value,
        bomInput5: document.getElementById("bomInput5").value,
        bomInput6: document.getElementById("bomInput6").value
      };
      localStorage.setItem(STORAGE_KEY_BOM, JSON.stringify(data));
      logInfo("BoM入力を保存しました。（次回起動時に自動復元）");
    }

    function loadBomInputsFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_BOM);
      if (!s) return;
      try {
        const data = JSON.parse(s);
        if (data.bomInput1 !== undefined) document.getElementById("bomInput1").value = data.bomInput1;
        if (data.bomInput2 !== undefined) document.getElementById("bomInput2").value = data.bomInput2;
        if (data.bomInput3 !== undefined) document.getElementById("bomInput3").value = data.bomInput3;
        if (data.bomInput4 !== undefined) document.getElementById("bomInput4").value = data.bomInput4;
        if (data.bomInput5 !== undefined) document.getElementById("bomInput5").value = data.bomInput5;
        if (data.bomInput6 !== undefined) document.getElementById("bomInput6").value = data.bomInput6;
      } catch(e) {
        console.warn("BoM入力の復元に失敗:", e);
      }
    }

    function clearBomInputsStorage() {
      localStorage.removeItem(STORAGE_KEY_BOM);
      logInfo("保存されていた BoM 入力を削除しました。（テキスト内容はそのまま）");
    }

    /* ============ Config（係数） ============ */
    function getConfigFromUI() {
      return {
        kGlobal:     parseFloat(document.getElementById("cfg_kGlobal").value)  || 1.0,
        wF107:       parseFloat(document.getElementById("cfg_wF107").value)    || 0.004,
        wAp:         parseFloat(document.getElementById("cfg_wAp").value)      || 0.01,
        wDst:        parseFloat(document.getElementById("cfg_wDst").value)     || -0.002,
        pX:          parseFloat(document.getElementById("cfg_pX").value)       || 1.5,
        latShape:    parseFloat(document.getElementById("cfg_latShape").value) || 0.4,
        latHighCut:  parseFloat(document.getElementById("cfg_latHighCut").value) || 0.5,
        betaFlare:   parseFloat(document.getElementById("cfg_betaFlare").value)|| 0.5,
        kX:          parseFloat(document.getElementById("cfg_kX").value)       || 1.0,
        kM:          parseFloat(document.getElementById("cfg_kM").value)       || 0.3,
        biasThresh:  parseFloat(document.getElementById("cfg_biasThresh").value)|| 15,
        suggestGain: parseFloat(document.getElementById("cfg_suggestGain").value)|| 0.5,
        // 嵐モデル関連
        kStormOnsetH:   parseFloat(document.getElementById("cfg_kStormOnsetH").value)   || 0.5,
        kStormPeakH:    parseFloat(document.getElementById("cfg_kStormPeakH").value)    || 3,
        kStormRecoverH: parseFloat(document.getElementById("cfg_kStormRecoverH").value) || 24,
        kStormBoost:    parseFloat(document.getElementById("cfg_kStormBoost").value)    || 0.3,
        kStormDecay:    parseFloat(document.getElementById("cfg_kStormDecay").value)    || 0.05
      };
    }

    function applyConfigToUI(cfg) {
      document.getElementById("cfg_kGlobal").value     = cfg.kGlobal;
      document.getElementById("cfg_wF107").value       = cfg.wF107;
      document.getElementById("cfg_wAp").value         = cfg.wAp;
      document.getElementById("cfg_wDst").value        = cfg.wDst;
      document.getElementById("cfg_pX").value          = cfg.pX;
      document.getElementById("cfg_latShape").value    = cfg.latShape;
      document.getElementById("cfg_latHighCut").value  = cfg.latHighCut;
      document.getElementById("cfg_betaFlare").value   = cfg.betaFlare;
      document.getElementById("cfg_kX").value          = cfg.kX;
      document.getElementById("cfg_kM").value          = cfg.kM;
      document.getElementById("cfg_biasThresh").value  = cfg.biasThresh;
      document.getElementById("cfg_suggestGain").value = cfg.suggestGain;

      document.getElementById("cfg_kStormOnsetH").value   = cfg.kStormOnsetH;
      document.getElementById("cfg_kStormPeakH").value    = cfg.kStormPeakH;
      document.getElementById("cfg_kStormRecoverH").value = cfg.kStormRecoverH;
      document.getElementById("cfg_kStormBoost").value    = cfg.kStormBoost;
      document.getElementById("cfg_kStormDecay").value    = cfg.kStormDecay;
    }

    function saveConfig() {
      const cfg = getConfigFromUI();
      localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(cfg));
      logInfo("係数設定を保存しました。");
      updateFormulaText();
    }

    function loadConfig(apply) {
      const s = localStorage.getItem(STORAGE_KEY_CONFIG);
      if (!s) {
        if (apply) logInfo("保存された係数がありません。初期値を使用。");
        return null;
      }
      try {
        const cfgRaw = JSON.parse(s);
        // 後から増えたパラメータに対してデフォルト埋め
        const cfg = Object.assign({
          kGlobal:1.0,wF107:0.004,wAp:0.01,wDst:-0.002,pX:1.5,
          latShape:0.4,latHighCut:0.5,betaFlare:0.5,kX:1.0,kM:0.3,
          biasThresh:15,suggestGain:0.5,
          kStormOnsetH:0.5,kStormPeakH:3,kStormRecoverH:24,
          kStormBoost:0.3,kStormDecay:0.05
        }, cfgRaw);
        if (apply) applyConfigToUI(cfg);
        return cfg;
      } catch(e) {
        console.warn("Configの復元に失敗:", e);
        return null;
      }
    }

    /* ============ 検証マップ色設定 ============ */
    function applyVerifyColorScale() {
      const limits = [
        parseFloat(document.getElementById("vLimit1").value) || 10,
        parseFloat(document.getElementById("vLimit2").value) || 20,
        parseFloat(document.getElementById("vLimit3").value) || 30,
        parseFloat(document.getElementById("vLimit4").value) || 999
      ];
      const cols = [
        document.getElementById("vColor1").value || "#00ff00",
        document.getElementById("vColor2").value || "#ffff00",
        document.getElementById("vColor3").value || "#ff9900",
        document.getElementById("vColor4").value || "#ff0000"
      ];
      gVerifyColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_VCOL, JSON.stringify(gVerifyColorScale));
      logInfo("検証色スケールを保存しました。");
      drawVerifyMap(lastVerifyResult);
    }

    function resetVerifyColorScale() {
      gVerifyColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 20,  color: "#ffff00" },
        { limit: 30,  color: "#ff9900" },
        { limit: 999, color: "#ff0000" }
      ];
      document.getElementById("vLimit1").value = 10;
      document.getElementById("vLimit2").value = 20;
      document.getElementById("vLimit3").value = 30;
      document.getElementById("vLimit4").value = 999;
      document.getElementById("vColor1").value = "#00ff00";
      document.getElementById("vColor2").value = "#ffff00";
      document.getElementById("vColor3").value = "#ff9900";
      document.getElementById("vColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_VCOL, JSON.stringify(gVerifyColorScale));
      drawVerifyMap(lastVerifyResult);
    }

    function loadVerifyColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_VCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gVerifyColorScale = arr;
        document.getElementById("vLimit1").value = arr[0].limit;
        document.getElementById("vLimit2").value = arr[1].limit;
        document.getElementById("vLimit3").value = arr[2].limit;
        document.getElementById("vLimit4").value = arr[3].limit;
        document.getElementById("vColor1").value = arr[0].color;
        document.getElementById("vColor2").value = arr[1].color;
        document.getElementById("vColor3").value = arr[2].color;
        document.getElementById("vColor4").value = arr[3].color;
      } catch(e) {
        console.warn("検証色スケール復元に失敗:", e);
      }
    }

    /* ============ TEC カラーマップ設定 ============ */
    function applyTecColorScale() {
      const limits = [
        parseFloat(document.getElementById("tLimit1").value) || 10,
        parseFloat(document.getElementById("tLimit2").value) || 30,
        parseFloat(document.getElementById("tLimit3").value) || 60,
        parseFloat(document.getElementById("tLimit4").value) || 120
      ];
      const cols = [
        document.getElementById("tColor1").value || "#00ff00",
        document.getElementById("tColor2").value || "#ffff00",
        document.getElementById("tColor3").value || "#ff9900",
        document.getElementById("tColor4").value || "#ff0000"
      ];
      gTecColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      logInfo("TECカラースケールを保存しました。");
      updateTecLegend();
      drawTecOverlay();
    }

    function resetTecColorScale() {
      gTecColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 30,  color: "#ffff00" },
        { limit: 60,  color: "#ff9900" },
        { limit: 120, color: "#ff0000" }
      ];
      document.getElementById("tLimit1").value = 10;
      document.getElementById("tLimit2").value = 30;
      document.getElementById("tLimit3").value = 60;
      document.getElementById("tLimit4").value = 120;
      document.getElementById("tColor1").value = "#00ff00";
      document.getElementById("tColor2").value = "#ffff00";
      document.getElementById("tColor3").value = "#ff9900";
      document.getElementById("tColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      updateTecLegend();
      drawTecOverlay();
    }

    function loadTecColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_TCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gTecColorScale = arr;
        document.getElementById("tLimit1").value = arr[0].limit;
        document.getElementById("tLimit2").value = arr[1].limit;
        document.getElementById("tLimit3").value = arr[2].limit;
        document.getElementById("tLimit4").value = arr[3].limit;
        document.getElementById("tColor1").value = arr[0].color;
        document.getElementById("tColor2").value = arr[1].color;
        document.getElementById("tColor3").value = arr[2].color;
        document.getElementById("tColor4").value = arr[3].color;
      } catch(e) {
        console.warn("TEC色スケール復元に失敗:", e);
      }
    }

    /* ============ 指定範囲バイアス ============ */
    function applyBiasFromUI() {
      const latMin = parseFloat(document.getElementById("focusLatMin").value);
      const latMax = parseFloat(document.getElementById("focusLatMax").value);
      const lonMin = parseFloat(document.getElementById("focusLonMin").value);
      const lonMax = parseFloat(document.getElementById("focusLonMax").value);
      const pct    = parseFloat(document.getElementById("biasPct").value) || 0;

      if (!isFinite(latMin) || !isFinite(latMax) || !isFinite(lonMin) || !isFinite(lonMax)) {
        logInfo("バイアス範囲の緯度・経度が不正です。");
        return;
      }
      gBiasRect = {latMin,latMax,lonMin,lonMax,pct};
      localStorage.setItem(STORAGE_KEY_BIASRECT, JSON.stringify(gBiasRect));
      updateBiasRectOverlay();
      const info = `指定範囲バイアス: lat[${latMin},${latMax}], lon[${lonMin},${lonMax}] に ${pct}% を適用。`;
      document.getElementById("biasInfo").textContent = info;
      logInfo("指定範囲バイアスを保存しました。");
      drawTecOverlay();
    }

    function resetBiasRect() {
      gBiasRect = null;
      localStorage.removeItem(STORAGE_KEY_BIASRECT);
      document.getElementById("biasPct").value = 0;
      document.getElementById("biasInfo").textContent = "現在、指定範囲バイアスは未設定です。";
      if (biasRectLayer && map) {
        map.removeLayer(biasRectLayer);
        biasRectLayer = null;
      }
      drawTecOverlay();
    }

    function loadBiasRectFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_BIASRECT);
      if (!s) return;
      try {
        const rect = JSON.parse(s);
        if (rect && typeof rect.latMin === "number") {
          gBiasRect = rect;
          document.getElementById("biasPct").value = rect.pct;
          document.getElementById("biasInfo").textContent =
            `指定範囲バイアス: lat[${rect.latMin},${rect.latMax}], lon[${rect.lonMin},${rect.lonMax}] に ${rect.pct}% を適用。`;
          // フォーカス欄にはロードしない（ユーザー操作時に上書き）
          updateBiasRectOverlay();
        }
      } catch(e) {
        console.warn("指定範囲バイアス復元に失敗:", e);
      }
    }

    function updateBiasRectOverlay() {
      if (!map) return;
      if (biasRectLayer) {
        map.removeLayer(biasRectLayer);
        biasRectLayer = null;
      }
      if (!gBiasRect) return;
      const b = gBiasRect;
      const bounds = [[b.latMin, b.lonMin],[b.latMax, b.lonMax]];
      biasRectLayer = L.rectangle(bounds, {
        color:"#f97316",
        weight:1,
        fill:false,
        dashArray:"4,4"
      }).addTo(map);
    }

    /* ===== 太陽位置 ===== */
    function dayOfYearUTC(date) {
      const start = new Date(Date.UTC(date.getUTCFullYear(),0,1,0,0,0));
      return 1 + (date - start)/86400000;
    }
    function solarDeclinationRad(date) {
      const N = dayOfYearUTC(date);
      const rad = Math.PI/180;
      return 23.44*rad * Math.sin(2*Math.PI*(N-80)/365.0);
    }
    function subsolarLongitudeDeg(date) {
      const utH = date.getUTCHours() + date.getUTCMinutes()/60 + date.getUTCSeconds()/3600;
      let lon = -(utH - 12)*15;
      while (lon < -180) lon += 360;
      while (lon > 180) lon -= 360;
      return lon;
    }

    function computeSolarScale(F107, Ap, Dst, Xray, cfg) {
      const F0 = 100;
      const dF = F107 - F0;
      let S = 1 + cfg.wF107*dF;
      S += cfg.wAp*(Ap - 10);
      S += cfg.wDst*Dst;
      if (Xray > 0) {
        const X0 = 1e-7;
        const lx = Math.log10(Xray / X0);
        S += 0.05*lx;
      }
      if (S < 0.2) S = 0.2;
      if (S > 3.0) S = 3.0;
      return S;
    }

    function computeLatWeight(latDeg, cfg) {
      const a = cfg.latShape;
      const x = Math.abs(latDeg)/40;
      let w = 1 + a * (1 - (x-1)*(x-1));  // 赤道付近 > 中緯度 > 高緯度
      if (w < 0.3) w = 0.3;
      if (Math.abs(latDeg) > 60) {
        const f = (Math.abs(latDeg)-60)/30;
        const gh = cfg.latHighCut;
        w *= (1 - f*(1-gh));
      }
      return w;
    }

    function computeFlareScale(cfg) {
      let I = 0;
      for (let r=1;r<=8;r++) {
        const use = document.getElementById("fu"+r).checked;
        if (!use) continue;
        const px = parseFloat(document.getElementById("fx"+r).value) || 0;
        const pm = parseFloat(document.getElementById("fm"+r).value) || 0;
        let wvis = 0.7;
        if (r === 8) wvis = 1.0;
        if (r === 4 || r === 5) wvis = 0.85;
        const Fx = cfg.kX * (px/100);
        const Fm = cfg.kM * (pm/100);
        I += (Fx + Fm)*wvis;
      }
      const Sflare = 1 + cfg.betaFlare*I;
      return clamp(Sflare, 0.7, 3.0);
    }

    function fixLocalVShape(frame, nLat, nLon, threshold) {
      const out = new Array(nLat);
      for (let i=0;i<nLat;i++) {
        out[i] = new Array(nLon);
        for (let j=0;j<nLon;j++) {
          const T0 = frame[i][j];
          if (!isFinite(T0)) { out[i][j] = T0; continue; }
          let sum=0,cnt=0;
          for (let di=-1;di<=1;di++) {
            for (let dj=-1;dj<=1;dj++) {
              if (!di && !dj) continue;
              const ii=i+di, jj=(j+dj+nLon)%nLon;
              if (ii<0 || ii>=nLat) continue;
              const v = frame[ii][jj];
              if (!isFinite(v)) continue;
              sum += v; cnt++;
            }
          }
          if (cnt===0) { out[i][j]=T0; continue; }
          const neigh = sum/cnt;
          if (T0 < threshold*neigh) {
            const alpha = 0.7;
            out[i][j] = T0*(1-alpha)+neigh*alpha;
          } else out[i][j]=T0;
        }
      }
      return out;
    }

    /* ============ 磁気嵐 / 電離圏嵐モデル ============ */
    function parseEventTimeStr(str) {
      const s = (str || "").trim();
      if (!s) return null;
      // 末尾にZが無ければUTCとして扱う
      let iso = s;
      if (!/Z$/.test(iso) && !/[+-]\d\d:\d\d$/.test(iso)) {
        iso += "Z";
      }
      const d = new Date(iso);
      if (isNaN(d.getTime())) return null;
      return d;
    }

    function buildStormModelFromUI(cfg) {
      const tCME = parseEventTimeStr(document.getElementById("stormCmeTime").value);
      const tHSS = parseEventTimeStr(document.getElementById("stormHssTime").value);
      const Vsw  = parseFloat(document.getElementById("stormVsw").value) || 400;
      const bz   = parseFloat(document.getElementById("stormBzMin").value) || 0;

      if (!tCME && !tHSS) {
        return {
          hasStorm:false,
          baseTime:null,
          S:0,
          levelText:"静穏（イベント未入力）"
        };
      }
      const baseTime = tCME || tHSS;
      const vNorm = Vsw / 400;
      const bzSouth = Math.max(0, -bz); // 南向きのみ
      let S = vNorm * (1 + 0.1 * bzSouth);
      if (tCME && tHSS) {
        // CME + HSS 両方ある場合は少し強めに
        S *= 1.2;
      }
      S = clamp(S, 0, 4);

      let levelText = "Minor Storm";
      if (S < 0.5) levelText = "静穏〜弱い擾乱";
      else if (S < 1.5) levelText = "Minor Storm（G1相当）";
      else if (S < 2.5) levelText = "Moderate Storm（G2〜G3）";
      else levelText = "Strong Storm（G4+）";

      return {
        hasStorm:true,
        baseTime,
        S,
        levelText
      };
    }

    function updateStormModelFromUI() {
      const cfg = getConfigFromUI();
      gStormModel = buildStormModelFromUI(cfg);
      const div = document.getElementById("stormModelSummary");
      if (!gStormModel.hasStorm) {
        div.textContent = "Stormモデル: 現在は静穏として扱います。";
      } else {
        div.textContent =
          `Stormモデル: 基準時刻=${gStormModel.baseTime.toISOString()} / 強度Index S=${gStormModel.S.toFixed(2)} / ` +
          gStormModel.levelText;
      }
      updateFormulaText();
    }

    // ある時刻tに対する正層嵐ブースト係数とフェーズ文字列
    function getStormFactorAtTime(t, model, cfg) {
      if (!model || !model.hasStorm || !model.baseTime) {
        return { factor:1.0, phase:"嵐フェーズ: 静穏" };
      }
      const dtH = (t - model.baseTime)/3600000; // [h]
      const onsetH   = cfg.kStormOnsetH;                    // 到達→嵐開始
      const peakH    = onsetH + cfg.kStormPeakH;            // ピークまで
      const recoverH = peakH + cfg.kStormRecoverH;          // 回復終了
      const S        = model.S;
      const ampBase  = cfg.kStormBoost * (S/2);             // S=2で≈kStormBoost

      if (dtH < onsetH) {
        return { factor:1.0, phase:"嵐フェーズ: 事前静穏" };
      }
      if (dtH >= onsetH && dtH < peakH) {
        // 磁気嵐メインフェーズ & 電離圏正相の立ち上がり
        const prog = (dtH - onsetH) / Math.max(peakH-onsetH, 0.1);
        const amp  = ampBase * clamp(prog,0,1);
        const factor = 1 + amp;
        return { factor, phase:"嵐フェーズ: 磁気嵐立ち上がり / 正層嵐増加中" };
      }
      if (dtH >= peakH && dtH < recoverH) {
        // 回復フェーズ：指数減衰で正相嵐が弱まる
        const tRec = dtH - peakH;
        const amp  = ampBase * Math.exp(-cfg.kStormDecay * tRec);
        const factor = 1 + amp;
        return { factor, phase:"嵐フェーズ: 回復期 / 正層嵐減衰" };
      }
      // かなり後：ほぼ静穏へ
      return { factor:1.0, phase:"嵐フェーズ: ポストストーム〜静穏" };
    }

    /* ============ 予報計算本体 ============ */
    function runForecast() {
      try {
        const bomTexts = [
          document.getElementById("bomInput1").value,
          document.getElementById("bomInput2").value,
          document.getElementById("bomInput3").value,
          document.getElementById("bomInput4").value,
          document.getElementById("bomInput5").value,
          document.getElementById("bomInput6").value
        ];
        const snaps = [];
        const infoLines = [];
        for (let i=0;i<bomTexts.length;i++) {
          const t = bomTexts[i];
          if (!t.trim()) continue;
          try {
            const b = parseBoM(t);
            b.index = i+1;
            snaps.push(b);
            infoLines.push(`BoM #${i+1}: ${b.nLat}×${b.nLon}, VALID=${b.validTime ? b.validTime.toISOString() : "不明"}`);
          } catch(e) {
            infoLines.push(`BoM #${i+1}: エラー → ${e.message}`);
          }
        }
        document.getElementById("bomInfo").textContent = snaps.length
          ? "読み取り成功: " + snaps.length + "枚\n" + infoLines.join("\n")
          : "BoMが1枚も読み取れませんでした。";

        if (!snaps.length) throw new Error("少なくとも BoM を1枚入力してください。");

        const base = snaps[0];
        const {nLat, nLon, latArr, lonArr} = base;
        for (const s of snaps) {
          if (s.nLat!==nLat || s.nLon!==nLon) {
            throw new Error("BoMごとに格子サイズが異なります。");
          }
        }
        gGrid = {nLat, nLon, latArr, lonArr};

        snaps.sort((a,b)=> {
          const ta = a.validTime ? a.validTime.getTime():0;
          const tb = b.validTime ? b.validTime.getTime():0;
          return ta - tb;
        });
        gForecastStart = snaps[0].validTime || new Date();

        const cfg = getConfigFromUI();
        const F107 = parseFloat(document.getElementById("inpF107").value) || 150;
        const Ap   = parseFloat(document.getElementById("inpAp").value)   || 10;
        const Dst  = parseFloat(document.getElementById("inpDst").value)  || -20;
        const Xray = parseFloat(document.getElementById("inpXray").value) || 1e-6;

        const Ssolar = computeSolarScale(F107, Ap, Dst, Xray, cfg);
        const Sflare = computeFlareScale(cfg);

        // 磁気嵐モデルを更新
        gStormModel = buildStormModelFromUI(cfg);
        const stormSumDiv = document.getElementById("stormModelSummary");
        if (!gStormModel.hasStorm) {
          stormSumDiv.textContent = "Stormモデル: 現在は静穏として扱います。";
        } else {
          stormSumDiv.textContent =
            `Stormモデル: 基準時刻=${gStormModel.baseTime.toISOString()} / Index S=${gStormModel.S.toFixed(2)} / `
            + gStormModel.levelText;
        }

        const K = snaps.length;
        const T0  = new Array(nLat);
        const Aamp= new Array(nLat);
        const coschi = [];

        for (let k=0;k<K;k++) {
          const snap = snaps[k];
          const t = snap.validTime || gForecastStart;
          coschi[k] = new Array(nLat);
          const delta = solarDeclinationRad(t);
          const lonS  = subsolarLongitudeDeg(t);
          const rad = Math.PI/180;
          for (let i=0;i<nLat;i++) {
            coschi[k][i] = new Array(nLon);
            const lat = latArr[i];
            const phi = lat*rad;
            const sinphi = Math.sin(phi);
            const cosphi = Math.cos(phi);
            for (let j=0;j<nLon;j++) {
              const lon=lonArr[j];
              const lam=lon*rad;
              const h=lam - lonS*rad;
              const c = sinphi*Math.sin(delta)+cosphi*Math.cos(delta)*Math.cos(h);
              coschi[k][i][j] = c;
            }
          }
        }

        const pX = cfg.pX;
        for (let i=0;i<nLat;i++) {
          T0[i]=new Array(nLon);
          Aamp[i]=new Array(nLon);
          for (let j=0;j<nLon;j++) {
            let S_B=0,S_f=0,S_f2=0,S_Bf=0;
            for (let k=0;k<K;k++) {
              const B = snaps[k].grid[i][j];
              const c = coschi[k][i][j];
              const f = c>0 ? Math.pow(c,pX) : 0;
              S_B += B;
              S_f += f;
              S_f2+= f*f;
              S_Bf+= B*f;
            }
            const N=K;
            const D = N*S_f2 - S_f*S_f;
            let t0,a;
            if (Math.abs(D)<1e-8) {
              t0 = S_B/N; a=0;
            } else {
              t0 = (S_B*S_f2 - S_f*S_Bf)/D;
              a  = (N*S_Bf - S_f*S_B)/D;
            }
            if (!isFinite(t0)) t0=0;
            if (!isFinite(a))  a=0;
            if (t0<0) t0=0;
            T0[i][j]=t0;
            Aamp[i][j]=a;
          }
        }

        const forecastHours = 48;
        const dtMin = 15;
        const nSteps = Math.round(forecastHours*60/dtMin);
        gForecastFrames = new Array(nSteps+1);
        gForecastTimes  = new Array(nSteps+1);
        gStormFactors   = new Array(nSteps+1);
        gStormPhaseLabels = new Array(nSteps+1);

        for (let step=0; step<=nSteps; step++) {
          const t = new Date(gForecastStart.getTime() + step*dtMin*60000);
          gForecastTimes[step]=t;

          // 嵐係数
          const stormInfo = getStormFactorAtTime(t, gStormModel, cfg);
          const stormFactor = stormInfo.factor;
          gStormFactors[step] = stormFactor;
          gStormPhaseLabels[step] = stormInfo.phase;

          const delta = solarDeclinationRad(t);
          const lonS  = subsolarLongitudeDeg(t);
          const rad = Math.PI/180;
          const frame = new Array(nLat);

          for (let i=0;i<nLat;i++) {
            frame[i]=new Array(nLon);
            const lat=latArr[i];
            const phi=lat*rad;
            const sinphi=Math.sin(phi);
            const cosphi=Math.cos(phi);
            const wLat = computeLatWeight(lat,cfg);
            for (let j=0;j<nLon;j++) {
              const lon=lonArr[j];
              const lam=lon*rad;
              const h=lam - lonS*rad;
              const c = sinphi*Math.sin(delta)+cosphi*Math.cos(delta)*Math.cos(h);
              const fDay = c>0 ? Math.pow(c,pX) : 0;
              let T = T0[i][j] + Aamp[i][j]*fDay;
              if (T<0) T=0;
              const scale = cfg.kGlobal * Ssolar * Sflare * wLat;
              let val = T*scale;

              // 正層嵐ブースト
              val *= stormFactor;

              // 指定範囲バイアス適用
              if (gBiasRect) {
                const b = gBiasRect;
                if (lat >= b.latMin && lat <= b.latMax && lon >= b.lonMin && lon <= b.lonMax) {
                  val *= (1 + b.pct/100);
                }
              }

              frame[i][j] = val;
            }
          }
          // V字補正
          gForecastFrames[step] = fixLocalVShape(frame,nLat,nLon,0.9);
        }

        const slider = document.getElementById("timeSlider");
        slider.min=0; slider.max=nSteps; slider.value=0;
        currentStepIndex = 0;
        updateTimeLabel();
        logInfo(`予報計算完了: frames=${gForecastFrames.length}, grid=${nLat}×${nLon}`);
        drawTecOverlay();
        updateFormulaText();
      } catch(e) {
        logInfo("エラー: "+e.message);
        console.error(e);
      }
    }

    /* ===== TEC カラー関数 ===== */
    function hexToRgb(hex) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return m ? {
        r: parseInt(m[1], 16),
        g: parseInt(m[2], 16),
        b: parseInt(m[3], 16)
      } : {r:0,g:0,b:0};
    }

    function interpolateColor(c1, c2, t) {
      const rgb1 = hexToRgb(c1);
      const rgb2 = hexToRgb(c2);
      const r = Math.round(rgb1.r + (rgb2.r - rgb1.r)*t);
      const g = Math.round(rgb1.g + (rgb2.g - rgb1.g)*t);
      const b = Math.round(rgb1.b + (rgb2.b - rgb1.b)*t);
      return `#${r.toString(16).padStart(2,"0")}${g.toString(16).padStart(2,"0")}${b.toString(16).padStart(2,"0")}`;
    }

    function tecColorHex(val) {
      if (!gTecColorScale.length) return "#000000";
      const scale = gTecColorScale;
      const maxLimit = scale[scale.length-1].limit;
      if (val <= scale[0].limit) return scale[0].color;
      if (val >= maxLimit) return scale[scale.length-1].color;
      let lower = scale[0], upper = scale[scale.length-1];
      for (let i=0;i<scale.length-1;i++) {
        if (val <= scale[i+1].limit) {
          lower = scale[i];
          upper = scale[i+1];
          break;
        }
      }
      const range = upper.limit - lower.limit;
      const t = range > 0 ? (val - lower.limit)/range : 0;
      return interpolateColor(lower.color, upper.color, t);
    }

    function tecColorRGBA(val, alpha) {
      const hex = tecColorHex(val);
      const rgb = hexToRgb(hex);
      return `rgba(${rgb.r},${rgb.g},${rgb.b},${alpha})`;
    }

    function getTecGradientCSS() {
      const scale = gTecColorScale;
      if (!scale.length) return "none";
      const maxLimit = scale[scale.length-1].limit;
      const steps = 40;
      const stops = [];
      for (let k=0;k<=steps;k++) {
        const v = maxLimit * k / steps;
        const col = tecColorHex(v);
        const pct = 100*(1 - k/steps); // 上がMAX
        stops.push(`${col} ${pct}%`);
      }
      return `linear-gradient(to top, ${stops.join(",")})`;
    }

    /* ===== Leaflet 地図 & TEC Overlay ===== */
    function initLeafletMap() {
      map = L.map("tecMap", {
        worldCopyJump: false,
        maxBounds: [[-90,-180],[90,180]],
        maxBoundsViscosity: 0.7,
        zoomSnap: 0.25,
        zoomDelta: 0.5
      }).setView([0, 130], 2.0);

      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 6,
        minZoom: 1,
        attribution: "&copy; OpenStreetMap contributors"
      }).addTo(map);

      // TEC 用 Canvas Overlay
      tecCanvas = document.createElement("canvas");
      tecCanvas.className = "tec-canvas-overlay";
      const overlayPane = map.getPanes().overlayPane;
      overlayPane.appendChild(tecCanvas);
      resizeTecCanvas();

      map.on("moveend zoomend", drawTecOverlay);
      map.on("resize", () => {
        resizeTecCanvas();
        drawTecOverlay();
      });

      map.on("click", onMapClick);

      // TEC 凡例
      tecLegendControl = L.control({position:"bottomright"});
      tecLegendControl.onAdd = function() {
        const div = L.DomUtil.create("div", "leaflet-control tec-legend");
        div.innerHTML = `
          <div class="tec-legend-title">TEC [TECU]</div>
          <div class="tec-legend-bar"></div>
          <div class="tec-legend-labels">
            <span id="tecLegendMax">Max</span>
            <span id="tecLegendMin">0</span>
          </div>
        `;
        return div;
      };
      tecLegendControl.addTo(map);
      updateTecLegend();

      // 既存バイアス矩形の描画
      updateBiasRectOverlay();
    }

    function resizeTecCanvas() {
      if (!map || !tecCanvas) return;
      const size = map.getSize();
      tecCanvas.width = size.x;
      tecCanvas.height = size.y;
      tecCtx = tecCanvas.getContext("2d");
    }

    function updateTecLegend() {
      if (!map || !tecLegendControl) return;
      const container = tecLegendControl.getContainer();
      if (!container) return;
      const bar = container.querySelector(".tec-legend-bar");
      if (bar) {
        bar.style.background = getTecGradientCSS();
      }
      const maxSpan = container.querySelector("#tecLegendMax");
      const minSpan = container.querySelector("#tecLegendMin");
      if (maxSpan) {
        const maxLimit = gTecColorScale[gTecColorScale.length-1].limit;
        maxSpan.textContent = maxLimit.toFixed(0);
      }
      if (minSpan) {
        minSpan.textContent = "0";
      }
    }

    function updateTimeLabel() {
      const slider = document.getElementById("timeSlider");
      const idx = parseInt(slider.value,10) || 0;
      currentStepIndex = idx;
      const h  = (idx*15)/60;
      let label = `t = ${h.toFixed(2)} h`;
      if (gForecastTimes[idx]) {
        label += "  (UTC " + gForecastTimes[idx].toISOString().replace("T"," ").replace(".000Z","Z") + ")";
      }
      document.getElementById("timeLabel").textContent = label;

      const phaseText = gStormPhaseLabels[idx] || "嵐フェーズ: 静穏";
      document.getElementById("stormPhaseLabel").textContent = phaseText;
    }

    function drawTecOverlay() {
      if (!map || !tecCtx) return;
      const size = map.getSize();
      tecCtx.clearRect(0,0,size.x,size.y);

      if (!gForecastFrames.length || !gGrid) return;

      const frame = gForecastFrames[currentStepIndex] || gForecastFrames[0];
      const {nLat, nLon, latArr, lonArr} = gGrid;
      if (nLat<2 || nLon<2) return;

      const alphaSlider = document.getElementById("tecAlpha");
      tecAlpha = alphaSlider ? (parseFloat(alphaSlider.value)||0.8) : 0.8;

      const dLat = latArr[1] - latArr[0];
      const dLon = lonArr[1] - lonArr[0];

      for (let i=0;i<nLat;i++) {
        const latC = latArr[i];
        let lat1 = latC - dLat/2;
        let lat2 = latC + dLat/2;
        if (i===0)      lat1 = -90;
        if (i===nLat-1) lat2 =  90;

        for (let j=0;j<nLon;j++) {
          const lonC = lonArr[j];
          let lon1 = lonC - dLon/2;
          let lon2 = lonC + dLon/2;
          if (j===0)      lon1 = -180;
          if (j===nLon-1) lon2 =  180;

          const v = frame[i][j];
          if (!isFinite(v)) continue;
          const color = tecColorRGBA(v, tecAlpha);

          const p1 = map.latLngToLayerPoint([lat1, lon1]);
          const p2 = map.latLngToLayerPoint([lat1, lon2]);
          const p3 = map.latLngToLayerPoint([lat2, lon2]);
          const p4 = map.latLngToLayerPoint([lat2, lon1]);

          const minX = Math.min(p1.x, p2.x, p3.x, p4.x);
          const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
          const minY = Math.min(p1.y, p2.y, p3.y, p4.y);
          const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);
          if (maxX < 0 || maxY < 0 || minX > size.x || minY > size.y) continue;

          tecCtx.beginPath();
          tecCtx.moveTo(p1.x, p1.y);
          tecCtx.lineTo(p2.x, p2.y);
          tecCtx.lineTo(p3.x, p3.y);
          tecCtx.lineTo(p4.x, p4.y);
          tecCtx.closePath();
          tecCtx.fillStyle = color;
          tecCtx.fill();
        }
      }
    }

    function onSliderChange() {
      updateTimeLabel();
      drawTecOverlay();
    }

    function onTecAlphaChange() {
      const alphaSlider = document.getElementById("tecAlpha");
      tecAlpha = alphaSlider ? (parseFloat(alphaSlider.value)||0.8) : 0.8;
      drawTecOverlay();
    }

    /* ===== TEC値クリック表示（Leafletクリック） ===== */
    function findNearestIndex(value, arr) {
      let bestIdx = 0;
      let bestDiff = Infinity;
      for (let i=0;i<arr.length;i++) {
        const d = Math.abs(value - arr[i]);
        if (d < bestDiff) {
          bestDiff = d;
          bestIdx = i;
        }
      }
      return bestIdx;
    }

    function normalizeLonForGrid(lon, lonArr) {
      const minLon = Math.min(...lonArr);
      const maxLon = Math.max(...lonArr);
      if (minLon >= 0 && maxLon > 180) {
        if (lon < 0) lon += 360;
      }
      return lon;
    }

    function onMapClick(e) {
      if (!gForecastFrames.length || !gGrid) return;
      const {latArr, lonArr, nLat, nLon} = gGrid;
      const lat = e.latlng.lat;
      let lon = e.latlng.lng;
      lon = normalizeLonForGrid(lon, lonArr);

      const i = findNearestIndex(lat, latArr);
      const j = findNearestIndex(lon, lonArr);

      const frame = gForecastFrames[currentStepIndex] || gForecastFrames[0];
      const v = frame[i][j];
      const t = gForecastTimes[currentStepIndex] || gForecastTimes[0];

      const phaseText = gStormPhaseLabels[currentStepIndex] || "嵐フェーズ: 静穏";
      const info = `lat ≈ ${latArr[i].toFixed(1)}°, lon ≈ ${lonArr[j].toFixed(1)}°\n` +
                   `TEC ≈ ${v.toFixed(2)} TECU\n` +
                   `t(UTC) = ${t.toISOString().replace("T"," ").replace(".000Z","Z")}\n\n` +
                   `${phaseText}`;
      document.getElementById("pointInfo").textContent = info;
    }

    /* ===== 検証ロジック ===== */
    function runVerification() {
      if (!gForecastFrames.length || !gGrid || !gForecastTimes.length) {
        logInfo("まず予報を計算してください。");
        return;
      }
      const texts = [
        document.getElementById("verifyInput1").value,
        document.getElementById("verifyInput2").value,
        document.getElementById("verifyInput3").value,
        document.getElementById("verifyInput4").value
      ];
      const snaps=[];
      const msgs=[];
      for (let i=0;i<texts.length;i++) {
        const t=texts[i];
        if (!t.trim()) continue;
        try {
          const b=parseBoM(t);
          snaps.push(b);
          msgs.push(`Verify #${i+1}: VALID=${b.validTime ? b.validTime.toISOString():"不明"}`);
        } catch(e) {
          msgs.push(`Verify #${i+1}: エラー → ${e.message}`);
        }
      }
      if (!snaps.length) {
        logInfo("検証用 BoM がありません。");
        document.getElementById("verifyReport").textContent="検証用 BoM がありません。";
        return;
      }
      const {nLat,nLon,latArr,lonArr} = gGrid;
      for (const s of snaps) {
        if (s.nLat!==nLat || s.nLon!==nLon) {
          document.getElementById("verifyReport").textContent="予報と検証で格子サイズが異なります。";
          return;
        }
      }

      const latBands=[-90,-30,30,90];
      const lonBands=[-180,-60,60,180];
      const nZoneLat=3, nZoneLon=3;
      const sumAbsRel = Array.from({length:nZoneLat},()=>Array(nZoneLon).fill(0));
      const sumBias   = Array.from({length:nZoneLat},()=>Array(nZoneLon).fill(0));
      const sumObs    = Array.from({length:nZoneLat},()=>Array(nZoneLon).fill(0));
      const count     = Array.from({length:nZoneLat},()=>Array(nZoneLon).fill(0));

      function findStepForTime(time) {
        let best=-1, bestDt=1e12;
        for (let k=0;k<gForecastTimes.length;k++) {
          const dt = Math.abs(gForecastTimes[k]-time)/3600000;
          if (dt<bestDt) { bestDt=dt; best=k; }
        }
        return (bestDt<=2)? best : -1;
      }

      for (const s of snaps) {
        const step = s.validTime ? findStepForTime(s.validTime) : -1;
        if (step<0) continue;
        const frame = gForecastFrames[step];
        for (let i=0;i<nLat;i++) {
          const lat=latArr[i];
          let il=-1;
          for (let b=0;b<3;b++) {
            if (lat>=latBands[b] && lat<latBands[b+1]) { il=b; break; }
          }
          if (il<0) continue;
          for (let j=0;j<nLon;j++) {
            const lon=lonArr[j];
            let jl=-1;
            for (let b=0;b<3;b++) {
              if (lon>=lonBands[b] && lon<lonBands[b+1]) { jl=b; break; }
            }
            if (jl<0) continue;
            const obs=s.grid[i][j];
            const fc =frame[i][j];
            if (!isFinite(obs) || obs<=0 || !isFinite(fc)) continue;
            const rel = Math.abs(fc-obs)/obs*100;
            const bias=fc-obs;
            sumAbsRel[il][jl]+=rel;
            sumBias[il][jl]+=bias;
            sumObs[il][jl]+=obs;
            count[il][jl]++;
          }
        }
      }

      const reportLines=[];
      reportLines.push(msgs.join("\n"));
      reportLines.push("");
      reportLines.push("領域ごとの誤差（lat×lon を3×3分割）:");
      const zones=[];
      for (let il=0;il<3;il++) {
        for (let jl=0;jl<3;jl++) {
          const c = count[il][jl];
          if (!c) {
            zones.push({il,jl,MAPE:NaN,Bias:NaN});
            continue;
          }
          const mape=sumAbsRel[il][jl]/c;
          const bias=sumBias[il][jl]/c;
          zones.push({il,jl,MAPE:mape,Bias:bias});
          reportLines.push(
            `Lat[${latBands[il]},${latBands[il+1]}) Lon[${lonBands[jl]},${lonBands[jl+1]}) ` +
            `: MAPE=${mape.toFixed(1)}%, Bias=${bias.toFixed(2)} TECU`
          );
        }
      }

      const cfg=getConfigFromUI();
      let sumBiasAll=0,sumObsAll=0, nAll=0;
      for (let il=0;il<3;il++) {
        for (let jl=0;jl<3;jl++) {
          const c = count[il][jl];
          if (!c) continue;
          sumBiasAll += sumBias[il][jl];
          sumObsAll  += sumObs[il][jl];
          nAll       += c;
        }
      }
      reportLines.push("");
      reportLines.push("=== 係数調整の簡易提案 ===");
      if (nAll>0 && sumObsAll>0) {
        const avgBias = sumBiasAll/nAll;
        const avgObs  = sumObsAll/nAll;
        const relBias = avgBias/avgObs; // 正→過大評価
        const thr = cfg.biasThresh/100;
        if (Math.abs(relBias) < thr) {
          reportLines.push("・全体として大きなバイアスはありません。係数はそのままでOK。");
        } else {
          if (relBias>0) {
            reportLines.push("・全体的に TEC をやや過大評価しています。");
            const newK = cfg.kGlobal*(1 - cfg.suggestGain*relBias);
            reportLines.push(`  → kGlobal を ${cfg.kGlobal.toFixed(3)} → ${newK.toFixed(3)} 方向で調整するとよいかもしれません。`);
          } else {
            reportLines.push("・全体的に TEC をやや過小評価しています。");
            const newK = cfg.kGlobal*(1 - cfg.suggestGain*relBias);
            reportLines.push(`  → kGlobal を ${cfg.kGlobal.toFixed(3)} → ${newK.toFixed(3)} 方向で調整するとよいかもしれません。`);
          }
        }
      } else {
        reportLines.push("・有効なデータ点が少ないため、明確な提案は出せません。");
      }
      reportLines.push("・低緯度日中だけズレが大きい場合 → F10.7係数(wF107) や pX(日中指数) を微調整。");
      reportLines.push("・高緯度だけ過大/過小の場合 → latHighCut を 0.4〜0.7 程度で調整。");
      reportLines.push("・フレア影響を過大評価している場合 → β_flare, k_X, k_M を少し下げる。");

      const rep = reportLines.join("\n");
      document.getElementById("verifyReport").textContent = rep;

      lastVerifyResult = {
        zones,
        latBands,
        lonBands
      };
      drawVerifyMap(lastVerifyResult);
    }

    function clearVerification() {
      lastVerifyResult=null;
      document.getElementById("verifyReport").textContent="(まだ検証されていません)";
      const c=document.getElementById("verifyCanvas");
      const ctx=c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);
    }

    function drawVerifyMap(result) {
      const canvas=document.getElementById("verifyCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0,0,w,h);
      ctx.fillStyle="#050814";
      ctx.fillRect(0,0,w,h);
      if (!result||!result.zones) return;

      const cellW=w/3, cellH=h/3;
      ctx.font="10px system-ui";
      ctx.textAlign="center";
      ctx.textBaseline="middle";

      for (const z of result.zones) {
        const il=z.il, jl=z.jl;
        const x=jl*cellW;
        const y=(2-il)*cellH; // 北を上に
        let col="#333";
        if (isFinite(z.MAPE)) {
          for (const lvl of gVerifyColorScale) {
            if (z.MAPE <= lvl.limit) { col=lvl.color; break; }
          }
        }
        ctx.fillStyle=col;
        ctx.globalAlpha=0.8;
        ctx.fillRect(x+1,y+1,cellW-2,cellH-2);
        ctx.globalAlpha=1.0;
        ctx.strokeStyle="#111827";
        ctx.strokeRect(x+0.5,y+0.5,cellW-1,cellH-1);

        const textLines=[];
        if (isFinite(z.MAPE)) textLines.push(`MAPE ${z.MAPE.toFixed(1)}%`);
        else textLines.push("データなし");
        if (isFinite(z.Bias)) {
          const sign = z.Bias>0 ? "+" : "";
          textLines.push(`Bias ${sign}${z.Bias.toFixed(1)}`);
        }
        const cx=x+cellW/2, cy=y+cellH/2;
        ctx.fillStyle="#000";
        const dy=-6;
        for (let i=0;i<textLines.length;i++) {
          ctx.fillText(textLines[i], cx, cy + dy + i*12);
        }
      }
      ctx.fillStyle="#fff";
      ctx.font="9px system-ui";
      ctx.textAlign="left";
      ctx.fillText("検証 3×3 誤差マップ", 4,10);
    }

    /* ===== フォーカス機能 ===== */
    function onFocusPresetChange() {
      const preset = document.getElementById("focusPreset").value;
      let latMin=-90,latMax=90,lonMin=-180,lonMax=180;
      if (preset === "japan") {
        latMin=20; latMax=50; lonMin=120; lonMax=150;
      } else if (preset==="europe") {
        latMin=35; latMax=70; lonMin=-10; lonMax=40;
      } else if (preset==="na") {
        latMin=10; latMax=60; lonMin=-130; lonMax=-60;
      } else if (preset==="sa") {
        latMin=-60; latMax=15; lonMin=-80; lonMax=-30;
      } else if (preset==="africa") {
        latMin=-35; latMax=35; lonMin=-20; lonMax=50;
      } else if (preset==="global") {
        latMin=-90; latMax=90; lonMin=-180; lonMax=180;
      } else if (preset==="custom") {
        // カスタムは既存値そのまま
        return;
      }
      document.getElementById("focusLatMin").value = latMin;
      document.getElementById("focusLatMax").value = latMax;
      document.getElementById("focusLonMin").value = lonMin;
      document.getElementById("focusLonMax").value = lonMax;
      applyFocusRegion();
    }

    function applyFocusRegion() {
      if (!map) return;
      const latMin = parseFloat(document.getElementById("focusLatMin").value);
      const latMax = parseFloat(document.getElementById("focusLatMax").value);
      const lonMin = parseFloat(document.getElementById("focusLonMin").value);
      const lonMax = parseFloat(document.getElementById("focusLonMax").value);

      if (!isFinite(latMin) || !isFinite(latMax) || !isFinite(lonMin) || !isFinite(lonMax)) {
        logInfo("フォーカス範囲の緯度・経度が不正です。");
        return;
      }
      const bounds = [[latMin, lonMin],[latMax, lonMax]];
      map.fitBounds(bounds, {padding:[20,20]});

      if (focusRectLayer) {
        map.removeLayer(focusRectLayer);
      }
      focusRectLayer = L.rectangle(bounds, {
        color:"#22c55e",
        weight:1,
        fill:false
      }).addTo(map);
    }

    /* ===== リセット ===== */
    function resetAll() {
      gGrid=null;
      gForecastFrames=[];
      gForecastTimes=[];
      gForecastStart=null;
      currentStepIndex = 0;
      gStormModel = null;
      gStormFactors = [];
      gStormPhaseLabels = [];
      document.getElementById("timeSlider").value=0;
      updateTimeLabel();
      drawTecOverlay();
      clearVerification();
      document.getElementById("pointInfo").textContent =
        "地図上をクリックすると、その格子点のTECと位置が表示されます。";
      logInfo("内部状態をリセットしました。（BoM/係数/色/指定範囲バイアスの保存値は残っています）");
    }

    /* ===== レイアウト ===== */
    function resizeLayout() {
      if (map) {
        map.invalidateSize();
        resizeTecCanvas();
        drawTecOverlay();
      }
      const ver=document.getElementById("verifyCanvas");
      if (ver) {
        drawVerifyMap(lastVerifyResult);
      }
    }

    window.addEventListener("resize", resizeLayout);

    /* ===== 計算式テキスト ===== */
    function updateFormulaText() {
      const cfg = getConfigFromUI();
      const stormModel = gStormModel || {hasStorm:false,S:0,levelText:"静穏"};
      const lines = [];

      lines.push("TEC(lat, lon, t) =");
      lines.push("  ( T0(lat,lon) + A_amp(lat,lon) × f_day(lat,lon,t) )");
      lines.push("  × kGlobal");
      lines.push("  × SolarScale(F10.7, Ap, Dst, Xray)");
      lines.push("  × FlareScale(Deep Flare Net)");
      lines.push("  × LatWeight(lat)");
      lines.push("  × StormBoost(t)");
      lines.push("  × BiasRegion(lat, lon)");
      lines.push("");
      lines.push("where");
      lines.push(`  SolarScale = 1 + wF107·(F10.7-100) + wAp·(Ap-10) + wDst·Dst + Xray項`);
      lines.push(`    wF107 = ${cfg.wF107}, wAp = ${cfg.wAp}, wDst = ${cfg.wDst}`);
      lines.push("");
      lines.push("  LatWeight(lat) : 赤道異常 + 高緯度減衰");
      lines.push(`    latShape = ${cfg.latShape}, latHighCut = ${cfg.latHighCut}`);
      lines.push("");
      lines.push("  FlareScale : Deep Flare Net の X/M確率から係数を計算");
      lines.push(`    β_flare = ${cfg.betaFlare}, k_X = ${cfg.kX}, k_M = ${cfg.kM}`);
      lines.push("");
      lines.push("  StormBoost(t) : CME / 高速太陽風による電離圏正層嵐ブースト（正のみ）");
      lines.push("    ・到達から kStormOnsetH 時間後に磁気嵐開始");
      lines.push("    ・そこから kStormPeakH 時間でピークまで増加");
      lines.push("    ・さらに kStormRecoverH 時間かけて指数減衰で静穏へ");
      lines.push(`    kStormOnsetH = ${cfg.kStormOnsetH} h`);
      lines.push(`    kStormPeakH  = ${cfg.kStormPeakH} h`);
      lines.push(`    kStormRecoverH = ${cfg.kStormRecoverH} h`);
      lines.push(`    kStormBoost = ${cfg.kStormBoost}, kStormDecay = ${cfg.kStormDecay}`);
      if (stormModel && stormModel.hasStorm && stormModel.baseTime) {
        lines.push(`    StormIndex S = ${stormModel.S.toFixed(2)} （${stormModel.levelText}）`);
        lines.push(`    baseTime = ${stormModel.baseTime.toISOString()}`);
      } else {
        lines.push("    ※現在はStormイベント未設定 → StormBoost(t) ≒ 1");
      }
      lines.push("");
      if (gBiasRect) {
        lines.push("  BiasRegion(lat,lon): 指定範囲内のみ TEC×(1 + b%/100)");
        lines.push(`    lat[${gBiasRect.latMin},${gBiasRect.latMax}], lon[${gBiasRect.lonMin},${gBiasRect.lonMax}], b = ${gBiasRect.pct}%`);
      } else {
        lines.push("  BiasRegion(lat,lon): 現在バイアス無し（=1.0）");
      }

      document.getElementById("formulaText").textContent = lines.join("\n");
    }

    /* ===== 初期化 ===== */
    window.addEventListener("load", ()=>{
      loadConfig(true);
      loadVerifyColorScaleFromStorage();
      loadTecColorScaleFromStorage();
      loadBomInputsFromStorage();
      initLeafletMap();
      loadBiasRectFromStorage();

      updateTimeLabel();
      resizeLayout();
      updateFormulaText();

      logInfo("SWIFT-TEC v3 Leaflet版 準備完了。まず BoM TEC を貼り付けてください。");
    });
  </script>
</body>
</html>

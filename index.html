<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>SWIFT-TEC v3 – TEC Forecast & Verification Tool (Leaflet版)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #050816;
      color: #f5f5f5;
    }
    h1, h2, h3 {
      margin: 0 0 4px 0;
      letter-spacing: 0.03em;
    }
    h1 { font-size: 20px; }
    h2 { font-size: 16px; }
    h3 { font-size: 14px; }

    .page {
      display: flex;
      height: 100vh;
    }

    .sidebar {
      width: 430px;
      min-width: 360px;
      max-width: 480px;
      border-right: 1px solid #222b3f;
      padding: 10px;
      overflow-y: auto;
      background: radial-gradient(circle at top, #1c2740 0, #050814 55%, #050814 100%);
    }

    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 10px;
      gap: 8px;
      min-width: 0;
      overflow-y: auto;
    }

    .card {
      background: rgba(10, 16, 32, 0.96);
      border: 1px solid #222b3f;
      border-radius: 8px;
      padding: 8px;
      margin-bottom: 4px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.25);
    }
    .card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }
    .card-header span {
      font-size: 11px;
      opacity: 0.7;
    }

    textarea {
      width: 100%;
      min-height: 60px;
      resize: vertical;
      font-size: 11px;
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #334;
      background: #050814;
      color: #f5f5f5;
      font-family: "Consolas","Menlo",monospace;
    }
    input[type="number"],
    input[type="text"],
    input[type="color"],
    select {
      background: #050814;
      border-radius: 4px;
      border: 1px solid #334;
      color: #f5f5f5;
      font-size: 11px;
      padding: 2px 4px;
      font-family: inherit;
    }
    input[type="checkbox"] {
      transform: scale(0.9);
    }
    label {
      font-size: 11px;
    }
    .row {
      display: flex;
      gap: 6px;
      margin-bottom: 4px;
      align-items: center;
      flex-wrap: wrap;
    }
    .row > div {
      flex: 1;
      min-width: 80px;
    }
    button {
      border-radius: 4px;
      border: 1px solid #3b82f6;
      background: #1d4ed8;
      color: #f9fafb;
      padding: 3px 8px;
      font-size: 11px;
      cursor: pointer;
      font-weight: 500;
    }
    button.secondary {
      border-color: #4b5563;
      background: #111827;
    }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .small {
      font-size: 10px;
      opacity: 0.8;
    }
    pre {
      font-size: 11px;
      background: #050814;
      padding: 6px;
      border-radius: 4px;
      border: 1px solid #222b3f;
      white-space: pre-wrap;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 10px;
    }
    th, td {
      border: 1px solid #222b3f;
      padding: 2px 4px;
      text-align: center;
    }
    th {
      background: #111827;
    }
    .flex-col {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-card { flex: 0 0 auto; }
    .map-card {
      flex: 1 1 auto;
      min-height: 55vh;
      display: flex;
    }
    .output-card { flex: 0 0 auto; }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 11px;
      flex-wrap: wrap;
    }
    #timeSlider {
      flex: 1;
    }

    #tecMap {
      flex: 1;
      height: 100%;
      min-height: 360px;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    .leaflet-container {
      background: #000;
    }
    .tec-canvas-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .leaflet-control.tec-legend {
      background: rgba(5, 8, 20, 0.95);
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #222b3f;
      color: #f5f5f5;
      font-size: 10px;
      line-height: 1.3;
      box-shadow: 0 0 6px rgba(0,0,0,0.5);
    }
    .tec-legend-title {
      text-align: center;
      margin-bottom: 4px;
      font-weight: 600;
      letter-spacing: 0.05em;
    }
    .tec-legend-bar {
      width: 18px;
      height: 130px;
      margin: 0 auto 4px auto;
      border-radius: 4px;
      border: 1px solid #444;
      background-size: 100% 100%;
      background-repeat: no-repeat;
    }
    .tec-legend-labels {
      display: flex;
      justify-content: space-between;
      font-size: 9px;
    }

    #verifyCanvas {
      width: 220px;
      height: 220px;
      background: #050814;
      border-radius: 6px;
      border: 1px solid #222b3f;
    }

    .output-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .output-col {
      flex: 1;
      min-width: 200px;
      display: flex;
      flex-direction: column;
    }

    .output-col pre {
      max-height: 220px;
      overflow-y: auto;
    }

    hr {
      border: none;
      border-top: 1px solid #222b3f;
      margin: 4px 0;
    }

    .focus-btn {
      width: 100%;
      font-size: 9px;
      padding: 3px 2px;
    }
  </style>
</head>
<body>
  <div class="page">
    <!-- ============= サイドバー ============= -->
    <div class="sidebar">
      <div class="card">
        <div class="card-header">
          <h1>SWIFT-TEC v3</h1>
          <span>Global TEC Forecast & Verification</span>
        </div>
        <div class="small">
          ・BoM TEC（最大9枚）から 48h / 15min 予報を生成<br>
          ・F10.7 / Ap / Dst / X-ray / Deep Flare Net / 磁気嵐を反映<br>
          ・BoM 実測（最大4枚）で 3×3 領域ごとの誤差検証<br>
          ・Leaflet 地図で TEC / GPS誤差を確認、地域フォーカスも可能
        </div>
      </div>

      <!-- 1. BoM TEC 予報用 -->
      <div class="card">
        <div class="card-header">
          <h2>1. BoM TEC（予報用 最大9枚）</h2>
          <span>World0000_tec.txt などをコピペ</span>
        </div>
        <div class="row small">
          <div>BoM #1</div><div>BoM #2</div><div>BoM #3</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput1" placeholder="# PRODUCT NAME..."></textarea></div>
          <div><textarea id="bomInput2"></textarea></div>
          <div><textarea id="bomInput3"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #4</div><div>BoM #5</div><div>BoM #6</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput4"></textarea></div>
          <div><textarea id="bomInput5"></textarea></div>
          <div><textarea id="bomInput6"></textarea></div>
        </div>
        <div class="row small">
          <div>BoM #7</div><div>BoM #8</div><div>BoM #9</div>
        </div>
        <div class="row">
          <div><textarea id="bomInput7"></textarea></div>
          <div><textarea id="bomInput8"></textarea></div>
          <div><textarea id="bomInput9"></textarea></div>
        </div>
        <div class="row">
          <button onclick="saveBomInputs()">BoM入力を保存</button>
          <button class="secondary" onclick="clearBomInputsStorage()">保存を削除</button>
        </div>
        <div class="small" id="bomInfo">
          ※「BoM入力を保存」を押した時点の内容をブラウザに保存。次回起動時に自動復元。
        </div>
      </div>

      <!-- 2. 太陽活動パラメータ -->
      <div class="card">
        <div class="card-header">
          <h2>2. 太陽活動パラメータ</h2>
          <span>NOAA / 京都WDC / GOES 代表値</span>
        </div>
        <div class="row">
          <div>
            <label>F10.7 [sfu]</label><br>
            <input id="inpF107" type="number" value="150" step="1">
          </div>
          <div>
            <label>Ap Index</label><br>
            <input id="inpAp" type="number" value="10" step="1">
          </div>
          <div>
            <label>Dst [nT]</label><br>
            <input id="inpDst" type="number" value="-20" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>X-ray (代表値 W/m²)</label><br>
            <input id="inpXray" type="number" value="1e-6" step="1e-7">
          </div>
        </div>
        <div class="small">
          ※将来的に 27DO.txt / Kyoto Dst / GOES テキストから自動抽出も追加可能。<br>
          まずは代表値を手入力して挙動を確認。
        </div>
      </div>

      <!-- 3. Deep Flare Net 8領域 -->
      <div class="card">
        <div class="card-header">
          <h2>3. Deep Flare Net 領域</h2>
          <span>8分割フレア確率</span>
        </div>
        <div class="small">
          8領域ごとに Xクラス / Mクラス発生確率 [%] を入力。<br>
          同じ場所に複数領域がある場合は「特異なもののみ」入力。
        </div>
        <table>
          <thead>
            <tr>
              <th>ID</th><th>位置イメージ</th><th>P(X≥) %</th><th>P(M≥) %</th><th>使用</th>
            </tr>
          </thead>
          <tbody>
            <tr><td>R1</td><td>北西</td>
              <td><input id="fx1" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm1" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu1" type="checkbox" checked></td>
            </tr>
            <tr><td>R2</td><td>西</td>
              <td><input id="fx2" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm2" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu2" type="checkbox" checked></td>
            </tr>
            <tr><td>R3</td><td>南西</td>
              <td><input id="fx3" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm3" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu3" type="checkbox" checked></td>
            </tr>
            <tr><td>R4</td><td>南</td>
              <td><input id="fx4" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm4" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu4" type="checkbox" checked></td>
            </tr>
            <tr><td>R5</td><td>南東</td>
              <td><input id="fx5" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm5" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu5" type="checkbox" checked></td>
            </tr>
            <tr><td>R6</td><td>東</td>
              <td><input id="fx6" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm6" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu6" type="checkbox" checked></td>
            </tr>
            <tr><td>R7</td><td>北東</td>
              <td><input id="fx7" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm7" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu7" type="checkbox" checked></td>
            </tr>
            <tr><td>R8</td><td>中央</td>
              <td><input id="fx8" type="number" value="0" style="width:50px;"></td>
              <td><input id="fm8" type="number" value="10" style="width:50px;"></td>
              <td><input id="fu8" type="checkbox" checked></td>
            </tr>
          </tbody>
        </table>
      </div>

      <!-- 4. 検証用 BoM -->
      <div class="card">
        <div class="card-header">
          <h2>4. 検証用 BoM TEC（最大4枚）</h2>
          <span>予報期間中の実測</span>
        </div>
        <div class="row small">
          <div>Verify #1</div><div>Verify #2</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput1"></textarea></div>
          <div><textarea id="verifyInput2"></textarea></div>
        </div>
        <div class="row small">
          <div>Verify #3</div><div>Verify #4</div>
        </div>
        <div class="row">
          <div><textarea id="verifyInput3"></textarea></div>
          <div><textarea id="verifyInput4"></textarea></div>
        </div>
        <div class="row">
          <button onclick="runVerification()">検証を実行</button>
          <button class="secondary" onclick="clearVerification()">検証クリア</button>
        </div>
        <div class="small">
          検証では地球を緯度×経度で3×3の9領域に分割し、<br>
          各領域の平均TEC差（|予報−実測|）を算出します。
        </div>
      </div>

      <!-- 5. 検証マップ色設定 -->
      <div class="card">
        <div class="card-header">
          <h2>5. 検証マップ色設定</h2>
          <span>TEC差[TECU] → 色を任意設定</span>
        </div>
        <div class="small">
          TEC差の上限と色を設定。例）2 TECUまで緑、5まで黄、10までオレンジ、それ以上赤 など。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>TEC差上限</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="vLimit1" type="number" value="2" style="width:50px;"></td>
              <td><input id="vColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="vLimit2" type="number" value="5" style="width:50px;"></td>
              <td><input id="vColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="vLimit3" type="number" value="10" style="width:50px;"></td>
              <td><input id="vColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="vLimit4" type="number" value="999" style="width:50px;"></td>
              <td><input id="vColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyVerifyColorScale()">色設定を反映</button>
          <button class="secondary" onclick="resetVerifyColorScale()">初期化</button>
        </div>
      </div>

      <!-- 6. TEC カラーマップ設定 -->
      <div class="card">
        <div class="card-header">
          <h2>6. TEC カラーマップ設定</h2>
          <span>TEC値 → 色を任意設定</span>
        </div>
        <div class="small">
          TEC [TECU] の上限と色を設定。色は Leaflet 地図と凡例に反映されます。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>TEC上限[TECU]</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="tLimit1" type="number" value="10" style="width:60px;"></td>
              <td><input id="tColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="tLimit2" type="number" value="30" style="width:60px;"></td>
              <td><input id="tColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="tLimit3" type="number" value="60" style="width:60px;"></td>
              <td><input id="tColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="tLimit4" type="number" value="120" style="width:60px;"></td>
              <td><input id="tColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyTecColorScale()">TEC色を反映</button>
          <button class="secondary" onclick="resetTecColorScale()">初期化</button>
        </div>
      </div>

      <!-- 7. GPS L1誤差 カラーマップ設定 -->
      <div class="card">
        <div class="card-header">
          <h2>7. GPS L1誤差 カラーマップ</h2>
          <span>誤差[m] → 色を任意設定</span>
        </div>
        <div class="small">
          L1即位誤差 [m] の上限と色を設定。TEC×kL1 で換算。
        </div>
        <table>
          <thead>
            <tr><th>レベル</th><th>誤差上限[m]</th><th>色</th></tr>
          </thead>
          <tbody>
            <tr>
              <td>L1</td>
              <td><input id="gLimit1" type="number" value="5" style="width:60px;"></td>
              <td><input id="gColor1" type="color" value="#00ff00"></td>
            </tr>
            <tr>
              <td>L2</td>
              <td><input id="gLimit2" type="number" value="10" style="width:60px;"></td>
              <td><input id="gColor2" type="color" value="#ffff00"></td>
            </tr>
            <tr>
              <td>L3</td>
              <td><input id="gLimit3" type="number" value="20" style="width:60px;"></td>
              <td><input id="gColor3" type="color" value="#ff9900"></td>
            </tr>
            <tr>
              <td>L4</td>
              <td><input id="gLimit4" type="number" value="40" style="width:60px;"></td>
              <td><input id="gColor4" type="color" value="#ff0000"></td>
            </tr>
          </tbody>
        </table>
        <div class="row">
          <button onclick="applyGpsColorScale()">GPS色を反映</button>
          <button class="secondary" onclick="resetGpsColorScale()">初期化</button>
        </div>
      </div>

      <!-- 8. 磁気嵐 / 電離圏嵐パラメータ -->
      <div class="card">
        <div class="card-header">
          <h2>8. 磁気嵐 / 電離圏嵐パラメータ</h2>
          <span>CME / 高速太陽風 からの影響</span>
        </div>
        <div class="row">
          <div>
            <label>磁気嵐開始 [h]</label><br>
            <input id="stormStartH" type="number" value="0" step="1">
          </div>
          <div>
            <label>磁気嵐継続時間 [h]</label><br>
            <input id="stormDurH" type="number" value="0" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>磁気嵐強度 Kp (0–9)</label><br>
            <input id="stormKp" type="number" value="0" step="0.5" min="0" max="9">
          </div>
          <div>
            <label>電離圏嵐ピーク遅れ [h]</label><br>
            <input id="ionoDelayH" type="number" value="0" step="1">
          </div>
        </div>
        <div class="small">
          ※Kp=0 または 継続時間=0 の場合、磁気嵐・電離圏嵐のスケールは無効。<br>
          Smag = 1 + 0.3×(Kp/9), Siono = 1 + 0.5×(Kp/9) を掛け合わせて適用。
        </div>
      </div>

      <!-- 9. 係数設定 -->
      <div class="card">
        <div class="card-header">
          <h2>9. 係数設定（Advanced）</h2>
          <span>昼夜境界・フレア・GPS変換</span>
        </div>
        <div class="small">※いじり過ぎる前に現在値をどこかにメモ推奨。</div>
        <div class="flex-col">
          <div class="row">
            <div>
              <label>kGlobal（全体スケール）</label><br>
              <input id="cfg_kGlobal" type="number" value="0.55" step="0.05">
            </div>
            <div>
              <label>wF107</label><br>
              <input id="cfg_wF107" type="number" value="0.004" step="0.001">
            </div>
            <div>
              <label>wAp</label><br>
              <input id="cfg_wAp" type="number" value="0.01" step="0.002">
            </div>
          </div>
          <div class="row">
            <div>
              <label>wDst</label><br>
              <input id="cfg_wDst" type="number" value="-0.002" step="0.001">
            </div>
            <div>
              <label>pX（日中指数）</label><br>
              <input id="cfg_pX" type="number" value="0.2" step="0.05">
            </div>
            <div>
              <label>latShape（赤道異常）</label><br>
              <input id="cfg_latShape" type="number" value="0.45" step="0.05">
            </div>
          </div>
          <div class="row">
            <div>
              <label>latHighCut（高緯度減衰）</label><br>
              <input id="cfg_latHighCut" type="number" value="1.05" step="0.05">
            </div>
            <div>
              <label>β_flare</label><br>
              <input id="cfg_betaFlare" type="number" value="0.5" step="0.05">
            </div>
            <div>
              <label>k_X</label><br>
              <input id="cfg_kX" type="number" value="1.0" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>k_M</label><br>
              <input id="cfg_kM" type="number" value="0.3" step="0.1">
            </div>
            <div>
              <label>biasThresh%（提案閾値）</label><br>
              <input id="cfg_biasThresh" type="number" value="15" step="1">
            </div>
            <div>
              <label>suggestGain（提案の強さ）</label><br>
              <input id="cfg_suggestGain" type="number" value="0.5" step="0.1">
            </div>
          </div>
          <div class="row">
            <div>
              <label>dayEdgeCosWidth（昼夜境界の滑らかさ）</label><br>
              <input id="cfg_dayEdgeCosWidth" type="number" value="0.2" step="0.05">
            </div>
            <div>
              <label>kL1（TEC→L1誤差[m/TECU]）</label><br>
              <input id="cfg_kL1" type="number" value="0.16" step="0.01">
            </div>
          </div>
        </div>
        <div class="row">
          <button onclick="saveConfig()">設定を保存</button>
          <button class="secondary" onclick="loadConfig(true)">保存値を再読込</button>
        </div>
      </div>

      <!-- 10. 地域フォーカス -->
      <div class="card">
        <div class="card-header">
          <h2>10. 地域フォーカス</h2>
          <span>地図ズーム & 必要なら描画も制限</span>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('japan')">日本</button>
          <button class="focus-btn" onclick="focusRegion('northAmerica')">北アメリカ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('southAmerica')">南アメリカ</button>
          <button class="focus-btn" onclick="focusRegion('europe')">ヨーロッパ</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('africa')">アフリカ</button>
          <button class="focus-btn" onclick="focusRegion('australia')">オーストラリア</button>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('global')">全体図</button>
        </div>
        <hr>
        <div class="small">手動指定（緯度・経度）</div>
        <div class="row">
          <div>
            <label>Lat min</label><br>
            <input id="focusLatMin" type="number" value="-90" step="1">
          </div>
          <div>
            <label>Lat max</label><br>
            <input id="focusLatMax" type="number" value="90" step="1">
          </div>
        </div>
        <div class="row">
          <div>
            <label>Lon min</label><br>
            <input id="focusLonMin" type="number" value="-180" step="1">
          </div>
          <div>
            <label>Lon max</label><br>
            <input id="focusLonMax" type="number" value="180" step="1">
          </div>
        </div>
        <div class="row">
          <button class="focus-btn" onclick="focusRegion('manual')">手動フォーカス</button>
        </div>
        <div class="row small">
          <label><input id="maskFocus" type="checkbox"> フォーカス範囲のみ描画</label>
        </div>
      </div>

      <!-- 11. 実行 -->
      <div class="card">
        <div class="card-header">
          <h2>11. 実行</h2>
          <span>予報 & 描画</span>
        </div>
        <div class="row">
          <button onclick="runForecast()">TEC予報を計算</button>
          <button class="secondary" onclick="resetAll()">リセット</button>
        </div>
        <div id="runInfo" class="small"></div>
      </div>
    </div>

    <!-- ============= メイン領域 ============= -->
    <div class="main">
      <!-- 上段：時間スライダー＋透明度＋モード切替 -->
      <div class="card slider-card">
        <div class="slider-row">
          <span>時間スライダー（0〜48h / 15分刻み）</span>
          <input type="range" id="timeSlider" min="0" max="192" value="0" oninput="onSliderChange()">
          <span id="timeLabel">t = 0.00 h</span>
        </div>
        <div class="row small" style="margin-top:4px;">
          <div style="flex:1; min-width:160px;">
            TEC透明度:
            <input id="tecAlpha" type="range" min="0.2" max="1" step="0.05" value="0.8" style="width:140px;" oninput="onTecAlphaChange()">
          </div>
          <div style="flex:1; min-width:160px;">
            表示モード:
            <select id="mapModeSelect" onchange="onMapModeChange()">
              <option value="tec">TEC [TECU]</option>
              <option value="gps">GPS L1誤差 [m]</option>
            </select>
          </div>
          <div style="flex:2;">
            <span class="small">※地図をズーム／ドラッグして、任意の地域の分布を確認できます。</span>
          </div>
        </div>
      </div>

      <!-- 中段：Leaflet 地図 -->
      <div class="card map-card">
        <div id="tecMap"></div>
      </div>

      <!-- 下段：検証マップ＋レポート＋クリックTEC値 -->
      <div class="card output-card">
        <div class="output-row">
          <div class="output-col" style="flex:0 0 240px; max-width:260px;">
            <h3>12. 検証 3×3 マップ</h3>
            <canvas id="verifyCanvas"></canvas>
          </div>
          <div class="output-col" style="flex:2;">
            <h3>13. 検証レポート & 計算式</h3>
            <pre id="verifyReport">(まだ検証されていません)</pre>
          </div>
          <div class="output-col" style="flex:1;">
            <h3>14. 現在の値</h3>
            <pre id="pointInfo">地図上をクリックすると、その格子点のTEC/GPS誤差と位置が表示されます。</pre>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ============ グローバル状態 ============ */
    let gGrid = null;              // {latArr, lonArr, nLat, nLon}
    let gForecastFrames = [];      // [step][iLat][iLon] (TEC)
    let gForecastTimes = [];       // Date[]
    let gForecastStart = null;     // Date
    let currentStepIndex = 0;

    let gVerifyColorScale = [
      { limit: 2,   color: "#00ff00" },
      { limit: 5,   color: "#ffff00" },
      { limit: 10,  color: "#ff9900" },
      { limit: 999, color: "#ff0000" }
    ];

    // TEC カラー
    let gTecColorScale = [
      { limit: 10,  color: "#00ff00" },
      { limit: 30,  color: "#ffff00" },
      { limit: 60,  color: "#ff9900" },
      { limit: 120, color: "#ff0000" }
    ];

    // GPS L1 誤差カラー
    let gGpsColorScale = [
      { limit: 5,  color: "#00ff00" },
      { limit: 10, color: "#ffff00" },
      { limit: 20, color: "#ff9900" },
      { limit: 40, color: "#ff0000" }
    ];

    // Leaflet 関連
    let map = null;
    let tecCanvas = null;
    let tecCtx = null;
    let tecLegendControl = null;
    let tecAlpha = 0.8;

    // 検証結果
    let lastVerifyResult = null;

    // マップ表示モード ('tec' | 'gps')
    let mapMode = "tec";

    // 地域フォーカス情報
    let currentFocusBounds = null;   // {latMin,latMax,lonMin,lonMax} or null

    const STORAGE_KEY_CONFIG   = "swifttec_config_v4";
    const STORAGE_KEY_VCOL     = "swifttec_vcol_v4";
    const STORAGE_KEY_BOM      = "swifttec_bom_inputs_v4";
    const STORAGE_KEY_TCOL     = "swifttec_teccol_v4";
    const STORAGE_KEY_GCOL     = "swifttec_gpscol_v1";

    function logInfo(msg) {
      const div = document.getElementById("runInfo");
      if (div) div.textContent = msg;
      console.log(msg);
    }
    function clamp(v, a, b) { return v < a ? a : (v > b ? b : v); }

    /* ===== 日付パース: VALID DATE/TIME: 11/11/2025 00:00:00UTC ===== */
    function parseBomValidTime(text) {
      const lines = text.split(/\r?\n/);
      for (const line of lines) {
        const m = line.match(/VALID DATE\/TIME:\s*(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2}):(\d{2})/i);
        if (m) {
          const d  = parseInt(m[1],10);
          const mo = parseInt(m[2],10);
          const y  = parseInt(m[3],10);
          const hh = parseInt(m[4],10);
          const mm = parseInt(m[5],10);
          const ss = parseInt(m[6],10);
          return new Date(Date.UTC(y, mo-1, d, hh, mm, ss));
        }
      }
      return null;
    }

    /* ====== BoM TEC テキスト → 格子データ ====== */
    function parseBoM(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
      if (!lines.length) throw new Error("空のテキストです。");

      let latMin, latMax, latStep, nLat;
      let lonMin, lonMax, lonStep, nLon;

      for (const line of lines) {
        if (/LATITUDE GRID/i.test(line)) {
          const m = line.match(/LATITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            latMin  = parseFloat(m[1]);
            latMax  = parseFloat(m[2]);
            latStep = parseFloat(m[3]);
            nLat    = parseInt(m[4],10);
          }
        } else if (/LONGITUDE GRID/i.test(line)) {
          const m = line.match(/LONGITUDE GRID.*:\s*([-\d.]+)\s+([-\d.]+)\s+([-\d.]+)\s+(\d+)/i);
          if (m) {
            lonMin  = parseFloat(m[1]);
            lonMax  = parseFloat(m[2]);
            lonStep = parseFloat(m[3]);
            nLon    = parseInt(m[4],10);
          }
        }
      }
      if (latMin === undefined || lonMin === undefined) {
        throw new Error("LATITUDE/LONGITUDE GRID 情報が見つかりません。");
      }

      const valLines = lines.filter(l => !l.trim().startsWith("#") && !/GRID/i.test(l));
      const values = [];
      for (const ln of valLines) {
        const parts = ln.split(/[, ]+/).map(x => x.trim()).filter(x => x.length>0);
        for (const p of parts) {
          const v = parseFloat(p);
          if (!isNaN(v)) values.push(v);
        }
      }
      if (values.length !== nLat*nLon) {
        throw new Error(`データ数が不一致です: ${values.length} vs ${nLat*nLon}`);
      }

      const latArr = [];
      for (let i=0;i<nLat;i++) latArr.push(latMin + latStep*i);
      const lonArr = [];
      for (let j=0;j<nLon;j++) lonArr.push(lonMin + lonStep*j);

      const grid = new Array(nLat);
      let idx = 0;
      for (let i=0;i<nLat;i++) {
        grid[i] = new Array(nLon);
        for (let j=0;j<nLon;j++) {
          grid[i][j] = values[idx++];
        }
      }

      const validTime = parseBomValidTime(text);
      return { latArr, lonArr, nLat, nLon, grid, validTime };
    }

    /* ============ BoM 入力保存 ============ */
    function saveBomInputs() {
      const data = {};
      for (let k=1;k<=9;k++) {
        const el = document.getElementById("bomInput"+k);
        data["bomInput"+k] = el ? el.value : "";
      }
      localStorage.setItem(STORAGE_KEY_BOM, JSON.stringify(data));
      logInfo("BoM入力を保存しました。（次回起動時に自動復元）");
    }

    function loadBomInputsFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_BOM);
      if (!s) return;
      try {
        const data = JSON.parse(s);
        for (let k=1;k<=9;k++) {
          const key = "bomInput"+k;
          if (data[key] !== undefined) {
            const el = document.getElementById(key);
            if (el) el.value = data[key];
          }
        }
      } catch(e) {
        console.warn("BoM入力の復元に失敗:", e);
      }
    }

    function clearBomInputsStorage() {
      localStorage.removeItem(STORAGE_KEY_BOM);
      logInfo("保存されていた BoM 入力を削除しました。（テキスト内容はそのまま）");
    }

    /* ============ Config（係数） ============ */
    function getConfigFromUI() {
      return {
        kGlobal:     parseFloat(document.getElementById("cfg_kGlobal").value)  || 0.55,
        wF107:       parseFloat(document.getElementById("cfg_wF107").value)    || 0.004,
        wAp:         parseFloat(document.getElementById("cfg_wAp").value)      || 0.01,
        wDst:        parseFloat(document.getElementById("cfg_wDst").value)     || -0.002,
        pX:          parseFloat(document.getElementById("cfg_pX").value)       || 0.2,
        latShape:    parseFloat(document.getElementById("cfg_latShape").value) || 0.45,
        latHighCut:  parseFloat(document.getElementById("cfg_latHighCut").value) || 1.05,
        betaFlare:   parseFloat(document.getElementById("cfg_betaFlare").value)|| 0.5,
        kX:          parseFloat(document.getElementById("cfg_kX").value)       || 1.0,
        kM:          parseFloat(document.getElementById("cfg_kM").value)       || 0.3,
        biasThresh:  parseFloat(document.getElementById("cfg_biasThresh").value)|| 15,
        suggestGain: parseFloat(document.getElementById("cfg_suggestGain").value)|| 0.5,
        dayEdgeCosWidth: parseFloat(document.getElementById("cfg_dayEdgeCosWidth").value) || 0.2,
        kL1:         parseFloat(document.getElementById("cfg_kL1").value)      || 0.16
      };
    }

    function applyConfigToUI(cfg) {
      document.getElementById("cfg_kGlobal").value     = cfg.kGlobal;
      document.getElementById("cfg_wF107").value       = cfg.wF107;
      document.getElementById("cfg_wAp").value         = cfg.wAp;
      document.getElementById("cfg_wDst").value        = cfg.wDst;
      document.getElementById("cfg_pX").value          = cfg.pX;
      document.getElementById("cfg_latShape").value    = cfg.latShape;
      document.getElementById("cfg_latHighCut").value  = cfg.latHighCut;
      document.getElementById("cfg_betaFlare").value   = cfg.betaFlare;
      document.getElementById("cfg_kX").value          = cfg.kX;
      document.getElementById("cfg_kM").value          = cfg.kM;
      document.getElementById("cfg_biasThresh").value  = cfg.biasThresh;
      document.getElementById("cfg_suggestGain").value = cfg.suggestGain;
      document.getElementById("cfg_dayEdgeCosWidth").value = cfg.dayEdgeCosWidth ?? 0.2;
      document.getElementById("cfg_kL1").value         = cfg.kL1 ?? 0.16;
    }

    function saveConfig() {
      const cfg = getConfigFromUI();
      localStorage.setItem(STORAGE_KEY_CONFIG, JSON.stringify(cfg));
      logInfo("係数設定を保存しました。");
    }

    function loadConfig(apply) {
      const s = localStorage.getItem(STORAGE_KEY_CONFIG);
      if (!s) {
        if (apply) logInfo("保存された係数がありません。初期値を使用。");
        return null;
      }
      try {
        const cfgRaw = JSON.parse(s);
        const merged = Object.assign({
          kGlobal:0.55, wF107:0.004, wAp:0.01, wDst:-0.002,
          pX:0.2, latShape:0.45, latHighCut:1.05,
          betaFlare:0.5, kX:1.0, kM:0.3,
          biasThresh:15, suggestGain:0.5,
          dayEdgeCosWidth:0.2, kL1:0.16
        }, cfgRaw);
        if (apply) applyConfigToUI(merged);
        return merged;
      } catch(e) {
        console.warn("Configの復元に失敗:", e);
        return null;
      }
    }

    /* ============ 検証マップ色設定 ============ */
    function applyVerifyColorScale() {
      const limits = [
        parseFloat(document.getElementById("vLimit1").value) || 2,
        parseFloat(document.getElementById("vLimit2").value) || 5,
        parseFloat(document.getElementById("vLimit3").value) || 10,
        parseFloat(document.getElementById("vLimit4").value) || 999
      ];
      const cols = [
        document.getElementById("vColor1").value || "#00ff00",
        document.getElementById("vColor2").value || "#ffff00",
        document.getElementById("vColor3").value || "#ff9900",
        document.getElementById("vColor4").value || "#ff0000"
      ];
      gVerifyColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_VCOL, JSON.stringify(gVerifyColorScale));
      logInfo("検証色スケールを保存しました。");
      drawVerifyMap(lastVerifyResult);
    }

    function resetVerifyColorScale() {
      gVerifyColorScale = [
        { limit: 2,   color: "#00ff00" },
        { limit: 5,   color: "#ffff00" },
        { limit: 10,  color: "#ff9900" },
        { limit: 999, color: "#ff0000" }
      ];
      document.getElementById("vLimit1").value = 2;
      document.getElementById("vLimit2").value = 5;
      document.getElementById("vLimit3").value = 10;
      document.getElementById("vLimit4").value = 999;
      document.getElementById("vColor1").value = "#00ff00";
      document.getElementById("vColor2").value = "#ffff00";
      document.getElementById("vColor3").value = "#ff9900";
      document.getElementById("vColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_VCOL, JSON.stringify(gVerifyColorScale));
      drawVerifyMap(lastVerifyResult);
    }

    function loadVerifyColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_VCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gVerifyColorScale = arr;
        document.getElementById("vLimit1").value = arr[0].limit;
        document.getElementById("vLimit2").value = arr[1].limit;
        document.getElementById("vLimit3").value = arr[2].limit;
        document.getElementById("vLimit4").value = arr[3].limit;
        document.getElementById("vColor1").value = arr[0].color;
        document.getElementById("vColor2").value = arr[1].color;
        document.getElementById("vColor3").value = arr[2].color;
        document.getElementById("vColor4").value = arr[3].color;
      } catch(e) {
        console.warn("検証色スケール復元に失敗:", e);
      }
    }

    /* ============ TEC / GPS カラーマップ設定 ============ */
    function applyTecColorScale() {
      const limits = [
        parseFloat(document.getElementById("tLimit1").value) || 10,
        parseFloat(document.getElementById("tLimit2").value) || 30,
        parseFloat(document.getElementById("tLimit3").value) || 60,
        parseFloat(document.getElementById("tLimit4").value) || 120
      ];
      const cols = [
        document.getElementById("tColor1").value || "#00ff00",
        document.getElementById("tColor2").value || "#ffff00",
        document.getElementById("tColor3").value || "#ff9900",
        document.getElementById("tColor4").value || "#ff0000"
      ];
      gTecColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      logInfo("TECカラースケールを保存しました。");
      updateLegend();
      drawTecOverlay();
    }

    function resetTecColorScale() {
      gTecColorScale = [
        { limit: 10,  color: "#00ff00" },
        { limit: 30,  color: "#ffff00" },
        { limit: 60,  color: "#ff9900" },
        { limit: 120, color: "#ff0000" }
      ];
      document.getElementById("tLimit1").value = 10;
      document.getElementById("tLimit2").value = 30;
      document.getElementById("tLimit3").value = 60;
      document.getElementById("tLimit4").value = 120;
      document.getElementById("tColor1").value = "#00ff00";
      document.getElementById("tColor2").value = "#ffff00";
      document.getElementById("tColor3").value = "#ff9900";
      document.getElementById("tColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_TCOL, JSON.stringify(gTecColorScale));
      updateLegend();
      drawTecOverlay();
    }

    function loadTecColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_TCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gTecColorScale = arr;
        document.getElementById("tLimit1").value = arr[0].limit;
        document.getElementById("tLimit2").value = arr[1].limit;
        document.getElementById("tLimit3").value = arr[2].limit;
        document.getElementById("tLimit4").value = arr[3].limit;
        document.getElementById("tColor1").value = arr[0].color;
        document.getElementById("tColor2").value = arr[1].color;
        document.getElementById("tColor3").value = arr[2].color;
        document.getElementById("tColor4").value = arr[3].color;
      } catch(e) {
        console.warn("TEC色スケール復元に失敗:", e);
      }
    }

    function applyGpsColorScale() {
      const limits = [
        parseFloat(document.getElementById("gLimit1").value) || 5,
        parseFloat(document.getElementById("gLimit2").value) || 10,
        parseFloat(document.getElementById("gLimit3").value) || 20,
        parseFloat(document.getElementById("gLimit4").value) || 40
      ];
      const cols = [
        document.getElementById("gColor1").value || "#00ff00",
        document.getElementById("gColor2").value || "#ffff00",
        document.getElementById("gColor3").value || "#ff9900",
        document.getElementById("gColor4").value || "#ff0000"
      ];
      gGpsColorScale = [
        { limit: limits[0], color: cols[0] },
        { limit: limits[1], color: cols[1] },
        { limit: limits[2], color: cols[2] },
        { limit: limits[3], color: cols[3] }
      ];
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      logInfo("GPSカラースケールを保存しました。");
      updateLegend();
      drawTecOverlay();
    }

    function resetGpsColorScale() {
      gGpsColorScale = [
        { limit: 5,  color: "#00ff00" },
        { limit: 10, color: "#ffff00" },
        { limit: 20, color: "#ff9900" },
        { limit: 40, color: "#ff0000" }
      ];
      document.getElementById("gLimit1").value = 5;
      document.getElementById("gLimit2").value = 10;
      document.getElementById("gLimit3").value = 20;
      document.getElementById("gLimit4").value = 40;
      document.getElementById("gColor1").value = "#00ff00";
      document.getElementById("gColor2").value = "#ffff00";
      document.getElementById("gColor3").value = "#ff9900";
      document.getElementById("gColor4").value = "#ff0000";
      localStorage.setItem(STORAGE_KEY_GCOL, JSON.stringify(gGpsColorScale));
      updateLegend();
      drawTecOverlay();
    }

    function loadGpsColorScaleFromStorage() {
      const s = localStorage.getItem(STORAGE_KEY_GCOL);
      if (!s) return;
      try {
        const arr = JSON.parse(s);
        if (!Array.isArray(arr) || arr.length !== 4) return;
        gGpsColorScale = arr;
        document.getElementById("gLimit1").value = arr[0].limit;
        document.getElementById("gLimit2").value = arr[1].limit;
        document.getElementById("gLimit3").value = arr[2].limit;
        document.getElementById("gLimit4").value = arr[3].limit;
        document.getElementById("gColor1").value = arr[0].color;
        document.getElementById("gColor2").value = arr[1].color;
        document.getElementById("gColor3").value = arr[2].color;
        document.getElementById("gColor4").value = arr[3].color;
      } catch(e) {
        console.warn("GPS色スケール復元に失敗:", e);
      }
    }

    /* ============ カラー取得ヘルパ ============ */
    function getColorForValue(v, scaleArr) {
      let c = scaleArr[scaleArr.length - 1].color;
      for (let i = 0; i < scaleArr.length; i++) {
        if (v <= scaleArr[i].limit) {
          c = scaleArr[i].color;
          break;
        }
      }
      return c;
    }

    /* ============ Leaflet 初期化 ============ */
    function initMap() {
      map = L.map('tecMap', {
        worldCopyJump: true,
        center: [20, 135],
        zoom: 2,
        minZoom: 1,
        maxZoom: 6
      });

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // Canvas を overlayPane に配置
      tecCanvas = document.createElement('canvas');
      tecCanvas.className = 'tec-canvas-overlay';
      tecCtx = tecCanvas.getContext('2d');
      const pane = map.getPanes().overlayPane;
      pane.appendChild(tecCanvas);

      map.on('moveend', () => drawTecOverlay());
      map.on('zoomend', () => drawTecOverlay());
      map.on('resize', () => resizeTecCanvas());
      map.on('click', onMapClick);

      resizeTecCanvas();
      setupLegend();
    }

    function resizeTecCanvas() {
      if (!map || !tecCanvas) return;
      const size = map.getSize();
      tecCanvas.width = size.x;
      tecCanvas.height = size.y;
      tecCanvas.style.width = size.x + 'px';
      tecCanvas.style.height = size.y + 'px';
      drawTecOverlay();
    }

    function setupLegend() {
      if (tecLegendControl) {
        map.removeControl(tecLegendControl);
      }
      tecLegendControl = L.control({position:'bottomright'});
      tecLegendControl.onAdd = function() {
        const div = L.DomUtil.create('div', 'tec-legend');
        const title = document.createElement('div');
        title.className = 'tec-legend-title';
        title.id = 'legendTitle';
        title.textContent = 'TEC [TECU]';
        div.appendChild(title);

        const bar = document.createElement('div');
        bar.className = 'tec-legend-bar';
        bar.id = 'legendBar';
        div.appendChild(bar);

        const labels = document.createElement('div');
        labels.className = 'tec-legend-labels';
        labels.id = 'legendLabels';
        labels.innerHTML = '<span>Low</span><span>High</span>';
        div.appendChild(labels);

        return div;
      };
      tecLegendControl.addTo(map);
      updateLegend();
    }

    function createLegendGradient(scaleArr) {
      const gradCanvas = document.createElement('canvas');
      gradCanvas.width = 1;
      gradCanvas.height = 256;
      const ctx = gradCanvas.getContext('2d');

      const maxLimit = scaleArr[scaleArr.length - 1].limit;
      const sorted = scaleArr.slice().sort((a,b)=>a.limit-b.limit);

      const grad = ctx.createLinearGradient(0, 0, 0, 256);
      for (let i=0;i<sorted.length;i++) {
        const stop = sorted[i].limit / maxLimit;
        grad.addColorStop(1 - clamp(stop,0,1), sorted[i].color);
      }
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,1,256);

      return gradCanvas.toDataURL();
    }

    function updateLegend() {
      const titleEl = document.getElementById('legendTitle');
      const barEl   = document.getElementById('legendBar');
      const labelsEl= document.getElementById('legendLabels');
      if (!titleEl || !barEl || !labelsEl) return;

      if (mapMode === 'tec') {
        titleEl.textContent = 'TEC [TECU]';
        const url = createLegendGradient(gTecColorScale);
        if (url) barEl.style.backgroundImage = `url(${url})`;
      } else {
        titleEl.textContent = 'GPS L1誤差 [m]';
        const url = createLegendGradient(gGpsColorScale);
        if (url) barEl.style.backgroundImage = `url(${url})`;
      }
      labelsEl.innerHTML = '<span>Low</span><span>High</span>';
    }

    /* ============ 緯度シェイプ：BoMをそのまま使う ============ */
    function getLatShapeFactor(latDeg, cfg) {
      // ★緯度による増減はかけず、BoMの緯度プロファイルをそのまま使用
      return 1.0;
    }

    /* ============ 昼夜因子（cosχ + dayEdgeCosWidth） ============ */
    function computeDayFactor(latDeg, lonDeg, timeUTC, cfg) {
      const utcHours = timeUTC.getUTCHours() + timeUTC.getUTCMinutes()/60;
      const localHours = (utcHours + lonDeg/15 + 24) % 24;
      const hourAngle = (localHours - 12) * 15;
      const rad = Math.PI/180;
      const chi = Math.acos(
        Math.cos(latDeg*rad)*Math.cos(0)*Math.cos(hourAngle*rad) +
        Math.sin(latDeg*rad)*Math.sin(0)
      );
      const cosChi = Math.cos(chi);
      const pX = cfg.pX;
      const w = cfg.dayEdgeCosWidth || 0.2;

      let f;
      if (cosChi <= -w) {
        f = 0.0;
      } else if (cosChi >= w) {
        f = 1.0;
      } else {
        const t = (cosChi + w)/(2*w);
        f = 0.5 - 0.5*Math.cos(Math.PI*t);
      }
      const dayBoost = Math.pow(Math.max(f,0), pX);
      return dayBoost;
    }

    /* ============ 磁気嵐 / 電離圏嵐スケール ============ */
    function getStormScale(tRelH, stormStartH, stormDurH, stormKp, ionoDelayH) {
      if (!isFinite(tRelH) || stormDurH <= 0 || stormKp <= 0) return 1.0;
      const kpNorm = clamp(stormKp/9.0, 0, 1);

      let Smag = 1.0;
      let Siono = 1.0;

      if (tRelH >= stormStartH && tRelH <= stormStartH + stormDurH) {
        Smag = 1 + 0.3 * kpNorm;
      }
      if (tRelH >= stormStartH + ionoDelayH &&
          tRelH <= stormStartH + ionoDelayH + stormDurH) {
        Siono = 1 + 0.5 * kpNorm;
      }
      return Smag * Siono;
    }

    /* ============ フレアスケール（Deep Flare Net 簡易版） ============ */
    function getFlareScale(latDeg, lonDeg, cfg) {
      let sumM = 0, sumX = 0;
      for (let i=1;i<=8;i++) {
        const use = document.getElementById('fu'+i).checked;
        if (!use) continue;
        const px = parseFloat(document.getElementById('fx'+i).value) || 0;
        const pm = parseFloat(document.getElementById('fm'+i).value) || 0;
        sumX += Math.max(px,0);
        sumM += Math.max(pm,0);
      }
      const normM = clamp(sumM/100, 0, 3);
      const normX = clamp(sumX/100, 0, 3);

      const beta = cfg.betaFlare || 0.5;
      const kX = cfg.kX || 1.0;
      const kM = cfg.kM || 0.3;

      const s = 1 + beta * (kM * normM + kX * normX);
      return Math.max(0.5, Math.min(3.0, s));
    }

    /* ============ BoM セットから予報フレームを構築 ============ */
    function collectBomGrids() {
      const texts = [];
      for (let k=1;k<=9;k++) {
        const el = document.getElementById('bomInput'+k);
        if (el && el.value.trim().length>0) {
          texts.push(el.value);
        }
      }
      if (!texts.length) throw new Error("BoM予報テキストが1つもありません。");

      const bomList = [];
      let baseGrid = null;
      for (const t of texts) {
        const parsed = parseBoM(t);
        if (!parsed.validTime) {
          throw new Error("BoMテキストから VALID DATE/TIME が取得できません。");
        }
        if (!baseGrid) {
          baseGrid = parsed;
        } else {
          if (parsed.nLat !== baseGrid.nLat || parsed.nLon !== baseGrid.nLon) {
            throw new Error("BoMファイル同士でグリッドサイズが異なります。");
          }
        }
        bomList.push(parsed);
      }
      bomList.sort((a,b)=>a.validTime - b.validTime);

      gGrid = {
        latArr: bomList[0].latArr,
        lonArr: bomList[0].lonArr,
        nLat:   bomList[0].nLat,
        nLon:   bomList[0].nLon
      };
      return bomList;
    }

    function buildForecastFrames() {
      const bomList = collectBomGrids();
      const cfg = getConfigFromUI();

      const F107 = parseFloat(document.getElementById('inpF107').value) || 150;
      const Ap   = parseFloat(document.getElementById('inpAp').value)   || 10;
      const Dst  = parseFloat(document.getElementById('inpDst').value)  || -20;

      const stormStartH = parseFloat(document.getElementById('stormStartH').value) || 0;
      const stormDurH   = parseFloat(document.getElementById('stormDurH').value)   || 0;
      const stormKp     = parseFloat(document.getElementById('stormKp').value)     || 0;
      const ionoDelayH  = parseFloat(document.getElementById('ionoDelayH').value)  || 0;

      const startTime = bomList[0].validTime;
      gForecastStart = startTime;

      const totalHours = 48;
      const stepMin = 15;
      const steps = Math.round(totalHours * 60 / stepMin);
      gForecastFrames = [];
      gForecastTimes  = [];

      function getInterpolatedBomGrid(t) {
        if (bomList.length === 1) {
          return bomList[0].grid;
        }
        let i1 = 0;
        let i2 = bomList.length - 1;
        for (let i=0;i<bomList.length;i++) {
          if (bomList[i].validTime <= t) i1 = i;
          if (bomList[i].validTime >= t) { i2 = i; break; }
        }
        if (i1 === i2) {
          return bomList[i1].grid;
        }
        const t1 = bomList[i1].validTime.getTime();
        const t2 = bomList[i2].validTime.getTime();
        const tt = t.getTime();
        const ratio = clamp((tt - t1)/(t2 - t1), 0, 1);

        const nLat = gGrid.nLat;
        const nLon = gGrid.nLon;
        const g1 = bomList[i1].grid;
        const g2 = bomList[i2].grid;
        const out = new Array(nLat);
        for (let i=0;i<nLat;i++) {
          out[i] = new Array(nLon);
          for (let j=0;j<nLon;j++) {
            const v1 = g1[i][j];
            const v2 = g2[i][j];
            out[i][j] = v1 + (v2 - v1) * ratio;
          }
        }
        return out;
      }

      for (let k=0;k<=steps;k++) {
        const tMin = k * stepMin;
        const tHour = tMin / 60;
        const t = new Date(startTime.getTime() + tMin*60000);
        gForecastTimes.push(t);

        const baseGrid = getInterpolatedBomGrid(t);
        const nLat = gGrid.nLat;
        const nLon = gGrid.nLon;
        const frame = new Array(nLat);

        const solarFactor = 1 +
          cfg.wF107 * (F107 - 100) +
          cfg.wAp   * Ap +
          cfg.wDst  * (Dst / 100.0);

        const stormFactor = getStormScale(tHour, stormStartH, stormDurH, stormKp, ionoDelayH);

        for (let i=0;i<nLat;i++) {
          frame[i] = new Array(nLon);
          const lat = gGrid.latArr[i];
          for (let j=0;j<nLon;j++) {
            const lon = gGrid.lonArr[j];
            const baseTec = baseGrid[i][j];

            const dayFactor   = computeDayFactor(lat, lon, t, cfg);
            const latFactor   = getLatShapeFactor(lat, cfg); // =1.0
            const flareFactor = getFlareScale(lat, lon, cfg);

            let tec = baseTec * cfg.kGlobal * dayFactor * latFactor * solarFactor * flareFactor * stormFactor;
            if (!isFinite(tec)) tec = 0;
            if (tec < 0) tec = 0;
            frame[i][j] = tec;
          }
        }
        gForecastFrames.push(frame);
      }

      smoothForecastFrames();
    }

    /* ============ 3×3スパイク平滑化 ============ */
    function smoothForecastFrames() {
      if (!gForecastFrames.length || !gGrid) return;
      const nLat = gGrid.nLat;
      const nLon = gGrid.nLon;

      for (let s=0;s<gForecastFrames.length;s++) {
        const fr = gForecastFrames[s];
        const copy = fr.map(row => row.slice());
        for (let i=1;i<nLat-1;i++) {
          for (let j=1;j<nLon-1;j++) {
            let sum=0, cnt=0;
            for (let di=-1;di<=1;di++) {
              for (let dj=-1;dj<=1;dj++) {
                sum += copy[i+di][j+dj];
                cnt++;
              }
            }
            const avg = cnt>0 ? sum/cnt : copy[i][j];
            const v = copy[i][j];
            if (avg>0 && (v > 1.5*avg || v < 0.7*avg)) {
              fr[i][j] = v*0.3 + avg*0.7;
            }
          }
        }
      }
    }

    /* ============ TEC/GPS ヒートマップ描画 ============ */
    function drawTecOverlay() {
      if (!map || !tecCanvas || !tecCtx) return;
      if (!gGrid || !gForecastFrames.length) {
        tecCtx.clearRect(0,0,tecCanvas.width, tecCanvas.height);
        return;
      }
      const size = map.getSize();
      tecCtx.clearRect(0,0,size.x,size.y);
      tecCtx.globalAlpha = tecAlpha;

      const frame = gForecastFrames[currentStepIndex] || gForecastFrames[0];
      const cfg = getConfigFromUI();
      const useGps = (mapMode === 'gps');

      const latArr = gGrid.latArr;
      const lonArr = gGrid.lonArr;
      const nLat = gGrid.nLat;
      const nLon = gGrid.nLon;

      const mask = document.getElementById('maskFocus').checked;
      let latMin=-90, latMax=90, lonMin=-180, lonMax=180;
      if (mask && currentFocusBounds) {
        latMin = currentFocusBounds.latMin;
        latMax = currentFocusBounds.latMax;
        lonMin = currentFocusBounds.lonMin;
        lonMax = currentFocusBounds.lonMax;
      }

      for (let i=0;i<nLat-1;i++) {
        const lat0 = latArr[i];
        const lat1 = latArr[i+1];
        const latC = (lat0+lat1)/2;
        if (latC < latMin || latC > latMax) continue;

        for (let j=0;j<nLon-1;j++) {
          const lon0 = lonArr[j];
          const lon1 = lonArr[j+1];
          let lonC = (lon0+lon1)/2;
          if (lonC < lonMin || lonC > lonMax) continue;

          let tec = frame[i][j];
          if (!isFinite(tec)) continue;

          let value = tec;
          let colScale = gTecColorScale;
          if (useGps) {
            value = tec * cfg.kL1;
            colScale = gGpsColorScale;
          }

          const color = getColorForValue(value, colScale);
          tecCtx.fillStyle = color;

          const p0 = map.latLngToContainerPoint([lat0, lon0]);
          const p1 = map.latLngToContainerPoint([lat1, lon1]);

          const x = Math.min(p0.x, p1.x);
          const y = Math.min(p0.y, p1.y);
          const w = Math.abs(p1.x - p0.x);
          const h = Math.abs(p1.y - p0.y);

          if (w<=0 || h<=0) continue;
          tecCtx.fillRect(x, y, w, h);
        }
      }
    }

    /* ============ 地域フォーカス ============ */
    function focusRegion(key) {
      let latMin, latMax, lonMin, lonMax;
      if (key === 'japan') {
        latMin = 20; latMax = 50; lonMin = 120; lonMax = 150;
      } else if (key === 'northAmerica') {
        latMin = 10; latMax = 60; lonMin = -160; lonMax = -20;
      } else if (key === 'southAmerica') {
        latMin = -60; latMax = 10; lonMin = -90; lonMax = -30;
      } else if (key === 'europe') {
        latMin = 30; latMax = 70; lonMin = -20; lonMax = 40;
      } else if (key === 'africa') {
        latMin = -40; latMax = 35; lonMin = -20; lonMax = 55;
      } else if (key === 'australia') {
        latMin = -50; latMax = 0; lonMin = 110; lonMax = 160;
      } else if (key === 'manual') {
        latMin = parseFloat(document.getElementById('focusLatMin').value) || -90;
        latMax = parseFloat(document.getElementById('focusLatMax').value) || 90;
        lonMin = parseFloat(document.getElementById('focusLonMin').value) || -180;
        lonMax = parseFloat(document.getElementById('focusLonMax').value) || 180;
      } else if (key === 'global') {
        latMin = -90; latMax = 90; lonMin = -180; lonMax = 180;
      } else {
        latMin = -90; latMax = 90; lonMin = -180; lonMax = 180;
      }

      document.getElementById('focusLatMin').value = latMin;
      document.getElementById('focusLatMax').value = latMax;
      document.getElementById('focusLonMin').value = lonMin;
      document.getElementById('focusLonMax').value = lonMax;

      currentFocusBounds = {latMin,latMax,lonMin,lonMax};

      if (map) {
        map.fitBounds([[latMin, lonMin],[latMax, lonMax]]);
      }
      drawTecOverlay();
    }

    /* ============ スライダー・モード・透明度 ============ */
    function onSliderChange() {
      const slider = document.getElementById('timeSlider');
      currentStepIndex = parseInt(slider.value, 10) || 0;
      const t = gForecastTimes[currentStepIndex];
      let label = "t = " + (currentStepIndex * 0.25).toFixed(2) + " h";
      if (t instanceof Date) {
        label += " (UTC " + t.toISOString().replace('T',' ').substring(0,19) + ")";
      }
      document.getElementById('timeLabel').textContent = label;
      drawTecOverlay();
    }

    function onTecAlphaChange() {
      const v = parseFloat(document.getElementById('tecAlpha').value) || 0.8;
      tecAlpha = clamp(v,0.1,1);
      drawTecOverlay();
    }

    function onMapModeChange() {
      const sel = document.getElementById('mapModeSelect');
      mapMode = sel.value;
      updateLegend();
      drawTecOverlay();
    }

    /* ============ 地図クリックで値を表示 ============ */
    function onMapClick(e) {
      if (!gGrid || !gForecastFrames.length) return;
      const lat = e.latlng.lat;
      const lon = e.latlng.lng;

      const latArr = gGrid.latArr;
      const lonArr = gGrid.lonArr;

      let iBest = 0, jBest = 0;
      let dBest = 1e9;
      for (let i=0;i<latArr.length;i++) {
        const dLat = Math.abs(latArr[i] - lat);
        for (let j=0;j<lonArr.length;j++) {
          const dLon = Math.abs(lonArr[j] - lon);
          const d = dLat + dLon;
          if (d < dBest) {
            dBest = d;
            iBest = i;
            jBest = j;
          }
        }
      }

      const frame = gForecastFrames[currentStepIndex] || gForecastFrames[0];
      const tec = frame[iBest][jBest];
      const cfg = getConfigFromUI();
      const gpsErr = tec * cfg.kL1;

      const latC = latArr[iBest];
      const lonC = lonArr[jBest];

      let txt = "";
      txt += `格子中心: lat=${latC.toFixed(1)}°, lon=${lonC.toFixed(1)}°\n`;
      txt += `TEC: ${tec.toFixed(2)} TECU\n`;
      txt += `GPS L1誤差(推定): ${(gpsErr).toFixed(2)} m\n`;
      txt += `モード: ${mapMode === 'tec' ? 'TEC表示' : 'GPS L1表示'}\n`;
      document.getElementById('pointInfo').textContent = txt;
    }

    /* ============ 検証（TEC差ベース） ============ */
    function runVerification() {
      if (!gGrid || !gForecastFrames.length) {
        alert("まず BoM から予報を計算してください。");
        return;
      }
      const txt = document.getElementById('verifyInput1').value;
      if (!txt.trim()) {
        alert("Verify #1 に BoM フォーマットの実測TECを貼り付けてください。");
        return;
      }
      let parsed;
      try {
        parsed = parseBoM(txt);
      } catch(e) {
        alert("検証用 BoM のパースに失敗: " + e.message);
        return;
      }
      if (parsed.nLat !== gGrid.nLat || parsed.nLon !== gGrid.nLon) {
        alert("予報グリッドと検証グリッドのサイズが一致しません。");
        return;
      }

      const frame = gForecastFrames[currentStepIndex] || gForecastFrames[0];
      const gridV = parsed.grid;

      const nLat = gGrid.nLat;
      const nLon = gGrid.nLon;

      const regionLatIdx = [
        {i0:0,             i1:Math.floor(nLat/3)-1},
        {i0:Math.floor(nLat/3), i1:Math.floor(2*nLat/3)-1},
        {i0:Math.floor(2*nLat/3), i1:nLat-1}
      ];
      const regionLonIdx = [
        {j0:0,              j1:Math.floor(nLon/3)-1},
        {j0:Math.floor(nLon/3), j1:Math.floor(2*nLon/3)-1},
        {j0:Math.floor(2*nLon/3), j1:nLon-1}
      ];

      const result = [];
      let globalSum = 0, globalCnt = 0;
      for (let ry=0;ry<3;ry++) {
        result[ry] = [];
        const i0 = regionLatIdx[ry].i0;
        const i1 = regionLatIdx[ry].i1;
        for (let rx=0;rx<3;rx++) {
          const j0 = regionLonIdx[rx].j0;
          const j1 = regionLonIdx[rx].j1;

          let sumAbsDiff = 0;
          let cnt = 0;
          for (let i=i0;i<=i1;i++) {
            for (let j=j0;j<=j1;j++) {
              const f = frame[i][j];
              const v = gridV[i][j];
              if (!isFinite(f) || !isFinite(v)) continue;
              const diff = Math.abs(f - v);
              sumAbsDiff += diff;
              cnt++;
            }
          }
          const meanDiff = cnt>0 ? sumAbsDiff/cnt : 0;
          globalSum += sumAbsDiff;
          globalCnt += cnt;
          result[ry][rx] = {meanDiff};
        }
      }
      const globalMean = globalCnt>0 ? globalSum/globalCnt : 0;
      lastVerifyResult = {regions:result, globalMean};
      drawVerifyMap(lastVerifyResult);
      updateVerifyReport(lastVerifyResult);
      logInfo("検証（TEC差ベース）を更新しました。");
    }

    function clearVerification() {
      lastVerifyResult = null;
      const canvas = document.getElementById('verifyCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      document.getElementById('verifyReport').textContent = "(まだ検証されていません)";
    }

    function drawVerifyMap(res) {
      const canvas = document.getElementById('verifyCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      if (!res) return;

      const W = canvas.width;
      const H = canvas.height;
      const cellW = W/3;
      const cellH = H/3;

      for (let ry=0;ry<3;ry++) {
        for (let rx=0;rx<3;rx++) {
          const r = res.regions[ry][rx];
          const v = r.meanDiff;
          const col = getColorForValue(v, gVerifyColorScale);
          ctx.fillStyle = col;
          const x = rx*cellW;
          const y = (2-ry)*cellH;
          ctx.fillRect(x,y,cellW,cellH);

          ctx.strokeStyle = "#111827";
          ctx.lineWidth = 1;
          ctx.strokeRect(x,y,cellW,cellH);

          ctx.fillStyle = "#ffffff";
          ctx.font = "10px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(v.toFixed(1)+" TECU", x+cellW/2, y+cellH/2);
        }
      }
    }

    function updateVerifyReport(res) {
      const pre = document.getElementById('verifyReport');
      if (!res) {
        pre.textContent = "(まだ検証されていません)";
        return;
      }
      let txt = "";
      txt += "=== TEC差 検証結果（現在のスライダー時刻） ===\n";
      txt += "3×3各領域の平均 |予報−実測| [TECU]\n\n";
      const nameRow = ["西","中央","東"];
      const nameCol = ["南","中緯度","北"];
      for (let ry=0;ry<3;ry++) {
        for (let rx=0;rx<3;rx++) {
          const r = res.regions[ry][rx];
          txt += `${nameCol[ry]}×${nameRow[rx]}: ${r.meanDiff.toFixed(2)} TECU\n`;
        }
      }
      txt += "\n全体平均TEC差: " + res.globalMean.toFixed(2) + " TECU\n";

      const cfg = getConfigFromUI();
      txt += "\n=== 現在の予報計算式（概略） ===\n";
      txt += "TEC_forecast = TEC_BoM\n";
      txt += `  × kGlobal(${cfg.kGlobal})\n`;
      txt += "  × dayFactor(cosχ, pX="+cfg.pX+", width="+cfg.dayEdgeCosWidth+")\n";
      txt += `  × [ 1 + wF107(${cfg.wF107})*(F10.7-100) + wAp(${cfg.wAp})*Ap + wDst(${cfg.wDst})*(Dst/100) ]\n`;
      txt += "  × flareFactor(Deep Flare Net, β_flare="+cfg.betaFlare+", kM="+cfg.kM+", kX="+cfg.kX+")\n";
      txt += "  × stormFactor(Kp, stormStartH, stormDurH, ionoDelayH)\n";
      txt += "\nGPS L1誤差[m] ≒ TEC_forecast × kL1("+cfg.kL1+")\n";

      pre.textContent = txt;
    }

    /* ============ 予報実行 ============ */
    function runForecast() {
      try {
        buildForecastFrames();
        document.getElementById('timeSlider').value = 0;
        currentStepIndex = 0;
        onSliderChange();
        drawTecOverlay();
        logInfo("TEC予報を計算しました。");
      } catch(e) {
        console.error(e);
        alert("予報計算中にエラー: " + e.message);
      }
    }

    /* ============ 全リセット ============ */
    function resetAll() {
      if (!confirm("すべての設定とローカル保存を初期化しますか？")) return;
      localStorage.removeItem(STORAGE_KEY_CONFIG);
      localStorage.removeItem(STORAGE_KEY_VCOL);
      localStorage.removeItem(STORAGE_KEY_TCOL);
      localStorage.removeItem(STORAGE_KEY_GCOL);
      localStorage.removeItem(STORAGE_KEY_BOM);
      location.reload();
    }

    /* ============ 起動時処理 ============ */
    window.addEventListener('load', () => {
      initMap();
      loadConfig(true);
      loadVerifyColorScaleFromStorage();
      loadTecColorScaleFromStorage();
      loadGpsColorScaleFromStorage();
      loadBomInputsFromStorage();
      onSliderChange();
      updateLegend();
      logInfo("SWIFT-TEC v3 初期化完了。BoMを貼り付けて「TEC予報を計算」を押してください。");
    });
  </script>
</body>
</html>
